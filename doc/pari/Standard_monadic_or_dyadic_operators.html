<HTML>
<HEAD>
  <TITLE>
    Catalogue of GP/PARI Functions: Standard monadic or dyadic operators
  </TITLE>

  <META NAME="author"       CONTENT="Nils-Peter Skoruppa">
  <META NAME="created"      CONTENT="Thu Apr 27 10:11:36 2006">
  <META NAME="author-email" CONTENT="skoruppa@math.uni-siegen.de">
  <META NAME="keywords"     CONTENT="PARI, GP, DOC">
</HEAD>
<BODY bgcolor="#FFFFFF">



<h3 align=center>Standard monadic or dyadic operators</h3>

<a name="+/-"></a>
<h4><b>+/-</b></h4>
<p></p>
<p> The expressions <font color=#a3682a><tt>
+</tt></font>x and <font color=#a3682a><tt>
-</tt></font>x refer
to monadic operators (the first does nothing, the second negates x).</p>
<p>The library syntax is <b>gneg</b>(x) for <font color=#a3682a><tt>
-</tt></font>x.</p>

<br>
<hr></hr><br>

<a name="+"></a>
<h4><b>+</b></h4>
<p></p>
<p>, <font color=#a3682a><tt>
-</tt></font>: The expression x <font color=#a3682a><tt>
+</tt></font> y is the sum and
x <font color=#a3682a><tt>
-</tt></font> y is the difference of x and y. Among the prominent
impossibilities are addition/subtraction between a scalar type and a vector
or a matrix, between vector/matrices of incompatible sizes and between an
intmod and a real number.</p>
<p>The library syntax is <b>gadd</b>(x,y) x <font color=#a3682a><tt>
+</tt></font> y, <font color=#a3682a><tt>
 <b>gsub</b>(x,y)</tt></font> for x <font color=#a3682a><tt>
-</tt></font> y.</p>

<br>
<hr></hr><br>

<a name="*"></a>
<h4><b>*</b></h4>
<p></p>
<p> The expression x <font color=#a3682a><tt>
*</tt></font> y is the product of x
and y. Among the prominent impossibilities are multiplication between
vector/matrices of incompatible sizes, between an intmod and a real
number. Note that because of vector and matrix operations, <font color=#a3682a><tt>
*</tt></font> is not
necessarily commutative. Note also that since multiplication between two
column or two row vectors is not allowed, to obtain the scalar product
of two vectors of the same length, you must multiply a line vector by a
column vector, if necessary by transposing one of the vectors (using
the operator <font color=#a3682a><tt>
~</tt></font> or the function <font color=#a3682a><tt>
mattranspose</tt></font>, see
Section [<b>Label: se:linear_algebra</b>]).</p>
<p>If x and y are binary quadratic forms, compose them. See also
<font color=#a3682a><tt>
qfbnucomp</tt></font> and <font color=#a3682a><tt>
qfbnupow</tt></font>.</p>
<p>The library syntax is <b>gmul</b>(x,y) for x <font color=#a3682a><tt>
*</tt></font> y. Also available is
<font color=#a3682a><tt>
 <b>gsqr</b>(x)</tt></font> for x <font color=#a3682a><tt>
*</tt></font> x (faster of course!).</p>

<br>
<hr></hr><br>

<a name="/"></a>
<h4><b>/</b></h4>
<p></p>
<p> The expression x <font color=#a3682a><tt>
/</tt></font> y is the quotient of x
and y. In addition to the impossibilities for multiplication, note that if
the divisor is a matrix, it must be an invertible square matrix, and in that
case the result is x*y^{-1}. Furthermore note that the result is as exact
as possible: in particular, division of two integers always gives a rational
number (which may be an integer if the quotient is exact) and <u>not</u> the
Euclidean quotient (see x <font color=#a3682a><tt>
\</tt></font> y for that), and similarly the
quotient of two polynomials is a rational function in general. To obtain the
approximate real value of the quotient of two integers, add <font color=#a3682a><tt>
0.</tt></font> to the
result; to obtain the approximate p-adic value of the quotient of two
integers, add <font color=#a3682a><tt>
O(p^k)</tt></font> to the result; finally, to obtain the
Taylor series expansion of the quotient of two polynomials, add
<font color=#a3682a><tt>
O(X^k)</tt></font> to the result or use the <font color=#a3682a><tt>
taylor</tt></font> function
(see Section [<b>Label: se:taylor</b>]). </p>
<p>The library syntax is <b>gdiv</b>(x,y) for x <font color=#a3682a><tt>
/</tt></font> y.</p>

<br>
<hr></hr><br>

<a name="\"></a>
<h4><b>\</b></h4>
<p></p>
<p> The expression <font color=#a3682a><tt>
x \y</tt></font> is the \idx{Euclidean
quotient} of x and y. If y is a real scalar, this is defined as
<font color=#a3682a><tt>
floor(x/y)</tt></font> if y &#62; 0, and <font color=#a3682a><tt>
ceil(x/y)</tt></font> if y &#60; 0 and
the division is not exact. Hence the remainder <font color=#a3682a><tt>
x - (x\y)*y</tt></font>
is in [0, |y|[.</p>
<p>Note that when y is an integer and x a polynomial, y is first promoted
to a polynomial of degree 0. When x is a vector or matrix, the operator
is applied componentwise.</p>
<p>The library syntax is <b>gdivent</b>(x,y) for x <font color=#a3682a><tt>
\</tt></font> y.</p>

<br>
<hr></hr><br>

<a name="\/"></a>
<h4><b>\/</b></h4>
<p></p>
<p> The expression x <font color=#a3682a><tt>
\/</tt></font> y evaluates to the rounded
Euclidean quotient of x and y. This is the same as <font color=#a3682a><tt>
x \y</tt></font>
except for scalar division: the quotient is such that the corresponding
remainder is smallest in absolute value and in case of a tie the quotient
closest to + oo  is chosen (hence the remainder would belong to
]-|y|/2, |y|/2]).</p>
<p>When x is a vector or matrix, the operator is applied componentwise.</p>
<p>The library syntax is <b>gdivround</b>(x,y) for x <font color=#a3682a><tt>
\/</tt></font> y.</p>

<br>
<hr></hr><br>

<a name="divrem"></a>
<h4><b>divrem</b>(x,y,{v})</h4>
<p></p>
<p> creates a column vector with two components,
the first being the Euclidean quotient (<font color=#a3682a><tt>
x \y</tt></font>), the second the
Euclidean remainder (<font color=#a3682a><tt>
x - (x\y)*y</tt></font>), of the division of x by
y. This avoids the need to do two divisions if one needs both the quotient
and the remainder. If v is present, and x, y are multivariate
polynomials, divide with respect to the variable v.</p>
<p>Beware that <font color=#a3682a><tt>
divrem(x,y)[2]</tt></font> is in general not the same as
<font color=#a3682a><tt>
x % y</tt></font>; there is no operator to obtain it in GP:</p>
<p><pre><font color=#a3682a><tt>? divrem(1/2, 3)[2]
&nbsp;%1 = 1/2
&nbsp;? (1/2) % 3
&nbsp;%2 = 2
&nbsp;? divrem(Mod(2,9), 3)[2]
&nbsp;  ***   forbidden division t_INTMOD \ t_INT.
&nbsp;? Mod(2,9) % 6
&nbsp;%3 = Mod(2,3)
</tt></font></pre></p>
<p>
The library syntax is <b>divrem</b>(x,y,v),where v is a <font color=#a3682a><tt>
long</tt></font>. Also available as
<font color=#a3682a><tt>
 <b>gdiventres</b>(x,y)</tt></font> when v is not needed.</p>

<br>
<hr></hr><br>

<a name="^"></a>
<h4><b>^</b></h4>
<p></p>
<p> The expression x{<font color=#a3682a><tt>
^</tt></font>}n is powering.
If the exponent is an integer, then exact operations are performed using
binary (left-shift) powering techniques. In particular, in this case x
cannot be a vector or matrix unless it is a square matrix (invertible
if the exponent is negative). If x is a p-adic number, its
precision will increase if v_p(n) &#62; 0. Powering a binary quadratic form
(types <font color=#a3682a><tt>
t_QFI</tt></font> and <font color=#a3682a><tt>
t_QFR</tt></font>) returns a reduced representative of the
class, provided the input is reduced. In particular, x{<font color=#a3682a><tt>
^</tt></font>}1 is
identical to x.</p>
<p>PARI is able to rewrite the multiplication x * x of two <u>identical</u>
objects as x^2, or <font color=#a3682a><tt>
sqr</tt></font>(x). Here, identical means the operands are
two different labels referencing the same chunk of memory; no equality test
is performed. This is no longer true when more than two arguments are
involved.</p>
<p>If the exponent is not of type integer, this is treated as a transcendental
function (see Section [<b>Label: se:trans</b>]), and in particular has the effect of
componentwise powering on vector or matrices.</p>
<p>As an exception, if the exponent is a rational number p/q and x an
integer modulo a prime or a p-adic number, return a solution y of
y^q = x^p if it exists. Currently, q must not have large prime factors.
Beware that</p>
<p><pre><font color=#a3682a><tt>    ? Mod(7,19)^(1/2)
&nbsp;    %1 = Mod(11, 19) /* is any square root */
&nbsp;    ? sqrt(Mod(7,19))
&nbsp;    %2 = Mod(8, 19)  /* is the smallest square root */
&nbsp;    ? Mod(7,19)^(3/5)
&nbsp;    %3 = Mod(1, 19)
&nbsp;    ? %3^(5/3)
&nbsp;    %4 = Mod(1, 19)  /* Mod(7,19) is just another cubic root */
</tt></font></pre></p>
<p>
If the exponent is a negative integer, an inverse must be computed.
For non-invertible <font color=#a3682a><tt>
t_INTMOD</tt></font>, this will fail and implicitly exhibit a
non trivial factor of the modulus:</p>
<p><pre><font color=#a3682a><tt>    ? Mod(4,6)^(-1)
&nbsp;      ***   impossible inverse modulo: Mod(2, 6).
</tt></font></pre></p>
<p>(Here, a factor 2 is obtained directly. In general, take the gcd of the
representative and the modulus.) This is most useful when performing
complicated operations modulo an integer N whose factorization is
unknown. Either the computation succeeds and all is well, or a factor d
is discovered and the computation may be restarted modulo d or N/d.</p>
<p>For non-invertible <font color=#a3682a><tt>
t_POLMOD</tt></font>, this will fail without exhibiting a
factor.</p>
<p><pre><font color=#a3682a><tt>    ? Mod(x^2, x^3-x)^(-1)
&nbsp;      ***   non-invertible polynomial in RgXQ_inv.
&nbsp;
&nbsp;    ? a = Mod(3,4)*y^3 + Mod(1,4); b = y^6+y^5+y^4+y^3+y^2+y+1;
&nbsp;    ? Mod(a, b)^(-1);
&nbsp;      ***   non-invertible polynomial in RgXQ_inv.
</tt></font></pre></p>
<p>In fact the latter polynomial is invertible, but the algorithm used
(subresultant) assumes the base ring is a domain. If it is not the case,
as here for <b>Z</b>/4<b>Z</b>, a result will be correct but chances are an error
will occur first. In this specific case, one should work with 2-adics.
In general, one can try the following approach</p>
<p><pre><font color=#a3682a><tt>    ? inversemod(a, b) =
&nbsp;    { local(m);
&nbsp;      m = polsylvestermatrix(polrecip(a), polrecip(b));
&nbsp;      m = matinverseimage(m, matid(#m)[,1]);
&nbsp;      Polrev( vecextract(m, Str("..", poldegree(b))), variable(b) )
&nbsp;    }
&nbsp;    ? inversemod(a,b)
&nbsp;    %2 = Mod(2,4)*y^5 + Mod(3,4)*y^3 + Mod(1,4)*y^2 + Mod(3,4)*y + Mod(2,4)
&nbsp;
</tt></font></pre></p>
<p>This is not guaranteed to work either since it must invert pivots. See
Section [<b>Label: se:linear_algebra</b>].</p>
<p>The library syntax is <b>gpow</b>(x,n,<u>prec</u>) for x{<font color=#a3682a><tt>
^</tt></font>}n.</p>

<br>
<hr></hr><br>

<a name="bittest"></a>
<h4><b>bittest</b>(x,n)</h4>
<p></p>
<p> outputs the n^{{th}} bit of x starting
from the right (i.e.the coefficient of 2^n in the binary expansion of x).
The result is 0 or 1. To extract several bits at once as a vector, pass a
vector for n.</p>
<p>See Section [<b>Label: se:bitand</b>] for the behaviour at negative arguments.</p>
<p>The library syntax is <b>bittest</b>(x,n), where n and the result are <font color=#a3682a><tt>
long</tt></font>s.</p>

<br>
<hr></hr><br>

<a name="shift"></a>
<h4><b>shift</b>(x,n)</h4>
<p></p>
<p> or x <font color=#a3682a><tt>
 &#60;&#60; </tt></font> n ( = x <font color=#a3682a><tt>
 &#62;&#62; </tt></font> (-n)): shifts
x componentwise left by n bits if n <font color=#a3682a><tt>
&#62;=</tt></font> 0 and right by |n| bits if n &#60; 0.
A left shift by n corresponds to multiplication by 2^n. A right shift of an
integer x by |n| corresponds to a Euclidean division of x by 2^{|n|}
with a remainder of the same sign as x, hence is not the same (in general) as
x <font color=#a3682a><tt>
\</tt></font> 2^n.</p>
<p>The library syntax is <b>gshift</b>(x,n) where n is a <font color=#a3682a><tt>
long</tt></font>.</p>

<br>
<hr></hr><br>

<a name="shiftmul"></a>
<h4><b>shiftmul</b>(x,n)</h4>
<p></p>
<p> multiplies x by 2^n. The difference with
<font color=#a3682a><tt>
shift</tt></font> is that when n &#60; 0, ordinary division takes place, hence for
example if x is an integer the result may be a fraction, while for shifts
Euclidean division takes place when n &#60; 0 hence if x is an integer the result
is still an integer.</p>
<p>The library syntax is <b>gmul2n</b>(x,n) where n is a <font color=#a3682a><tt>
long</tt></font>.</p>

<br>
<hr></hr><br>

<a name="<,<,>=,>,==,!=,||,&&,!,|,&,<>"></a>
<h4><b>Comparison and boolean operators</b></h4>
<p></p>
<p>. The six
standard comparison operators <font color=#a3682a><tt>
 &#60;= </tt></font>, <font color=#a3682a><tt>
 &#60; </tt></font>, <font color=#a3682a><tt>
 &#62;= </tt></font>, <font color=#a3682a><tt>
 &#62; </tt></font>,
<font color=#a3682a><tt>
 == </tt></font>, <font color=#a3682a><tt>
 != </tt></font> are available in GP, and in library mode under the names
<font color=#a3682a><tt>
gle</tt></font>, <font color=#a3682a><tt>
glt</tt></font>, <font color=#a3682a><tt>
gge</tt></font>, <font color=#a3682a><tt>
ggt</tt></font>, <font color=#a3682a><tt>
geq</tt></font>, <font color=#a3682a><tt>
gne</tt></font> respectively.
The library syntax is <u>co</u>(x,y), where <u>co</u> is the comparison
operator. The result is 1 (as a <font color=#a3682a><tt>
GEN</tt></font>) if the comparison is true, 0 (as a
<font color=#a3682a><tt>
GEN</tt></font>) if it is false. For the purpose of comparison, <font color=#a3682a><tt>
t_STR</tt></font> objects are
strictly larger than any other non-string type; two <font color=#a3682a><tt>
t_STR</tt></font> objects are
compared using the standard lexicographic order.</p>
<p>The standard boolean functions  <font color=#a3682a><tt>
||</tt></font> (inclusive or), <font color=#a3682a><tt>
&amp;&amp;</tt></font>
(and) and <font color=#a3682a><tt>
!</tt></font> (not) are also available, and the
library syntax is <font color=#a3682a><tt>
 <b>gor</b>(x,y)</tt></font>, <font color=#a3682a><tt>
 <b>gand</b>(x,y)</tt></font> and <font color=#a3682a><tt>
 <b>gnot</b>(x)</tt></font>
respectively.</p>
<p>In library mode, it is in fact usually preferable to use the two basic
functions which are <font color=#a3682a><tt>
 <b>gcmp</b>(x,y)</tt></font> which gives the sign (1, 0, or -1) of
x-y, where x and y must be in <b>R</b>, and <font color=#a3682a><tt>
 <b>gequal</b>(x,y)</tt></font> which can be
applied to any two PARI objects x and y and gives 1 (i.e.true) if they are
equal (but not necessarily identical), 0 (i.e.false) otherwise. Comparisons
to special constants are implemented and should be used instead of
<font color=#a3682a><tt>
gequal</tt></font>: <font color=#a3682a><tt>
 <b>gcmp0</b>(x)</tt></font> (x == 0 ?), <font color=#a3682a><tt>
 <b>gcmp1</b>(x)</tt></font> (x == 1 ?), and
<font color=#a3682a><tt>
 <b>gcmp_1</b>(x)</tt></font> (x == -1 ?).</p>
<p>Note that <font color=#a3682a><tt>
gcmp0</tt></font>(x) tests whether x is equal to zero, even if x is
not an exact object. To test whether x is an exact object which is equal to
zero, one must use <font color=#a3682a><tt>
 <b>isexactzero</b>(x)</tt></font>.</p>
<p>Also note that the <font color=#a3682a><tt>
gcmp</tt></font> and <font color=#a3682a><tt>
gequal</tt></font> functions return a C-integer,
and <u>not</u> a <font color=#a3682a><tt>
GEN</tt></font> like <font color=#a3682a><tt>
gle</tt></font> etc.</p>
<p>
GP accepts the following synonyms for some of the above functions: since we
thought it might easily lead to confusion, we don't use the customary C
operators for bitwise <font color=#a3682a><tt>
and</tt></font> or bitwise <font color=#a3682a><tt>
or</tt></font> (use <font color=#a3682a><tt>
bitand</tt></font> or
<font color=#a3682a><tt>
bitor</tt></font>), hence <font color=#a3682a><tt>
|</tt></font> and <font color=#a3682a><tt>
&amp;</tt></font> are accepted as\sidx{bitwise
and} synonyms of <font color=#a3682a><tt>
||</tt></font> and <font color=#a3682a><tt>
&amp;&amp;</tt></font> respectively.
Also, <font color=#a3682a><tt>
 &#60;  &#62; </tt></font> is accepted as a synonym for <font color=#a3682a><tt>
 != </tt></font>. On the other hand,
<font color=#a3682a><tt>
 = </tt></font> is definitely <u>not</u> a synonym for <font color=#a3682a><tt>
 == </tt></font> since it is the
assignment statement.</p>

<br>
<hr></hr><br>

<a name="lex"></a>
<h4><b>lex</b>(x,y)</h4>
<p></p>
<p> gives the result of a lexicographic comparison
between x and y (as -1, 0 or 1). This is to be interpreted in quite
a wide sense: It is admissible to compare objects of different types
(scalars, vectors, matrices), provided the scalars can be compared, as well
as vectors/matrices of different lengths. The comparison is recursive.</p>
<p>In case all components are equal up to the smallest length of the operands,
the more complex is considered to be larger. More precisely, the longest is
the largest; when lengths are equal, we have matrix  &#62;  vector  &#62;  scalar.
For example:</p>
<p><pre><font color=#a3682a><tt>? lex([1,3], [1,2,5])
&nbsp;%1 = 1
&nbsp;? lex([1,3], [1,3,-1])
&nbsp;%2 = -1
&nbsp;? lex([1], [[1]])
&nbsp;%3 = -1
&nbsp;? lex([1], [1]~)
&nbsp;%4 = 0
</tt></font></pre></p>
<p>
The library syntax is <b>lexcmp</b>(x,y).</p>

<br>
<hr></hr><br>

<a name="sign"></a>
<h4><b>sign</b>(x)</h4>
<p></p>
<p> sign (0, 1 or -1) of x, which must be of
type integer, real or fraction.</p>
<p>The library syntax is <b>gsigne</b>(x). The result is a <font color=#a3682a><tt>
long</tt></font>.</p>

<br>
<hr></hr><br>

<a name="max"></a>
<h4><b>max</b>(x,y)</h4>
<p></p>
<p> and <font color=#a3682a><tt>
 <b>min</b>(x,y)</tt></font>: creates the
maximum and minimum of x and y when they can be compared.</p>
<p>The library syntax is <b>gmax</b>(x,y) and <font color=#a3682a><tt>
 <b>gmin</b>(x,y)</tt></font>.</p>

<br>
<hr></hr><br>

<a name="vecmax"></a>
<h4><b>vecmax</b>(x)</h4>
<p></p>
<p> if x is a vector or a matrix, returns the maximum
of the elements of x, otherwise returns a copy of x. Error if x is
empty.</p>
<p>The library syntax is <b>vecmax</b>(x).</p>

<br>
<hr></hr><br>

<a name="vecmin"></a>
<h4><b>vecmin</b>(x)</h4>
<p></p>
<p> if x is a vector or a matrix, returns the minimum
of the elements of x, otherwise returns a copy of x. Error if x is
empty.</p>
<p>The library syntax is <b>vecmin</b>(x).</p>

<br>
<hr></hr><br>



</BODY>
</HTML>