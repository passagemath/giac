<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Algorithmes de calcul formel
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea png.hva algo.tex -->
<!--HTMLHEAD-->
Retour &#XE0; la page principale de <A HREF="http://www-fourier.ujf-grenoble.fr/parisse/giac_fr.html">Giac/Xcas</A>.<!--ENDHTML-->
<!--CUT DEF section 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">Algorithmes de calcul formel</H1><H3 CLASS="titlerest">B. Parisse<BR>
Institut Fourier<BR>
UMR 5582 du CNRS<BR>
Université de Grenoble I</H3></TD></TR>
</TABLE><BLOCKQUOTE CLASS="abstract"><B>Résumé: </B>
Ce document décrit une partie des algorithmes de calcul formel 
utilisés pour le logiciel de calcul formel Giac/Xcas, cf.<BR>
<CODE>http://www-fourier.ujf-grenoble.fr/~parisse/giac_fr.html</CODE>
</BLOCKQUOTE><!--TOC section Table des matières-->
<H2 CLASS="section"><!--SEC ANCHOR -->Table des matières</H2><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">1  Calculer sur ordinateur</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc2">1.1  Problèmes spécifiques au calcul formel</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc3">1.1.1  Calcul exact et approché, types, évaluation.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">1.1.2  Forme normale et reconnaissance du 0.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">1.1.3  Valeur générique des variables et hypothèses</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">1.2  Structures de données</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc7">1.2.1  Calculatrices formelles HP</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">1.2.2  Calculatrices formelles TI</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc9">1.2.3  Maple, MuPAD, Mathematica, ...</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">1.2.4  Giac/xcas</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc11">1.3  Algorithmes et complexité.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">2  Quelques algorithmes d&#X2019;arithmétique de base.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc13">2.1  Pour en savoir plus.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">3  Exercices sur types, calcul exact et approché, 
algorithmes de bases</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc15">4  Le PGCD</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc16">4.1  Le sous-résultant.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc17">4.2  Le pgcd en une variable</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc18">4.2.1  Le pgcd heuristique.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">4.2.2  Le pgcd modulaire</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc20">4.3  Le pgcd à plusieurs variables.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc21">4.3.1  Le pgcd heuristique.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">4.3.2  Le pgcd modulaire multivariables.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc23">4.3.3  EZGCD.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">4.4  Quel algorithme choisir?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc25">4.5  Pour en savoir plus.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">5  Le résultant</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc27">6  Les suites de Sturm</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">7  Exercices (PGCD, résultant, ...)</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc29">7.1  Instructions</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc30">7.1.1  Entiers</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc31">7.1.2  Polynômes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc32">7.1.3  Calculs modulo <I>n</I></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">7.2  Exercices PGCD</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc34">7.3  Exercices (résultant)</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc35">7.4  Exercice (Bézout modulaire)</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">7.5  Exercice (Géométrie et résultants).</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc37">7.6  Décalage entier entre racines.</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc38">8  Factorisation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc39">8.1  Les facteurs multiples</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">8.2  Factorisation en une variable</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc41">8.2.1  Factorisation dans &#X2124;/<I>p</I>&#X2124;[<I>X</I>]</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc42">8.2.2  Distinct degree factorization</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc43">8.2.3  La méthode de Cantor-Zassenhaus</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc44">8.2.4  La méthode de Berlekamp</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">8.2.5  Remontée (Hensel)</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc46">8.2.6  Combinaison de facteurs</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc47">8.3  Factorisation à plusieurs variables</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc48">8.4  Preuve de l&#X2019;identité de Bézout généralisée</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc49">8.5  Algorithme de Bézout généralisé</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">8.6  Pour en savoir plus</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc51">8.7  Exercices (factorisation des polynômes)</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc52">9  Intégration</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc53">9.1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc54">9.2  Fonctions élémentaires</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc55">9.2.1  Extensions transcendantes, tour de variables</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc56">9.2.2  Théorème de structure de Risch</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">9.2.3  Théorème de Liouville</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc58">9.3  L&#X2019;algorithme de Risch</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc59">9.3.1  Intégration d&#X2019;une fraction propre</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc60">9.3.2  Réduction sans facteurs multiples</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc61">9.3.3  La partie logarithmique</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">9.3.4  La partie polynomiale (généralisée)</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">9.3.5  Extension logarithmique</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc64">9.3.6  Extension exponentielle</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc65">9.4  Quelques références</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc66">10  Algèbre linéaire</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc67">10.1  Résolution de systèmes, calcul de déterminant.</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc68">10.1.1  La méthode du pivot de Gauß.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc69">10.1.2  Le déterminant.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc70">10.1.3  Systèmes linéaires</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc71">10.1.4  Base du noyau</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc72">10.2  Réduction des endomorphismes</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc73">10.2.1  Le polynôme minimal</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc74">10.2.2  Le polynôme caractéristique</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc75">10.2.3  La méthode de Hessenberg</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc76">10.2.4  La méthode de Leverrier-Faddeev-Souriau</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc77">10.2.5  Les vecteurs propres simples.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc78">10.2.6  La forme normale de Jordan</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc79">10.2.7  Exemple 1</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc80">10.2.8  Exemple 2</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc81">10.2.9  Le polynôme minimal par Faddeev</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc82">10.2.10  Formes normales rationnelles</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc83">10.2.11  Fonctions analytiques</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc84">10.3  Quelques autres algorithmes utiles</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc85">10.4  Quelques références</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc86">10.5  Bézout et les <I>p</I>-adiques.</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc87">10.6  Exercices (algèbre linéaire)</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc88">10.6.1  Instructions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc89">10.6.2  Exercices</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc90">10.7  L&#X2019;algorithme du simplexe</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc91">11  Interpolation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc92">11.1  Lagrange</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc93">11.2  Différences divisées</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc94">11.3  Les splines</A>
</LI></UL>
</LI></UL><!--TOC section Calculer sur ordinateur-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc1">1</A>  Calculer sur ordinateur</H2><!--SEC END --><!--TOC subsection Problèmes spécifiques au calcul formel-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc2">1.1</A>  Problèmes spécifiques au calcul formel</H3><!--SEC END --><!--TOC subsubsection Calcul exact et approché, types, évaluation.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc3">1.1.1</A>  Calcul exact et approché, types, évaluation.</H4><!--SEC END --><P>
Dans les langages de programmation traditionnel (C, Pascal,...), il existe 
déjà des types permettant une représentation 
exacte des données (type entier) ou une représentation approchée 
(type flottant). Mais ces types de donnée de base 
occupent une taille fixe en mémoire, le type entier est donc
limité à un intervalle d&#X2019;entiers (par exemple [0,2<SUP>32</SUP>&#X2212;1] pour un entier
non signé sur une machine utilisant un processeur 32 bits) alors que le 
type flottant peut représenter des nombres réels, mais est 
limité à une précision en nombre de digits de la mantisse et de l&#X2019;exposant 
(par exemple 12 chiffres significatifs et un 
exposant compris entre -499 et 499). </P><P>En calcul formel, on souhaite pouvoir calculer rigoureusement d&#X2019;une part, 
et avec des paramètres dont la valeur n&#X2019;est 
pas connue d&#X2019;autre part ; il faut donc s&#X2019;affranchir de ces limites : 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
pour les entiers relatifs, on utilise des entiers de 
<EM>précision arbitraire</EM>
dont la taille en mémoire est dynamique (déterminée pendant l&#X2019;exécution et non
à la compilation),
</LI><LI CLASS="li-itemize">pour les nombres complexes, on utilise un couple de nombres réels,
</LI><LI CLASS="li-itemize">pour les rationnels, on utilise un couple d&#X2019;entiers relatifs,
</LI><LI CLASS="li-itemize">pour les irrationnels algébriques (par exemple &#X221A;<SPAN style="text-decoration:overline">2</SPAN>), 
on utilise un polynôme irréductible dont ils sont racines,
</LI><LI CLASS="li-itemize">pour les paramètres (<I>x</I>,<I>y</I>,<I>z</I>,<I>t</I>...), on utilise un type 
structuré contenant un champ de type chaine de caractères pour 
représenter le nom du paramètre et
un champ pour attribuer une valeur à (ou une hypothèse sur) ce paramètre,
</LI><LI CLASS="li-itemize">pour les nombres transcendants (par exemple &#X3C0;), on est obligé
d&#X2019;introduire un paramètre auquel on attribue une valeur numérique, 
qui ne sera utilisée qu&#X2019;au moment où on veut une 
approximation numérique d&#X2019;une expression contenant ce nombre transcendant,
on parle de constante,
</LI><LI CLASS="li-itemize">lorsqu&#X2019;on a besoin d&#X2019;une approximation numérique d&#X2019;un nombre,
on peut utiliser des conversions de ces types en un type flottant. On peut 
aussi pour lutter contre les erreurs 
d&#X2019;arrondi utiliser des nombres flottants étendus dont la précision est 
dynamique ou même des intervalles de flottants étendus,
</LI><LI CLASS="li-itemize">il faut aussi
un nouveau type, appelé expression ou symbolique, permettant d&#X2019;appliquer
une fonction qu&#X2019;on ne peut évaluer directement sur les objets précédents,
par exemple sin(<I>x</I>). Il
doit s&#X2019;agir d&#X2019;une opération de clôture, au sens où appliquer une fonction à
un objet symbolique ne nécessite pas la création d&#X2019;un nouveau type
(en général on renvoie un objet symbolique).
</LI></UL><P>Enfin, il faut pouvoir évaluer un objet (en particulier symbolique) :
par exemple évaluer sin(<I>x</I>) lorsqu&#X2019;on assigne une valeur à <I>x</I>. 
Dans cet exemple, on voit qu&#X2019;il faut d&#X2019;abord remplacer <I>x</I> par
sa valeur avant de lui appliquer la fonction sinus. C&#X2019;est le mécanisme
général de l&#X2019;évaluation, mais il y a quelques exceptions où
on souhaite empêcher l&#X2019;évaluation d&#X2019;un ou plusieurs arguments
d&#X2019;une fonction avant l&#X2019;évaluation de la fonction. Par exemple si on 
veut calculer la valeur numérique d&#X2019;une intégrale par des méthodes
de quadrature, on ne souhaitera pas rechercher une primitive de la 
fonction à intégrer. Dans le jargon, on parle alors de &#X201C;quoter&#X201D; un argument 
(l&#X2019;origine du terme vient probablement de la notation <CODE>'</CODE> du langage 
Lisp). Certaines fonctions doivent toujours quoter leurs arguments
(par exemple la fonction qui permet de purger le contenu d&#X2019;un paramètre),
on parle parfois d&#X2019;autoquotation.</P><!--TOC subsubsection Forme normale et reconnaissance du 0.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc4">1.1.2</A>  Forme normale et reconnaissance du 0.</H4><!--SEC END --><P>
Une fois défini ces types de base représentant les nombres d&#X2019;un système de 
calcul formel, il faut pouvoir comparer ces 
nombres, en particulier décider si deux représentations distinctes 
correspondent au même nombre ou, ce qui revient au 
même, par soustraction décider quand un nombre est nul. 
Par exemple 4/2 et 2 représentent le même nombre. 
Lorsqu&#X2019;on dispose d&#X2019;un algorithme permettant de représenter un nombre 
d&#X2019;une manière unique, on parle de forme normale. 
C&#X2019;est par exemple le cas pour les nombres rationnels, la forme normale 
usuelle est la fraction irréductible de 
dénominateur positif. C&#X2019;est aussi le cas pour les fractions rationnelles 
de polynômes à coefficients entiers représentées par une fraction 
irréductible, avec au dénominateur un coefficient de plus haut degré
positif.
Malheureusement, il n&#X2019;est pas toujours possible de trouver une forme normale
pour diverses raisons théoriques ou pratiques : 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
on ne connaît pas toujours le statut de certaines constantes
(par exemple la constante d&#X2019;Euler),
</LI><LI CLASS="li-itemize">il n&#X2019;existe pas d&#X2019;algorithmes permettant de déterminer
s&#X2019;il existe des relations algébriques entre constantes,
</LI><LI CLASS="li-itemize">il n&#X2019;existe pas forcément une seule forme plus simple, par exemple :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(</TD><TD CLASS="dcell"><FONT SIZE=5>&#X221A;</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD></TR>
</TABLE></TD><TD CLASS="dcell">+1)<I>x</I>+1</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>+</TD><TD CLASS="dcell"><FONT SIZE=5>&#X221A;</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD></TR>
</TABLE></TD><TD CLASS="dcell">+1</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>+</TD><TD CLASS="dcell"><FONT SIZE=5>&#X221A;</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X2212;1</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(</TD><TD CLASS="dcell"><FONT SIZE=5>&#X221A;</FONT></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X2212;1)<I>x</I>+1</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE>
Ce cas se présente fréquemment avec les extensions algébriques.
</LI><LI CLASS="li-itemize">en pratique il peut être trop coûteux d&#X2019;utiliser une forme
normale, par exemple le polynôme <I>x</I><SUP>1000</SUP>&#X2212;1/<I>x</I>&#X2212;1 possède 1000 monômes
</LI></UL><P>
En résumé, au mieux on a une forme normale, au pire on risque de ne pas 
reconnaître un zéro, entre les deux on peut ne
pas avoir de forme normale mais être capable de reconnaître à coup sûr 
une expression nulle (par contre, si le système 
de calcul formel détermine qu&#X2019;une expression est nulle, alors elle l&#X2019;est).</P><P>Il n&#X2019;existe pas d&#X2019;algorithme solution
pour le problème de la reconnaissance du zéro pour une classe 
d&#X2019;expressions "assez générale". Heureusement, 
dans la plupart des cas pratiques on sait résoudre ce problème, en
se ramenant le plus souvent au cas des polynômes et fractions rationnelles.
Par exemple, pour simplifier une expression trigonométrique,
on remplace les fonctions trigonométriques sin(<I>x</I>), cos(<I>x</I>), tan(<I>x</I>)
par leur expression en fonction de <I>t</I>=tan(<I>x</I>/2), on est ainsi ramené
à une fraction rationnelle en <I>t</I> que l&#X2019;on écrit sous forme normale.</P><P>Les polynômes ont un rôle central dans tout système de calcul formel
puisque sauf dans les cas les plus simples (fractions d&#X2019;entiers par exemple), 
la simplification d&#X2019;expressions
fait appel à un moment ou à un autre à des calculs
de PGCD de polynômes. Le PGCD de polynômes est un algorithme 
très sollicité auquel nous consacrerons une section. En effet,
l&#X2019;application brutale de l&#X2019;algorithme d&#X2019;Euclide pose des problèmes
d&#X2019;efficacité ce qui a obligé à inventer des méthodes plus efficaces.
Anticipons rapidement sur un exemple qui montre l&#X2019;un des problèmes
majeurs des algorithmes de calcul formel, l&#X2019;explosion en taille
(ici des coefficients des restes successifs).
Voici donc les restes successifs lorsqu&#X2019;on applique l&#X2019;algorithme
d&#X2019;Euclide pour calculer le PGCD de <I>P</I>(<I>x</I>)=(<I>x</I>+1)<SUP>7</SUP>&#X2212;(<I>x</I>&#X2212;1)<SUP>6</SUP> avec
sa dérivée (les deux polynômes sont premiers entre eux) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>7 (<I>x</I>+1)<SUP>6</SUP>&#X2212;6 (<I>x</I>&#X2212;1)<SUP>5</SUP></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">162</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>5</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;390</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>4</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1060</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>3</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;780</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>2</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">474</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;78</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">157780</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">729</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>4</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;507640</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2187</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>3</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">290864</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">729</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>2</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;101528</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">729</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">28028</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">729</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">49</TD></TR>
</TABLE></TD><TD CLASS="dcell">  (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1400328</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2645</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>3</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;732888</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2645</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>2</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1133352</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">3703</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;732888</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">18515</TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2187</TD></TR>
</TABLE></TD><TD CLASS="dcell">  (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2161816376832</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4669921</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUP>2</SUP>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;555436846944</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4669921</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">301917024864</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4669921</TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">907235</TD></TR>
</TABLE></TD><TD CLASS="dcell">  (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">469345063045455</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">129411872</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I>+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;47641670106615</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">129411872</TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">5497465490623352995840</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">209648836272383412129</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Le lecteur voulant tester d&#X2019;autres exemples pourra utiliser le programme 
<CODE>Xcas</CODE> (cf. l&#X2019;appendice) suivant :
</P><PRE CLASS="verbatim">pgcd(a):={
  local b,r,res;
  b:=diff(a,x);
  res:=NULL;
  for (;b!=0;){
    res:=res,b;
    r:=rem(a,b);
    a:=b;
    b:=r;
  }
  return(res);
}
</PRE><!--TOC subsubsection Valeur générique des variables et hypothèses-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc5">1.1.3</A>  Valeur générique des variables et hypothèses</H4><!--SEC END --><P>
Lorsqu&#X2019;on utilise un symbole sans lui affecter de valeurs en mathématiques 
on s&#X2019;attend à une discussion en fonction du 
paramètre représenté par ce symbole. Ce qui nécessiterait de créer un 
arborescence de calculs (on retrouve ici les problèmes 
d&#X2019;explosion évoqués dans la section précédente). 
La plupart des systèmes de calcul formel contournent la difficulté en 
supposant que le paramètre possède une valeur 
générique (par exemple la solution de (<I>t</I><SUP>2</SUP>&#X2212;1)<I>x</I>=<I>t</I>&#X2212;1 sera <I>x</I>=1/(<I>t</I>+1)) ou 
choisissent une branche pour les fonctions 
possédant un point de branchement (par exemple pour résoudre <I>x</I><SUP>2</SUP>=<I>t</I> 
en fonction de <I>t</I>). Certains systèmes demandent de 
manière interactive à l&#X2019;utilisateur si la variable est par exemple positive 
ou différente de 1 mais cela s&#X2019;oppose à un 
traitement automatique. 
On peut aussi anticiper ce type de décision en faisant des hypothèses
sur une paramètre, la plupart des systèmes de calcul formel actuel
proposent cette possibilité.</P><!--TOC subsection Structures de données-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc6">1.2</A>  Structures de données</H3><!--SEC END --><P>
On a vu plus haut qu&#X2019;on souhaitait manipuler des entiers de taille non 
fixe, des réels de précision fixe ou non, des
fractions, des nombres complexes, des extensions algébriques, des 
paramètres, des expressions symboliques. La plupart des systèmes
proposent un type générique qui recouvre ces divers types de scalaire.
On peut par exemple utiliser un type structuré comportant un champ
type et la donnée ou un pointeur sur la donnée (avec dans ce cas un 
pointeur sur un compteur de références de la donnée
pour pouvoir la détruire dès qu&#X2019;elle n&#X2019;est plus référencée<SUP><A NAME="text1" HREF="#note1">1</A></SUP>). 
En programmation orientée objet, on utiliserait plutôt un
type abstrait dont dérivent ces différents scalaires et le polymorphisme.</P><P>Il faut aussi un type pour les vecteurs, les matrices et les
listes. Il faut prendre garde à la méthode utilisée
par le système lorsqu&#X2019;on modifie un élément
d&#X2019;un vecteur, matrice ou liste : soit on effectue une copie de tout
l&#X2019;objet en modifiant l&#X2019;élément, soit on modifie l&#X2019;élément
de l&#X2019;objet original. La première méthode (par valeur) est
plus aisée à comprendre pour un débutant mais
la seconde méthode (par référence) est bien plus efficace.</P><P>On peut se poser la question de savoir s&#X2019;il faut inclure 
ces types dans le type générique ; en général la 
réponse est affirmative, une des raisons étant que les 
interpréteurs qui permettront de lire des données dans un 
fichier texte sont en général basé sur le couple de logiciels
<CODE>lex(flex)/yacc(bison)</CODE> qui ne peut compiler qu&#X2019;à destination d&#X2019;un 
seul type. Ceci permet également d&#X2019;unifier en un seul type symbolique 
les fonctions ayant un ou plusieurs arguments en 
voyant plusieurs arguments comme un vecteur d&#X2019;arguments. 
Les fonctions sont le plus souvent elle-même incluses dans le 
type générique permettant ainsi à l&#X2019;utilisateur de saisir des 
commandes ou programmes fonctionnels (on peut
utiliser une fonction comme argument d&#X2019;une commande).</P><P>Pour des raisons d&#X2019;efficacité, les systèmes de calcul formel
utilisent souvent des représentations particulières pour les polynômes
dont on a dit qu&#X2019;ils jouaient un rôle central.
Pour les polynômes à une variable,
on peut utiliser la liste des coefficients du polynôme, on parle
alors de représentation dense. On peut aussi décider de ne stocker
que les coefficients non nuls, on parle alors de représentation creuse
(on stocke alors un couple formé par le coefficient et le degré
du monôme correspondant). Pour les polynômes à plusieurs variables,
on peut les considérer comme des polynômes à une variable à
coefficients polynomiaux, on parle alors de représentation récursive.
On peut aussi décider de ne pas briser la symétrie entre les
variables (pas de variable principale), on parle alors de représentation
distribuée, le plus souvent les représentation distribuées
sont creuses car les représentations
denses nécessitent très vite beaucoup de coefficients. Les méthodes
de représentation creuses sont parfois aussi utilisées pour les
matrices ayant beaucoup de coefficients nuls.</P><P>Voyons maintenant plus précisément sur quelques exemples de logiciels
de calcul formel répandus quelles structures de données sont
utilisées. Plusieurs éléments entrent en compte dans les choix faits :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
le(s) profil(s) d&#X2019;utilisation (enseignement, ingéniérie,
calcul intensif, recherche)
</LI><LI CLASS="li-itemize">les ressources disponibles (mémoire, puissance du processeur...)
</LI><LI CLASS="li-itemize">la facilité d&#X2019;implémentation (choix du langage, outils
disponibles en particulier débuggueurs, ...)
</LI><LI CLASS="li-itemize">l&#X2019;histoire du système (un système conçu avec les outils
disponibles aujourd&#X2019;hui est forcément différent d&#X2019;un système 
conçu il y a 20 ans)
</LI></UL><P>
Nous allons d&#X2019;abord parler des calculatrices formelles HP
et TI (le lecteur pourra facilement les tester grâce aux émulateurs gratuits
pour PC). Ce sont des systèmes plutôt destinés à l&#X2019;enseignement, soumis 
à de fortes contraintes en termes de taille mémoire, et destinés
à traiter des petits problèmes.
Puis nous présenterons des systèmes pour ordinateur où les ressources
(par exemple mémoire) sont moins limitées ce qui permet 
d&#X2019;utiliser des langages de programmation de plus haut niveau.</P><!--TOC subsubsection Calculatrices formelles HP-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc7">1.2.1</A>  Calculatrices formelles HP</H4><!--SEC END --><P>
Les langages utilisés pour programmer ces calculateurs sont l&#X2019;assembleur
et le RPL (Reverse Polish Lisp) adapté à l&#X2019;écriture de code
en mémoire morte très compact.</P><P>Le type générique est implémenté avec un champ type appelé prologue (qui est
en fait un pointeur sur la fonction chargée d&#X2019;évaluer ce type d&#X2019;objet)
suivi de la donnée elle-même (et non d&#X2019;un pointeur sur la donnée, on
économise ainsi la place mémoire du compteur de référence).</P><P>Le type entier en précision arbitraire est codé par le nombre de digits 
(sur 5 quartets<SUP><A NAME="text2" HREF="#note2">2</A></SUP>) suivi du signe sur un 
quartet et de la représentation BCD (en base 10) de la valeur absolue de 
l&#X2019;entier. Le choix de la représentation BCD a été fait pour optimiser 
les temps de conversion en chaîne de caractères pour l&#X2019;affichage. La mémoire
vive disponible est de 256K, c&#X2019;est elle qui limite la taille des entiers 
et non le champ longueur de l&#X2019;entier. Il n&#X2019;y a pas de type spécifique 
pour les rationnels (on utilise un objet
symbolique normal). </P><P>Les fonctions internes des HP49/50/40 utilisent 
le type programme pour représenter les entiers de Gauß (complexes
dont la partie réelle et imaginaire est entière).
Les nombres algébriques ne sont pas implémentés, sauf les racines carrées
(représentée de manière interne par le type programme). 
Il y a un type spécifique prévu pour les flottants en précision arbitraire, 
mais l&#X2019;implémentation des opérations sur ces types
n&#X2019;a pas été intégrée en ROM à ce jour. </P><P>Les types listes, programmes et objet symbolique sont composés du prologue
(champ type) suivi par la succession d&#X2019;objets situés en
mémoire vive ou de pointeurs sur des objets situés en mémoire en lecture 
seule (ROM) et se terminent par un pointeur sur une
adresse fixe (appelée <CODE>SEMI</CODE>). Ces types sont eux-mêmes des 
objets et peuvent donc être utilisés de manière
récursive. La longueur des types listes, programmes, symboliques 
n&#X2019;est stockée nulle part, c&#X2019;est le délimiteur final
qui permet de la connaître, ce qui est parfois source d&#X2019;inefficacité.
On utilise de manière interne les listes pour représenter les 
polynômes denses (avec 
représentation récursive pour les polynômes à plusieurs variables). </P><P>Les calculatrices HP4xG utilisent une pile<SUP><A NAME="text3" HREF="#note3">3</A></SUP>, c&#X2019;est-à-dire une liste
de taille non fixée d&#X2019;objets. On place les objets sur la pile,
l&#X2019;exécution d&#X2019;une fonction prend ces arguments sur
la pile et renvoie un ou plusieurs résultats sur la pile (ce qui est
une souplesse du RPN comparé aux langages où on ne peut renvoyer
qu&#X2019;une valeur de retour). Il faut donc
donner les arguments avant d&#X2019;appeler la fonction correspondante. Par
exemple pour calculer <I>a</I>+<I>b</I> on tapera <CODE>a b +</CODE>. C&#X2019;est
la syntaxe dite polonaise inversée (RPN). Un avantage de cette syntaxe
est que le codage d&#X2019;un objet symbolique par cette syntaxe est évidente,
il suffit de stocker la liste précédente <CODE>{a b +}</CODE>.
Les objets symboliques sont donc représenté par une suite d&#X2019;objets écrit
en syntaxe polonaise inversée. L&#X2019;évaluation d&#X2019;un objet symbolique se fait
dans l&#X2019;ordre polonaise inversé : les arguments sont évalués
puis les fonctions leur sont appliqués. Pour des raisons d&#X2019;efficacité, 
on représente souvent les objets composites (listes, symboliques) par 
leurs composants placés sur la pile (appelé meta-objets).</P><P>Une rigidité de la syntaxe polonaise est
que les fonctions ont toujours un nombre fixe d&#X2019;arguments<SUP><A NAME="text4" HREF="#note4">4</A></SUP>, par
exemple l&#X2019;addition a toujours 2 arguments, ainsi
<I>a</I>+<I>b</I>+<I>c</I> est obtenu par (<I>a</I>+<I>b</I>)+<I>c</I> ou par <I>a</I>+(<I>b</I>+<I>c</I>)
c&#X2019;est-à-dire respectivement <CODE>a b + c +</CODE> ou <CODE>a b c + +</CODE> ce qui
brise parfois artificiellement la symétrie de certaines opérations. En
polonaise inversée, le système doit de plus jongler avec l&#X2019;autoquote puisque
les arguments sont évalués avant l&#X2019;opérateur qui éventuellement demanderait
à ne pas évaluer ses arguments. À noter l&#X2019;existence d&#X2019;une commande 
<CODE>QUOTE</CODE> permettant à l&#X2019;utilisateur de quoter une sous-expression.</P><P>Les hypothèses sur des variables réelles sont regroupées dans une liste
stockée dans la variable globale <CODE>REALASSUME</CODE>, on peut supposer
qu&#X2019;une variable est dans un intervalle. Il n&#X2019;y a pas à ce jour
de possibilité de supposer qu&#X2019;une variable est entière (ni à fortiori
qu&#X2019;une variable à une valeur modulo un entier fixé), bien qu&#X2019;il ait été
décidé de réserver la variable globale <CODE>INTEGERASSUME</CODE> à cet effet.
Il n&#X2019;y a pas de possibilité de faire des hypothèses ayant une portée
locale.</P><!--TOC subsubsection Calculatrices formelles TI-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc8">1.2.2</A>  Calculatrices formelles TI</H4><!--SEC END --><P>
Le langage utilisé pour programmer ces calculatrices est le langage C
(on peut aussi écrire du code en assembleur pour ces calculatrices).
On retrouve ici les différents types de données regroupé en un
type générique qui est un tableau d&#X2019;octets (aussi appelé quantum). 
Le champ type
est appelé tag dans la documentation TI. Contrairement à ce qui
précède, ce champ type est placé en mémoire à la fin de l&#X2019;objet,
ce qui est possible car la longueur d&#X2019;un objet est toujours indiquée
au début de l&#X2019;objet. Ceci est fait afin de faciliter l&#X2019;évaluation (cf.
infra).</P><P>Les entiers en précision arbitraire sont codés par un tag parmi deux (pour
différencier le signe), un octet pour la longueur, puis la valeur
absolue de l&#X2019;entier (en base 256). Ils sont donc limités par le
champ longueur à 255 octets, le plus grand entier représentable est
<SUP><A NAME="text5" HREF="#note5">5</A></SUP> (256<SUP>255</SUP>&#X2212;1).
Il existe un tag spécifique pour les rationnels, pour les constantes 
réelles et entières qui apparaissent par exemple en résolvant une équation.
Il existe des tags utilisés de manière interne, par exemple
pour les nombres complexes. 
Il n&#X2019;y a pas de tag prévu pour les flottants en précision arbitraire.
ni pour les nombres algébriques (racines carrées par 
exemple).</P><P>Les listes sont codées par la succession de leurs éléments. En principe
elles ne peuvent pas contenir des listes (sauf pour représenter
une matrice).
Quelques fonctions utilisent les listes pour représenter des polynômes 
denses à une variable, mais probablement pas pour représenter de manière
récursive des polynômes à plusieurs variables (puisque le type liste
n&#X2019;est en principe pas récursif).</P><P>Comme les HP, les TI utilisent une pile (non visible par
l&#X2019;utilisateur) appelée expression stack
afin de traduire un expression mathématique sous forme d&#X2019;un texte
en un objet symbolique codé exactement comme ci-dessus en syntaxe
polonaise. Toutefois, la présence du champ longueur
permet d&#X2019;évaluer un objet symbolique sans perdre en efficacité
en partant de l&#X2019;opérateur
final et en redescendant ensuite sur ces arguments, c&#X2019;est la stratégie
adoptée. C&#X2019;est pour cela que le tag d&#X2019;identification
se trouve à la fin de l&#X2019;objet. L&#X2019;utilisation de cette méthode
facilite grandement l&#X2019;autoquotation (on peut toutefois regretter
que le système n&#X2019;ait pas prévu d&#X2019;instruction permettant à l&#X2019;utilisateur 
d&#X2019;empêcher l&#X2019;évaluation d&#X2019;une sous-expression).</P><P>On ne peut pas faire d&#X2019;hypothèse globale sur un paramètre par
contre on peut faire des hypothèses de type appartenance à un intervalle 
ayant une portée locale.</P><!--TOC subsubsection Maple, MuPAD, Mathematica, ...-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc9">1.2.3</A>  Maple, MuPAD, Mathematica, ...</H4><!--SEC END --><P>
Ces systèmes ont un noyau fermé, au sens où l&#X2019;utilisateur n&#X2019;a pas
accès du tout, ou en tout cas pas facilement, aux structures de données
de base. Je ne dispose donc pas d&#X2019;information sur les structures de données
utilisées par le noyau (pour MuPAD, on pourrait sans doute en savoir
plus en achetant de la documentation sur la programmation des
modules dynamiques).</P><P>L&#X2019;interaction système-utilisateur se fait quasiment toujours en utilisant le
langage de programmation propre au système, langage interprété
par le noyau du système (ce qui ralentit l&#X2019;exécution). Ces langages 
utilisateurs sont essentiellement
non typés : on travaille avec des variables du type générique sans pouvoir
accéder aux types sous-jacents. On ne bénéficie en général pas des
vérifications faites lors de la compilation avec un langage typé,
de plus ces systèmes ne sont pas toujours fourni avec de bon outils de 
mise au point. Enfin ces langages ne sont pas standardisés d&#X2019;un
système à l&#X2019;autre et il est en général impossible
d&#X2019;utiliser ces systèmes comme des librairies depuis un langage
de programmation traditionnel. Leur intérêt principal réside donc
dans une utilisation interactive en profitant de la librairie de 
fonctions accessibles.</P><!--TOC subsubsection Giac/xcas-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc10">1.2.4</A>  Giac/xcas</H4><!--SEC END --><P>
Il s&#X2019;agit du système de calcul formel que j&#X2019;implémente actuellement sous 
forme d&#X2019;une bibliothèque C++ (ce qui
permettra aux programmes tiers d&#X2019;utiliser beaucoup plus facilement du 
calcul formel qu&#X2019;avec les systèmes précédents). L&#X2019;objectif est 
d&#X2019;avoir un système facile à programmer directement en C++, proche 
du langage utilisateur, lui-même compatible avec Maple ou MuPAD, 
tout cela sans trop perdre en performances comparativement aux
librairies spécialisées écrites en C/C++. Ce qui explique un choix 
de type générique (<CODE>gen</CODE>) non orienté objet, avec un champ type 
et soit une donnée immédiate (pour les nombres flottants par exemple), 
soit un pointeur vers un objet du type correspondant au champ type pour 
les données de taille non fixe (on pourrait donc se
contenter du langage C, mais le langage C++ permet de redéfinir 
les opérateurs sur des types utilisateurs ce qui
améliore considérablement la lisibilité du code source). 
Les données dynamiques ne sont pas dupliquées, Giac
utilise un pointeur sur un compteur de référence pour détruire 
ces données lorsqu&#X2019;elles ne sont plus référencées.</P><P>Les entiers en précision arbitraire sont hérités de la bibliothque
GMP (écrite en C) du projet GNU. Les flottants en précision arbitraire
utiliseront aussi GMP (plus précisément MPFR).
Il y a un type fraction, structure C composé d&#X2019;un champ numérateur
et d&#X2019;un champ dénominateur, et un type nombre complexe.</P><P>Les listes, vecteurs, matrices utilisent le type paramétré <CODE>vector&lt;&gt;</CODE>
de la librairie standard C++ (Standard Template Library).
Les objets symboliques sont des structures composés d&#X2019;un champ sommet
qui est une fonction prenant un argument de type <CODE>gen</CODE>
et renvoyant un résultat
de type <CODE>gen</CODE>, et d&#X2019;un champ feuille qui est de type <CODE>gen</CODE>.
Lorsqu&#X2019;une fonction possède plusieurs arguments, ils sont rassemblés
en une liste formant le champ feuille de l&#X2019;objet symbolique.
Les programmes sont aussi des objets symboliques, dont le champ
sommet est la fonction évaluation d&#X2019;un programme.
Les listes sont aussi utilisées pour représenter vecteurs, matrices
et polynômes en une variable en représentation dense, on peut
y accéder par valeur (<CODE>:=</CODE>) ou par référence
(<CODE>=&lt;</CODE>). Les polynômes
en représentation creuse ou en plusieurs indéterminées sont également
disponibles.</P><P>L&#X2019;évaluation d&#X2019;un objet symbolique se fait en regardant d&#X2019;abord si
la fonction au sommet doit évaluer ou non ses arguments (autoquote),
on évalue les arguments si nécessaire puis on applique la fonction.</P><P>Une hypthèse sur un paramètre est une valeur spéciale
affectée au paramètre, valeur ignorée par la routine d&#X2019;évaluation.</P><!--TOC subsection Algorithmes et complexité.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc11">1.3</A>  Algorithmes et complexité.</H3><!--SEC END --><P>
On va présenter dans la suite quelques algorithmes que l&#X2019;on peut
considérer comme classiques dans le domaine du calcul formel. Avant 
d&#X2019;implémenter ce type d&#X2019;algorithmes, on a besoin des algorithmes de base
en arithmétique. Le lecteur trouvera en appendice une brève présentation
de certains de ces algorithmes, mes références en la matière sont le livre
de Henri Cohen, et les livres de Donald Knuth (cf. appendice).</P><P>La plupart des problèmes posés en calcul formel nécessitent des
calculs dont la taille croit de manière exponentielle voire
doublement exponentielle en fonction de la taille des données et
ce même si le résultat est lui aussi de taille petite. Un
exemple est la réduction des systèmes de plusieurs équations polynomiales
(bases de Groebner).
Dans certains cas, l&#X2019;application de théories mathématiques
parfois sophistiquées permet de réduire la complexité (par exemple,
M. Van Hoeij a découvert récemment qu&#X2019;un algorithme très utilisé en théorie des
nombres, l&#X2019;algorithme LLL, permettait d&#X2019;améliorer la complexité d&#X2019;une des
étapes de la factorisation des polynomes à coefficients entiers sur les
entiers). Heureusement, dans de nombreux cas, on peut réduire la
complexité (donc le temps de calcul) par des adaptations au
problème d&#X2019;une même idée à condition de faire des
hypothèses sur les données (autrement dit en abandonnant la volonté
d&#X2019;implémenter un algorithme très générique, ou tout au moins
en spécialisant des algorithmes génériques).</P><P>Par exemple lorsqu&#X2019;on travaille
avec des entiers (ou des polynômes à coefficients entiers, ou
des matrices à coefficients entiers...) on utilise souvent des algorithmes
modulaires et <I>p</I>-adiques. Comme le calcul exact nécessite
presque toujours de calculer avec des entiers, ces méthodes
ont un rôle central en calcul formel, nous les présentons donc
maintenant brièvement. Dans les prochaines sections, nous utiliserons
ce type de méthode, par exemple pour le calcul de PGCD ou la factorisation
de polynômes à coefficients entiers.</P><P>Les méthodes modulaires consistent à réduire un problème dans 
&#X2124; à son équivalent dans <I>Z</I>/<I>n</I>&#X2124; pour une ou 
plusieurs valeurs de <I>n</I>, nombre premier. Le calcul dans &#X2124;/<I>n</I>&#X2124;
a l&#X2019;avantage de se faire avec des entiers dont la taille est bornée.
Ensuite à l&#X2019;aide d&#X2019;estimations 
à priori sur la taille des solutions 
éventuelles du problème initial, on reconstruit la solution au problème
initial avec le théorème des restes chinois. </P><P>Par exemple, on peut calculer un déterminant d&#X2019;une matrice
à coefficients entiers en cherchant ce déterminant dans &#X2124;/<I>n</I>&#X2124;
pour plusieurs premiers <I>n</I>, dont le produit est plus grand qu&#X2019;une 
estimation à priori de la taille du déterminant 
(donnée par exemple par l&#X2019;inégalité d&#X2019;Hadamard, cf. Cohen, p. 50). </P><P>Les méthodes <I>p</I>-adiques commencent de manière identique par un 
calcul dans &#X2124;/<I>n</I>&#X2124;, on augmente ensuite la
précision de la solution en la «liftant»de &#X2124;/<I>n</I><SUP><I>k</I></SUP> &#X2124; vers 
&#X2124;/<I>n</I><SUP><I>k</I>+1</SUP>&#X2124; ou vers &#X2124;/<I>n</I><SUP>2<I>k</I></SUP>&#X2124; (lift
linéaire ou lift quadratique), on s&#X2019;arrête lorsque <I>k</I> est assez grand 
(à l&#X2019;aide d&#X2019;estimations à priori) et on
reconstruit alors la solution initiale. L&#X2019;étape de «lift»est en 
général un lemme de Hensel dont on verra quelques exemples dans les
prochains articles. L&#X2019;algorithme
commun au lemme de Hensel et au théorème des restes chinois est 
l&#X2019;identité de Bézout, que l&#X2019;on retrouve 
d&#X2019;ailleurs un peu partout (par exemple pour le calcul de primitives). </P><P>Illustrons cette méthode sur un exemple simple, la recherche de 
racines rationnelles d&#X2019;un polynôme <I>P</I>(<I>X</I>)=<I>a</I><SUB><I>d</I></SUB> <I>X</I><SUP><I>d</I></SUP> + &#X22EF; + <I>a</I><SUB>0</SUB> 
à coefficients entiers ou polynomiaux, avec <I>a</I><SUB><I>d</I></SUB> et <I>a</I><SUB>0</SUB> non nuls. 
L&#X2019;algorithme générique (assez connu) consiste 
à chercher les diviseurs de <I>a</I><SUB>0</SUB> et de <I>a</I><SUB><I>d</I></SUB> et à tester toutes 
les fractions de ces diviseurs, on montre en effet 
aisément que si <I>X</I>=<I>p</I>/<I>q</I> fraction irréductible est racine de <I>P</I> 
alors <I>q</I> divise <I>a</I><SUB><I>d</I></SUB> et <I>p</I> divise <I>a</I><SUB>0</SUB>. Cet 
algorithme est très inefficace si <I>a</I><SUB><I>d</I></SUB> ou <I>a</I><SUB>0</SUB> est un grand entier 
(car on ne sait pas forcément le factoriser) ou 
s&#X2019;il a beaucoup de facteurs premiers (la liste des diviseurs à tester 
est alors très grande). </P><P>Lorsque les coefficients de <I>P</I> sont entiers, la recherche précédente 
revient à trouver un facteur à
coefficients entiers <I>qX</I>&#X2212;<I>p</I> de <I>P</I>, on peut donc réduire le problème 
modulo un entier premier <I>n</I> qui ne divise pas <I>a</I><SUB><I>d</I></SUB> : si un tel facteur 
existe dans &#X2124; alors ce facteur (réduit modulo <I>n</I>) est un facteur 
de <I>P</I> dans &#X2124;/<I>n</I>&#X2124;
donc <I>P</I> admet une racine dans &#X2124;/<I>n</I>&#X2124; (puisque <I>q</I> est inversible 
modulo <I>n</I> car on a choisi <I>n</I> premier ne divisant pas <I>a</I><SUB><I>d</I></SUB>). On
évalue maintenant <I>P</I> en les <I>n</I> éléments de &#X2124;/<I>n</I>&#X2124;. S&#X2019;il n&#X2019;y a pas 
de 0, alors <I>P</I> n&#X2019;a pas de racine rationnelle. S&#X2019;il y a des racines, on va 
les lifter de &#X2124;/<I>n</I><SUP><I>k</I></SUP>&#X2124; dans &#X2124;/<I>n</I><SUP>2<I>k</I></SUP>&#X2124;.</P><P>On suppose donc que pour <I>k</I>&#X2265; 1, il existe un entier <I>p</I><SUB><I>k</I></SUB> tel que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>p</I><SUB><I>k</I></SUB>)=0 (mod <I>n</I><SUP><I>k</I></SUP> ) </TD></TR>
</TABLE><P>
Il s&#X2019;agit de trouver un entier <I>x</I> tel que <I>p</I><SUB><I>k</I>+1</SUB>=<I>p</I><SUB><I>k</I></SUB>+<I>n</I><SUP><I>k</I></SUP>  <I>x</I>
vérifie
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>p</I><SUB><I>k</I>+1</SUB>)=0 (mod <I>n</I><SUP>2<I>k</I></SUP> ) </TD></TR>
</TABLE><P>
On applique la formule de Taylor à l&#X2019;ordre 1 pour <I>P</I> en <I>p</I><SUB><I>k</I></SUB>, le
reste est nul modulo <I>n</I><SUP>2<I>k</I></SUP>, donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>p</I><SUB><I>k</I></SUB>)+ <I>n</I><SUP><I>k</I></SUP>  <I>x</I> <I>P</I>&#X2032;(<I>p</I><SUB><I>k</I></SUB>)=0 (mod <I>n</I><SUP>2<I>k</I></SUP> ) </TD></TR>
</TABLE><P>
soit finalement :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>=&#X2212;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I>(<I>p</I><SUB><I>k</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I><SUP><I>k</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  ( <I>P</I>&#X2032;(<I>p</I><SUB><I>k</I></SUB>) (mod <I>n</I><SUP><I>k</I></SUP> )) <SUP>&#X2212;1</SUP> </TD></TR>
</TABLE><P>
On reconnaît au passage la méthode de Newton, pour qu&#X2019;elle fonctionne 
il suffit que <I>P</I>&#X2032;(<I>p</I><SUB><I>k</I></SUB>) &#X2260; 0 (mod <I>n</I> ) ce qui
permet de l&#X2019;inverser modulo <I>n</I><SUP><I>k</I></SUP> (et c&#X2019;est ici qu&#X2019;intervient 
l&#X2019;identité de Bézout). En pratique quand on factorise
un polynôme, on commence par retirer les multiplicités, 
on peut donc supposer que <I>P</I> est sans facteur multiple dans
&#X2124;. Ceci n&#X2019;entraîne pas forcément qu&#X2019;il le reste dans &#X2124;/<I>n</I>&#X2124; 
ce qui crée une contrainte supplémentaire sur le choix
de <I>n</I>, à savoir que <I>P</I> et <I>P</I>&#X2032; restent premier entre eux dans &#X2124;/<I>n</I>&#X2124; 
(il existe forcément de tels <I>n</I>, par exemple
<I>n</I> premier plus grand que le plus grand entier intervenant dans le calcul 
du PGCD de <I>P</I> et <I>P</I>&#X2032; dans &#X2124;).</P><P>Reste donc à revenir dans &#X2124; à partir d&#X2019;une racine <I>p</I><SUB><I>k</I></SUB> dans &#X2124;/(<I>n</I><SUP><I>k</I></SUP> &#X2124;)
(où on peut choisir <I>k</I>). 
On va maintenant utiliser la représentation modulaire symétrique :
on prend comme représentant modulaire d&#X2019;un entier <I>z</I> dans &#X2124;/<I>n</I><SUP><I>k</I></SUP>&#X2124;
l&#X2019;unique entier congru à <I>z</I> modulo <I>n</I> qui est strictement compris entre
&#X2212;<I>n</I><SUP><I>k</I></SUP>/2 et <I>n</I><SUP><I>k</I></SUP>/2 (si <I>n</I> est pair, la deuxième inégalité
est choisie large).</P><P>Si <I>qX</I>&#X2212;<I>p</I> est un facteur de <I>P</I>, alors <I>a</I><SUB><I>d</I></SUB><I>X</I>&#X2212;<I>a</I><SUB><I>d</I></SUB>/<I>q</I><I>p</I> est encore 
un facteur de <I>P</I> (le quotient de <I>P</I> par <I>a</I><SUB><I>d</I></SUB><I>X</I>&#X2212;<I>a</I><SUB><I>d</I></SUB>/<I>q</I><I>p</I>
est à coefficients rationnels mais le facteur est à coefficients entiers). 
Si on a choisi <I>k</I> tel que <I>n</I><SUP><I>k</I></SUP>&gt;2|<I>a</I><SUB><I>d</I></SUB> <I>a</I><SUB>0</SUB>|, l&#X2019;écriture en représentation
modulaire symétrique de <I>a</I><SUB><I>d</I></SUB><I>X</I>&#X2212;<I>a</I><SUB><I>d</I></SUB>/<I>q</I><I>p</I> est inchangée,
en effet on a des estimations à priori sur les entiers <I>p</I> et <I>q</I> : 
|<I>q</I>|&#X2264; |<I>a</I><SUB><I>d</I></SUB>| et |<I>p</I>| &#X2264; |<I>a</I><SUB>0</SUB>| puisque <I>q</I> 
divise <I>a</I><SUB><I>d</I></SUB> et <I>p</I> divise <I>a</I><SUB>0</SUB>. 
Comme <I>a</I><SUB><I>d</I></SUB><I>X</I>&#X2212;<I>a</I><SUB><I>d</I></SUB>/<I>q</I><I>p</I> est égal à <I>a</I><SUB><I>d</I></SUB>(<I>X</I>&#X2212;<I>p</I><SUB><I>k</I></SUB>) dans &#X2124;/(<I>n</I><SUP><I>k</I></SUP> &#X2124;),
il nous suffit d&#X2019;écrire en représentation modulaire 
symétrique <I>a</I><SUB><I>d</I></SUB>(<I>X</I>&#X2212;<I>p</I><SUB><I>k</I></SUB>)=<I>a</I><SUB><I>d</I></SUB> <I>X</I>&#X2212;<I>p</I>&#X2032;.
Pour conclure, on sait que <I>a</I><SUB><I>d</I></SUB> <I>X</I>&#X2212;<I>p</I>&#X2032; est un multiple entier de <I>qX</I>&#X2212;<I>p</I>.
On divise donc le facteur <I>a</I><SUB><I>d</I></SUB> <I>X</I>&#X2212;<I>p</I>&#X2032; par le pgcd de <I>a</I><SUB><I>d</I></SUB> et <I>p</I>&#X2032; et on
teste la divisibilité de <I>P</I> par ce facteur réduit.</P><P><B>Exemple</B><BR>
Considérons le polynôme 2 <I>X</I><SUP>3</SUP>&#X2212;<I>X</I><SUP>2</SUP>&#X2212;<I>X</I>&#X2212;3 qui est sans facteur carré.
On ne peut pas choisir <I>n</I>=2 car on réduirait le degré, pour <I>n</I>=3,
on a <I>P</I>&#X2032;=<I>X</I>&#X2212;1 qui est facteur de <I>P</I>, pour <I>n</I>=5, <I>P</I>&#X2032;=6<I>X</I><SUP>2</SUP>&#X2212;2<I>X</I>&#X2212;1,
on vérifie que <I>P</I> et <I>P</I>&#X2032; sont premiers entre eux (par exemple
avec <CODE>GCDMOD</CODE> sur une HP49 où on aura fixé la variable <CODE>MODULO</CODE>
à 5).</P><P>On teste ensuite les entiers de -2 à 2 sur <I>P</I>. Seul -1 est racine
modulo 5 (<I>P</I>(&#X2212;1)=&#X2212;5), on va maintenant lifter <I>p</I><SUB>1</SUB>=&#X2212;1. </P><P>L&#X2019;estimation à priori est 2|<I>a</I><SUB><I>d</I></SUB>||<I>a</I><SUB>0</SUB>|=12 donc <I>k</I>=2 (5<SUP>2</SUP>=25&gt;12), 
une itération suffira. On a <I>P</I>&#X2032;(&#X2212;1)=7, l&#X2019;inverse de <I>P</I>&#X2032;(&#X2212;1) (mod 5 )
est -2 donc:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>= &#X2212;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I>(&#X2212;1)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">5</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (&#X2212;2) = &#X2212;(&#X2212;1)  (&#X2212;2)=&#X2212;2 </TD></TR>
</TABLE><P>
et <I>p</I><SUB>2</SUB>=&#X2212;1+5×(&#X2212;2)=&#X2212;11 est racine de <I>P</I> dans &#X2124;/25&#X2124;.
On calcule ensuite <I>a</I><SUB><I>d</I></SUB>(<I>X</I>&#X2212;<I>p</I><SUB><I>k</I></SUB>)=2(<I>X</I>+11)=2<I>X</I>+22=2<I>X</I>&#X2212;3 en représentation
symétrique, le PGCD de 2 et -3 est 1 donc on teste le facteur
2<I>X</I>&#X2212;3, ici il divise <I>P</I> donc <I>P</I> admet un unique facteur entier
de degré 1 qui est 2<I>X</I>&#X2212;3.</P><!--TOC section Quelques algorithmes d&#X2019;arithmétique de base.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc12">2</A>  Quelques algorithmes d&#X2019;arithmétique de base.</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
Les algorithmes de multiplication et division dit rapides
des entiers et polynômes (Karatsuba, FFT, ...). Cf. par exemple Knuth.
ou pour les entiers la documentation de GMP.
</LI><LI CLASS="li-itemize">Au lieu de la division euclidienne, on utilise très souvent la
pseudo-division pour les polynômes : étant donné deux polynômes <I>A</I>
et <I>B</I> de degrés <I>a</I> et <I>b</I> à coefficients dans un anneau contenu dans un corps
(par exemple &#X2124;), on multiplie <I>A</I> par une puissance du coefficient
dominant <I>B</I><SUB><I>b</I></SUB> de <I>B</I>, plus précisément par <I>B</I><SUB><I>b</I></SUB><SUP><I>a</I>&#X2212;<I>b</I>+1</SUP>, ce qui permet 
d&#X2019;effectuer la division par <I>B</I> sans que
les coefficients sortent de l&#X2019;anneau.
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>B</I><SUB><I>b</I></SUB><SUP><I>a</I>&#X2212;<I>b</I>+1</SUP> <I>A</I>= <I>B</I> <I>Q</I> + <I>R</I> </TD></TR>
</TABLE>
On utilise cette méthode lorsqu&#X2019;on peut multiplier les polynômes par
des constantes sans changer le problème (par exemple pour l&#X2019;algorithme
d&#X2019;Euclide).
</LI><LI CLASS="li-itemize">L&#X2019;algorithme d&#X2019;Euclide est un algorithme «générique»de calcul
de PGCD. Il n&#X2019;est en général pas utilisé tel quel. Pour les entiers 
on utilise une variation adaptée à la
représentation binaire des entiers (cf. Cohen ou le manuel de GMP version 4 
pour plus de détails). Nous décrirons des
algorithmes de PGCD plus efficaces pour les polynômes dans le prochain article.
</LI><LI CLASS="li-itemize">l&#X2019;identité de Bézout, aussi appelée PGCD étendu. Étant donné
deux entiers ou deux polynômes <I>a</I> et <I>b</I> on calcule <I>u</I>, <I>v</I> et
<I>d</I> tels que <I>au</I>+<I>bv</I>=<I>d</I>. On écrit la matrice :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I>a</I></TD><TD ALIGN=left NOWRAP>1</TD><TD ALIGN=left NOWRAP>0 </TD></TR>
<TR><TD ALIGN=left NOWRAP><I>b</I></TD><TD ALIGN=left NOWRAP>0</TD><TD ALIGN=left NOWRAP>1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE>
où on remarque que pour chaque ligne le coefficient de la 1ère colonne 
est égal à <I>a</I> multiplié par le coefficient de la
2ème colonne additionné à <I>b</I> multiplié par le coefficient de la 
3ème colonne. Ce qui reste vrai si on effectue des
combinaisons linéaires de lignes (type réduction de Gauß). 
Comme on travaille dans les entiers ou les polynômes, on remplace la
réduction de Gauß des matrices à coefficients réels par une combinaison 
linéaire utilisant le quotient <EM>euclidien</EM> <I>q</I>
de <I>a</I> par <I>b</I>. On obtient alors le reste <I>r</I> en 1ère colonne :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>L</I><SUB>3</SUB>=<I>L</I><SUB>1</SUB>&#X2212;<I>qL</I><SUB>2</SUB>    </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I>a</I></TD><TD ALIGN=left NOWRAP>1</TD><TD ALIGN=left NOWRAP>0 </TD></TR>
<TR><TD ALIGN=left NOWRAP><I>b</I></TD><TD ALIGN=left NOWRAP>0</TD><TD ALIGN=left NOWRAP>1 </TD></TR>
<TR><TD ALIGN=left NOWRAP><I>r</I></TD><TD ALIGN=left NOWRAP>1</TD><TD ALIGN=left NOWRAP>&#X2212;<I>q</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE>
et on recommence jusqu&#X2019;à obtenir 0 en 1ère colonne.
L&#X2019;avant-dernière ligne obtenue est l&#X2019;identité de Bézout (la dernière
ligne donne le PPCM de <I>a</I> et <I>b</I>). Si l&#X2019;on veut l&#X2019;inverse de <I>a</I> modulo
<I>b</I> on remarque qu&#X2019;il n&#X2019;est pas utile de calculer les coefficients
appartenant à la 3ème colonne. Enfin, les lignes intermédiaires
peuvent servir à reconstruire une fraction d&#X2019;entier représentée
par un entier de &#X2124;/<I>n</I>&#X2124; lorsque le numérateur et le dénominateur
sont de valeur absolue inférieure à &#X221A;<SPAN style="text-decoration:overline"><I>n</I>/2</SPAN>.
</LI><LI CLASS="li-itemize">Le théorème des restes chinois. Si on connaît <I>x</I>=<I>a</I> (mod <I>m</I> )
et <I>x</I>= <I>b</I> (mod <I>n</I> )  avec <I>m</I> et <I>n</I> premiers entre eux,
on détermine <I>c</I> tel que
<I>x</I>=<I>c</I> (mod <I>m</I>× <I>n</I> ) (<I>c</I>=<I>a</I>+<I>mu</I>=<I>b</I>+<I>nv</I> et on applique
Bézout pour trouver <I>u</I> et <I>v</I>, on en déduit <I>c</I>).
</LI><LI CLASS="li-itemize">Les tests de pseudo-primalité. Il est essentiel d&#X2019;avoir une
méthode rapide permettant de générer des nombres premiers pour appliquer
des méthodes modulaires et <I>p</I>-adiques. On utilise par exemple le
test de Miller-Rabin, qui prolonge le petit théorème de Fermat
(si <I>p</I> est premier, alors <I>a</I><SUP><I>p</I></SUP>=<I>a</I> (mod <I>p</I> )).
</LI></UL><!--TOC subsection Pour en savoir plus.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">2.1</A>  Pour en savoir plus.</H3><!--SEC END --><P>
Sur des aspects plus théoriques :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Knuth: TAOCP (The Art of Computer Programming), volumes 1 et suivants
</LI><LI CLASS="li-itemize">Henri Cohen: A Course in Computational Algebraic Number Theory
</LI><LI CLASS="li-itemize">Davenport, Siret, Tournier: Calcul formel: Systèmes et algorithmes 
de manipulations algébriques
</LI></UL><P>Sur des aspects plus pratiques, quelques références en ligne, 
la plupart sont accessibles gratuitement :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
le code source de Giac disponible à l&#X2019;URL :<BR>
<CODE>http://www-fourier.ujf-grenoble.fr/~parisse/giac.html</CODE>
</LI><LI CLASS="li-itemize">le code source de GiNaC, cf. :
<CODE>http://www.ginac.de</CODE>
</LI><LI CLASS="li-itemize">le site <CODE>http://www.hpcalc.org</CODE> pour les calculatrices HP,
on y trouve tout, de la documentation, des émulateurs de
calculatrices HP, des outils de développement pour Windows
et Unix/Linux, ... Pour ce qui concerne cet article, je conseille de lire<BR>
<CODE>http://www.hpcalc.org/hp48/docs/programming/rplman.zip</CODE>
</LI><LI CLASS="li-itemize">le site <CODE>http://www.ticalc.org</CODE>, on y trouve le portage
tigcc du compilateur C de GNU, des émulateurs, etc. Des informations de 
cet article ont leur source dans le guide du
développeur TI89/92<BR>
<CODE>http://education.ti.com/</CODE>
</LI><LI CLASS="li-itemize">la librairie du système <CODE>MuPAD</CODE> (archivée dans le fichier
<CODE>lib.tar</CODE> des distributions Unix, pour une installation
par défaut, ce fichier
se trouve dans le rérpertoire <CODE>/usr/local/MuPAD/share/lib</CODE>), 
cf. <CODE>www.sciface.com</CODE> pour obtenir une licence
d&#X2019;utilisation.
</LI><LI CLASS="li-itemize">en Maple, il est possible de
décompiler une instruction <CODE>Maple</CODE> avec la commande<BR>
<CODE>eval(instruction);</CODE><BR>
après avoir tapé<BR>
<CODE>interface(verboseproc=2);</CODE>
</LI><LI CLASS="li-itemize">le source du plus ancien système de calcul formel <CODE>maxima</CODE>
(devenu logiciel libre) pour les personnes familières du langage Lisp<BR>
<CODE>http://sourceforge.net/projects/maxima</CODE><BR>
de même pour le système Axiom
</LI><LI CLASS="li-itemize">le source de librairies plus spécialisées (GMP, GP-PARI, Singular,
NTL, Zen, ALP, GAP, CoCoA, ...), rechercher ces moms sur google.
</LI></UL><!--TOC section Exercices sur types, calcul exact et approché, 
algorithmes de bases-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc14">3</A>  Exercices sur types, calcul exact et approché, 
algorithmes de bases</H2><!--SEC END --><P>
Pour télécharger et installer Xcas sur votre ordinateur, suivre
les instructions données sur<BR>
<CODE>http://www-fourier.ujf-grenoble.fr/~parisse/giac_fr.html</CODE><BR>
Pour lancer <TT>xcas</TT> sous Unix, ouvrir un fenêtre terminal et
taper la commande<BR>
<CODE>  xcas &amp; </CODE><BR>
Lors de la première exécution, vous devrez choisir entre
différents types de syntaxe (compatible C, maple ou TI89). Vous
pouvez changer ce choix à tout moment en utilisant le menu
Configuration-&gt;mode (syntaxe).</P><P>L&#X2019;aide en ligne est accessible en tapant <CODE>?nom_de_commande</CODE>.
Dans Xcas, vous pouvez aussi taper le début d&#X2019;un
nom de commande puis la touche de tabulation (à gauche du A sur
un clavier francais), sélectionner la commande dans la boite
de dialogues puis cliquer sur Details pour avoir une aide plus
complète dans votre navigateur. Pour plus de détails sur
l&#X2019;interface de Xcas, consultez le manuel (Aide-&gt;Interface).
Si vous n&#X2019;avez jamais utilisé de logiciel de calcul formel,
vous pouvez commencer par lire le tutoriel (menu Aide-&gt;Debuter en
calcul formel-&gt;tutoriel) et faire certains des exercices 
proposés (des corrigés sous forme de sessions Xcas sont 
dans Aide-&gt;Debuter en calcul formel-&gt;solutions)</P><P>Il peut être interessant de tester ces exercices
en parallèle avec Xcas et des calculatrices
formelles....
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Utiliser la commande <TT>type</TT> ou <TT>whattype</TT> ou équivalent
pour déterminer la représentation
utilisée par le logiciel pour représenter
une fraction, un nombre complexe, un flottant en précision machine, 
un flottant avec 100 décimales, la variable <I>x</I>, l&#X2019;expression sin(<I>x</I>)+2,
la fonction <TT>x-&gt;sin(x)</TT>, une liste, une séquence, un vecteur,
une matrice. Essayez d&#X2019;accéder aux parties de
l&#X2019;objet pour les objets composites (en utilisant <TT>op</TT> par exemple).</LI><LI CLASS="li-enumerate">Comparer le type de l&#X2019;objet <CODE>t</CODE> si on effectue
la commande <CODE>t[2]:=0;</CODE> après avoir purgé <CODE>t</CODE>
ou après avoir affecté <CODE>t:=[1,2,3]</CODE> ?</LI><LI CLASS="li-enumerate">Comparer l&#X2019;effet de l&#X2019;affectation dans une liste et dans un
vecteur ou une matrice sur votre logiciel (en Xcas, on peut utiliser
<CODE>=&lt;</CODE> au lieu de <CODE>:=</CODE> pour stocker par référence).</LI><LI CLASS="li-enumerate">Voici un programme écrit en syntaxe compatible maple
(menu Cfg-&gt;Mode-&gt;maple dans Xcas) qui calcule la base utilisée
pour représenter les flottants. 
<PRE CLASS="verbatim">Base:=proc()
local A,B;
A:=1.0; B:=1.0;
while evalf(evalf(A+1.0)-A)-1.0=0.0 do A:=2*A; od;
while evalf(evalf(A+B)-A)-B&lt;&gt;0 do B:=B+1; od;
B;
end; 
</PRE>Testez-le et expliquez.</LI><LI CLASS="li-enumerate">Déterminer le plus grand réel positif <I>x</I> de la forme 
2<SUP>&#X2212;<I>n</I></SUP> (<I>n</I> entier)
tel que (1.0+<I>x</I>)&#X2212;1.0 renvoie 0 sur PC avec la précision par
défaut puis avec <CODE>Digits:=30</CODE>.</LI><LI CLASS="li-enumerate">Calculer la valeur de <I>a</I>:=exp(&#X3C0; &#X221A;<SPAN style="text-decoration:overline">163</SPAN>) avec 30 chiffres
significatifs, puis sa partie fractionnaire. Proposez une commande
permettant de décider si <I>a</I> est un entier.</LI><LI CLASS="li-enumerate">Déterminer la valeur et le signe de la fraction rationnelle 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I>(<I>x</I>,<I>y</I>)= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1335</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">4</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>y</I><SUP>6</SUP> + <I>x</I><SUP>2</SUP> (11<I>x</I><SUP>2</SUP> <I>y</I><SUP>2</SUP>&#X2212;<I>y</I><SUP>6</SUP> &#X2212;121<I>y</I><SUP>4</SUP>&#X2212;2) + 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">11</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>y</I><SUP>8</SUP> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2<I>y</I></TD></TR>
</TABLE></TD></TR>
</TABLE>
en <I>x</I>=77617 et <I>y</I>=33096 en faisant deux calculs, l&#X2019;un en mode approché et 
l&#X2019;autre en mode exact. Que pensez-vous de ces résultats?
Combien de chiffres significatifs faut-il pour obtenir un résultat
raisonnable en mode approché?</LI><LI CLASS="li-enumerate">À quelle vitesse votre logiciel multiplie-t-il des
grands entiers (en fonction du nombre de chiffres)? 
On pourra tester le temps de calcul du produit
de <I>a</I>(<I>a</I>+1) où <I>a</I>=10 000!, <I>a</I>=15000!, etc. </LI><LI CLASS="li-enumerate">Comparer le temps de calcul de <I>a</I><SUP><I>n</I></SUP> (mod <I>m</I> ) par la fonction
<CODE>powmod</CODE> et la méthode prendre le reste modulo <I>m</I> après avoir 
calculé <I>a</I><SUP><I>n</I></SUP>.<BR>
Programmez la méthode rapide et la méthode lente.<BR>
Que se passe-t-il si on essaie d&#X2019;appliquer l&#X2019;algorithme de la
puissance rapide pour calculer (<I>x</I>+<I>y</I>+<I>z</I>+1)<SUP>32</SUP> ? Calculer le nombre
de termes dans le développement de (<I>x</I>+<I>y</I>+<I>z</I>+1)<SUP><I>n</I></SUP> et expliquez.</LI><LI CLASS="li-enumerate">Déterminer un entier <I>c</I> tel que <I>c</I>=1 (mod 3 ), 
<I>c</I>=3 (mod 5 ), <I>c</I>=5 (mod 7 ) et <I>c</I>=2 (mod 1 )1.</LI><LI CLASS="li-enumerate">Programmation de la méthode de Horner<BR>
Il s&#X2019;agit d&#X2019;évaluer efficacement un polynôme 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>X</I>) = <I>a</I><SUB><I>n</I></SUB> <I>X</I><SUP><I>n</I></SUP> + ... + <I>a</I><SUB>0</SUB> </TD></TR>
</TABLE>
en un point.
On pose <I>b</I><SUB>0</SUB>=<I>P</I>(&#X3B1; ) et on écrit :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>X</I>)&#X2212;<I>b</I><SUB>0</SUB>=(<I>X</I>&#X2212;&#X3B1; )<I>Q</I>(<I>X</I>) </TD></TR>
</TABLE>
où :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Q</I>(<I>X</I>) = <I>b</I><SUB><I>n</I></SUB> <I>X</I><SUP><I>n</I>&#X2212;1</SUP> + ... +<I>b</I><SUB>2</SUB> <I>X</I> + <I>b</I><SUB>1</SUB> </TD></TR>
</TABLE>
On calcule alors par ordre décroissant <I>b</I><SUB><I>n</I></SUB>, <I>b</I><SUB><I>n</I>&#X2212;1</SUB>, ..., <I>b</I><SUB>0</SUB>.
<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
Donner <I>b</I><SUB><I>n</I></SUB> en fonction de <I>a</I><SUB><I>n</I></SUB> puis pour <I>i</I>&#X2264; <I>n</I>&#X2212;1, <I>b</I><SUB><I>i</I></SUB>
en fonction de <I>a</I><SUB><I>i</I></SUB> et <I>b</I><SUB><I>i</I>+1</SUB>. Indiquez le détail des calculs
pour <I>P</I>(<I>X</I>)=<I>X</I><SUP>3</SUP>&#X2212;2<I>X</I>+5 et une valeur de &#X3B1;  non nulle.
</LI><LI CLASS="li-enumerate">Écrire un fonction <CODE>horn</CODE> effectuant ce calcul:
on donnera en arguments le polynôme sous forme de la
liste de ces coefficients (dans l&#X2019;exemple <CODE>[1,0,-2,5]</CODE>) et la
valeur de &#X3B1;  et le programme renverra <I>P</I>(&#X3B1; ).
(On pourra aussi renvoyer les coefficients de <I>Q</I>).
</LI><LI CLASS="li-enumerate">En utilisant cette fonction, écrire une fonction qui calcule
le développement de Taylor complet d&#X2019;un polynôme en un point.
</LI></OL></LI><LI CLASS="li-enumerate">Algorithmes de base : écrire des programmes implémentant
<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
le pgcd de 2 entiers
</LI><LI CLASS="li-enumerate">l&#X2019;algorithme de Bézout
</LI><LI CLASS="li-enumerate">l&#X2019;inverse modulaire en ne calculant que ce qui est nécessaire
dans l&#X2019;algorithme de Bézout
</LI><LI CLASS="li-enumerate">les restes chinois
</LI></OL></LI></OL><!--TOC section Le PGCD-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc15">4</A>  Le PGCD</H2><!--SEC END --><P>
Comme on l&#X2019;a remarqué dans le premier article, l&#X2019;algorithme d&#X2019;Euclide est
inefficace pour calculer le pgcd de deux polynômes à coefficients entiers. On
va présenter ici les algorithmes utilisés habituellement par les systèmes de
calcul formel: sous-résultant (PRS), modulaire (GCDMOD), <I>p</I>-adique (EEZGD) et
heuristique (GCDHEU). Le premier est une adaptation de l&#X2019;algorithme d&#X2019;Euclide
et s&#X2019;adapte à des coefficients assez génériques. Les trois autres ont en
commun d&#X2019;évaluer une ou plusieurs variables du polynôme (dans ce dernier cas
il est nécessaire de bien distinguer le cas de polynômes à plusieurs
variables) et de reconstruire le pgcd par des techniques distinctes, la
plupart du temps ces algorithmes fonctionnent seulement si les coefficients
sont entiers.</P><P>Soit donc  <I>P</I> et <I>Q</I> deux polynômes à coefficients dans un corps. Le
pgcd de <I>P</I> et <I>Q</I> n&#X2019;est défini qu&#X2019;à une constante près. Mais lorsque les
coefficients de <I>P</I> et <I>Q</I> sont dans un anneau euclidien comme par exemple
&#X2124; ou
&#X2124;[ <I>i</I> ], on appelle pgcd de <I>P</I> et <I>Q</I> un polynôme <I>D</I> tel
que <I>P</I> / <I>D</I> et <I>Q</I> / <I>D</I> soient encore à coefficients dans l&#X2019;anneau, et que <I>D</I>
soit optimal, c&#X2019;est-à-dire que si un multiple µ <I>D</I> de <I>D</I> vérifie <I>P</I> / µ
<I>D</I> et <I>Q</I> / µ <I>D</I> sont à coefficients dans l&#X2019;anneau, alors µ est
inversible. La première étape d&#X2019;un algorithme de calcul de pgcd consiste donc
à diviser par le pgcd des coefficients entiers de chaque polynôme.</P><P><B>Exemple</B>: <I>P</I> = 4 <I>X</I><SUP>2</SUP> &#X2212; 4 et <I>Q</I> = 6 <I>X</I><SUP>2</SUP> + 12 <I>X</I> + 6. Le polynôme
<I>X</I> + 1 est un pgcd de <I>P</I> et <I>Q</I> puisqu&#X2019;il est de degré maximal divisant <I>P</I>
et <I>Q</I> mais le pgcd de <I>P</I> et <I>Q</I> est 2 ( <I>X</I> + 1 ). Remarquons qu&#X2019;avec notre
définition &#X2212; 2 ( <I>X</I> + 1 ) convient aussi. Par convention on appelera pgcd le
polynôme ayant un coefficient dominant positif.</P><P><B>Définition</B>: On appelle contenu <I>c</I> ( <I>P</I> ) d&#X2019;un polynôme <I>P</I> le
pgcd des coefficients de <I>P</I>. On définit alors la partie primitive de <I>P</I>:
pp( <I>P</I> ) = <I>P</I> / <I>c</I> ( <I>P</I> ). Si <I>c</I>(<I>P</I>)=1, on dit que <I>P</I> est primitif.
On montre que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>D</I> = pgcd ( <I>P</I>, <I>Q</I> ) = pgcd ( <I>c</I> ( <I>P</I> ), <I>c</I> ( <I>Q</I> )) pgcd (
pp ( <I>P</I> ), pp ( <I>Q</I> )) </TD></TR>
</TABLE><!--TOC subsection Le sous-résultant.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc16">4.1</A>  Le sous-résultant.</H3><!--SEC END --><P>La première idée qui vient à l&#X2019;esprit pour améliorer l&#X2019;efficacité de
l&#X2019;algorithme d&#X2019;Euclide consiste à éviter les fractions qui sont créées par les
divisions euclidiennes. On utilise à cet effet la pseudo-division: au lieu de
prendre le reste <I>R</I> de la division euclidienne du polynôme <I>P</I> par <I>Q</I>, on
prend le reste de la division de <I>P</I> <I>q</I><SUP>&#X3B4; + 1</SUP> par <I>Q</I>, où <I>q</I> désigne le
coefficient dominant de <I>Q</I> et &#X3B4; la différence entre le degré de <I>P</I> et
de <I>Q</I>.</P><P><B>Exercice:</B> En utilisant votre système de calcul formel préféré,
calculez les restes intermédiaires générés dans l&#X2019;algorithme d&#X2019;Euclide
lorsqu&#X2019;on utilise la pseudo-division par exemple pour les polynômes <I>P</I> ( <I>x</I> ) =
( <I>x</I> + 1 )<SUP>7</SUP> &#X2212; ( <I>x</I> &#X2212; 1 )<SUP>6</SUP> et sa dérivée.</P><P><B>Une solution avec giac/xcas</B>:
</P><PRE CLASS="verbatim">// -*- mode:C++ -*- a,b 2 polynomes -&gt; pgcd de a et b
pgcd(a,b):={ 
 local P,p,Q,q,R,g,h,d;
 // convertit a et b en polynomes listes et extrait la partie primitive   
 P:=symb2poly1(a);
 p:=lgcd(P); // pgcd des elements de la liste
 P:=P/p; 
 Q:=symb2poly1(b);
 q:=lgcd(Q);
 Q:=Q/q; 
 if (size(P)&lt;size(Q)){ // echange P et Q
  R:=P; P:=Q; Q:=R; 
 } 
 // calcul du contenu du pgcd
 p:=gcd(p,q);
 g:=1;
 h:=1;
 while (size(Q)!=1){
  q:=Q[0]; // coefficient dominant
  d:=size(P)-size(Q);
  R:=rem(q^(d+1)*P,Q);
  if (size(R)==0) return(p*poly12symb(Q/lgcd(Q),x));
  P:=Q;
  Q:=R;
  // ligne suivante a decommenter pour prs 
  // Q:=R/(g*h^d);
  print(Q);
  // ligne suivante a decommenter pour prs 
  // g:=q; h:=q^d/h^(d-1);
 } 
 return(p);
}
</PRE><P>On s&#X2019;aperçoit que les coefficients croissent de manière exponentielle. La
deuxième idée qui vient naturellement est alors à chaque étape de rendre le
reste primitif, donc de diviser <I>R</I> par le pgcd de ces coefficients. Cela
donne un algorithme plus efficace, mais encore assez peu efficace car à chaque
étape on doit calculer le pgcd de tous les coefficients, on peut imaginer le
temps que cela prendra en dimension 1 et à fortiori en dimension supérieure.
L&#X2019;idéal serait de connaitre à l&#X2019;avance une quantité suffisamment grande qui
divise tous les coefficients du reste.</P><P>C&#X2019;est ici qu&#X2019;intervient l&#X2019;algorithme du sous-résultant: après chaque
pseudo-division euclidienne, on exhibe un coefficient "magique" qui divise les
coefficients du reste. Ce coefficient n&#X2019;est pas le pgcd mais il est
suffisamment grand pour qu&#X2019;on évite la croissance exponentielle des
coefficients.</P><P><B>Algorithme du sous-résultant</B></P><P>Arguments: 2 polynômes <I>P</I> et <I>Q</I> primitifs. Valeur de retour: le pgcd de <I>P</I>
et <I>Q</I>.</P><P>Pour calculer le coefficient "magique" on utilise 2 variables auxiliaires <I>g</I>
et <I>h</I> initialisées a 1.</P><P>Boucle à effectuer tant que <I>Q</I> est non nul:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
on note &#X3B4; =degre(<I>P</I>)-degre(<I>Q</I>) et <I>q</I> le coefficient dominant
de <I>Q</I></LI><LI CLASS="li-itemize">on effectue la division euclidienne (sans fraction) de <I>q</I><SUP>&#X3B4; + 1</SUP>
<I>P</I> par <I>Q</I>, soit <I>R</I> le reste</LI><LI CLASS="li-itemize">Si <I>R</I> est constant, on sort de l&#X2019;algorithme en renvoyant 1 comme pgcd</LI><LI CLASS="li-itemize">on recopie <I>Q</I> dans <I>P</I> puis <I>R</I> / ( <I>g</I> <I>h</I><SUP>&#X3B4;</SUP> ) dans <I>Q</I></LI><LI CLASS="li-itemize">on recopie <I>q</I> dans <I>g</I> et <I>h</I><SUP>1 &#X2212; &#X3B4;</SUP> <I>q</I><SUP>&#X3B4;</SUP> dans <I>h</I>.
</LI></UL><P>
Si on sort normalement de la boucle, <I>Q</I> est nul, on renvoie donc la partie
primitive de <I>P</I> qui est le pgcd cherché.</P><P>Pour tester l&#X2019;algorithme avec <TT>xcas</TT>, il suffit de décommenter les
deux lignes <TT>Q:=R/(g*h^d);</TT> et <TT>g:=q; h:=q^d/h
(d-1);</TT> ci-dessus.</P><P>La preuve de l&#X2019;algorithme est un peu longue et par ailleurs bien expliquée
dans le 2ème tome de Knuth (The Art of Computer Programming, Semi-numerical
Algorithms), on y renvoie donc le lecteur intéressé. L&#X2019;idée générale
(et l&#X2019;origine du nom de l&#X2019;algorithme) 
est de considérer la matrice de Sylvester des polynômes de
départ <I>P</I> et <I>Q</I> (celle dont le déterminant est appelé résultant de <I>P</I> et
<I>Q</I>) et de traduire les pseudo-divisions qui permettent de calculer les restes
successifs du sous-résultant en opération de ligne sur ces matrices. On
démontre alors que les coefficients de <I>R</I> divisés par <I>g</I> <I>h</I><SUP>&#X3B4;</SUP> peuvent
être interprétés comme des déterminants de sous-matrices de la matrice de
Sylvester après réduction et c&#X2019;est cela qui permet de conclure qu&#X2019;ils sont
entiers.</P><P>Par exemple, supposons que <I>P</I>=<I>R</I><SUB>0</SUB>, <I>Q</I>=<I>R</I><SUB>1</SUB>, <I>R</I><SUB>2</SUB>... diminuent de 1 en degré
à chaque division 
(c&#X2019;est le cas générique dans le déroulement de l&#X2019;algorithme
d&#X2019;Euclide). Dans ce cas, &#X3B4;=1, il s&#X2019;agit par exemple
de montrer que le reste <I>R</I><SUB>3</SUB> de <I>Q</I>=<I>R</I><SUB>1</SUB> par <I>R</I><SUB>2</SUB> est divisible par le
carré du coefficient dominant de <I>Q</I>=<I>R</I><SUB>1</SUB>.
Voyons comment on obtient les coefficients de <I>R</I><SUB>3</SUB>
à partir de la matrice de Sylvester de <I>P</I> et <I>Q</I>. 
Prenons la sous-matrice constituée des 2 premières lignes de <I>P</I>
et des 3 premières lignes de <I>Q</I> et réduisons-la sous forme
échelonnée sans introduire de dénominateur. 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I></SUB></TD><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I>&#X2212;3</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I></SUB></TD><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>p</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;3</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;4</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;3</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP>...  </TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
On effectue <I>L</I><SUB>1</SUB> &#X2190; <I>q</I><SUB><I>n</I>&#X2212;1</SUB> <I>L</I><SUB>1</SUB> &#X2212; <I>p</I><SUB><I>n</I></SUB> <I>L</I><SUB>3</SUB>
et <I>L</I><SUB>2</SUB> &#X2190; <I>q</I><SUB><I>n</I>&#X2212;1</SUB> <I>L</I><SUB>2</SUB> &#X2212; <I>p</I><SUB><I>n</I></SUB> <I>L</I><SUB>4</SUB>, ce qui correspond à
l&#X2019;élimination du terme en <I>x</I> du quotient de <I>P</I> par <I>Q</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;1</SUB> <I>p</I><SUB><I>n</I>&#X2212;1</SUB> &#X2212; <I>p</I><SUB><I>n</I></SUB> <I>q</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;1</SUB> <I>p</I><SUB><I>n</I>&#X2212;1</SUB> &#X2212; <I>p</I><SUB><I>n</I></SUB> <I>q</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;3</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;4</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;3</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP>...  </TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
on effectue ensuite 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>L</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP>&#X2190;</TD><TD ALIGN=left NOWRAP><I>q</I><SUB><I>n</I>&#X2212;1</SUB> <I>L</I><SUB>1</SUB> &#X2212; (<I>q</I><SUB><I>n</I>&#X2212;1</SUB> <I>p</I><SUB><I>n</I>&#X2212;1</SUB> &#X2212; <I>p</I><SUB><I>n</I></SUB> <I>q</I><SUB><I>n</I>&#X2212;2</SUB>)  <I>L</I><SUB>4</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>L</I><SUB>2</SUB></TD><TD ALIGN=center NOWRAP>&#X2190;</TD><TD ALIGN=left NOWRAP><I>q</I><SUB><I>n</I>&#X2212;1</SUB> <I>L</I><SUB>2</SUB> &#X2212; (<I>q</I><SUB><I>n</I>&#X2212;1</SUB> <I>p</I><SUB><I>n</I>&#X2212;1</SUB> &#X2212; <I>p</I><SUB><I>n</I></SUB> <I>q</I><SUB><I>n</I>&#X2212;2</SUB>)  <I>L</I><SUB>5</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P> 
ce qui correspond à l&#X2019;élimination du terme constant du quotient
de <I>P</I> par <I>Q</I>, on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>r</I><SUB>2,<I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>r</I><SUB>2,<I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;3</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;4</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;3</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP>...  </TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
si on enlève les lignes 3 et 4, et les colonnes 1 et 2,
on obtient (après échanges
de lignes) une sous-matrice de la matrice de Sylvester de <I>Q</I> et <I>R</I><SUB>2</SUB>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> <I>q</I><SUB><I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>q</I><SUB><I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP> <I>r</I><SUB>2,<I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP> 0</TD><TD ALIGN=center NOWRAP><I>r</I><SUB>2,<I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
On recommence les opérations de réduction de cette sous-matrice
correspondant à la division euclidienne de <I>Q</I> par <I>R</I><SUB>2</SUB>, on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>r</I><SUB>3,<I>n</I>&#X2212;3</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP> <I>r</I><SUB>2,<I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP> 0</TD><TD ALIGN=center NOWRAP><I>r</I><SUB>2,<I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
puis après suppression des colonnes 1 et 2 et des lignes 2 et 3
la ligne des coefficients de <I>R</I><SUB>3</SUB>.</P><P>Supposons qu&#X2019;on se limite dès le début de la réduction à ne
garder que les colonnes 1 à 4 et une 5-ième colonne parmi
les suivantes, on obtient à la fin de la réduction
une matrice 1,1 qui contient
un des coefficients de <I>R</I><SUB>3</SUB> (selon le choix de la 5-ième colonne).
Donc ce coefficient est égal au déterminant de la matrice 1,1
qui est égal, au signe près, au déterminant de la matrice 3,3
dont il est issu par notre réduction (en effet, dans la 2ième
partie de la réduction,
on a multiplié deux fois <I>L</I><SUB>1</SUB> par <I>r</I><SUB>2,<I>n</I>&#X2212;2</SUB>, mais on doit ensuite diviser 
le déterminant par <I>r</I><SUB>2,<I>n</I>&#X2212;2</SUB><SUP>2</SUP> pour éliminer les colonnes 1 et 2).
Quant au déterminant de la matrice 3,3, il se déduit du
déterminant de la matrice 5,5 par multiplication par <I>q</I><SUB><I>n</I>&#X2212;1</SUB><SUP>4</SUP>
(2 lignes ont été multipliées 2 fois par <I>q</I><SUB><I>n</I>&#X2212;1</SUB>) et division
par <I>q</I><SUB><I>n</I>&#X2212;1</SUB><SUP>2</SUP> (élimination des colonnes 1 et 2). Au final,
tout coefficient de <I>R</I><SUB>3</SUB> est égal au produit d&#X2019;un déterminant
5,5 extrait de la matrice de Sylvester de <I>P</I> et <I>Q</I> par <I>q</I><SUB><I>n</I>&#X2212;1</SUB><SUP>2</SUP>,
qui est justement le coefficient &#X201C;magique&#X201D; par lequel on divise le reste
de <I>R</I><SUB>1</SUB>=<I>Q</I> par <I>R</I><SUB>2</SUB> lors de l&#X2019;algorithme du sous-résultant.</P><!--TOC subsection Le pgcd en une variable-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc17">4.2</A>  Le pgcd en une variable</H3><!--SEC END --><P>.</P><!--TOC subsubsection Le pgcd heuristique.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc18">4.2.1</A>  Le pgcd heuristique.</H4><!--SEC END --><P>On suppose ici que les coefficients sont entiers ou entiers de Gauss.
<B>On peut donc se ramener au cas où les polynômes sont primitifs.</B></P><P>L&#X2019;idée consiste à évaluer <I>P</I> et <I>Q</I> en un entier <I>z</I> et à extraire des
informations du pgcd <I>g</I> des entiers <I>P</I> ( <I>z</I> ) et <I>Q</I> ( <I>z</I> ). Il faut donc un
moyen de remonter de l&#X2019;entier <I>g</I> à un polynôme <I>G</I> tel que <I>G</I> ( <I>z</I> ) = <I>g</I>. La
méthode consiste à écrire en base <I>z</I> l&#X2019;entier <I>g</I>, avec une particularité
dans les divisions euclidiennes successives on utilise le reste symétrique
(compris entre &#X2212; <I>z</I> / 2 et <I>z</I> / 2). Cette écriture donne les coefficients
d&#X2019;un polynôme <I>G</I> unique. On extrait ensuite la partie primitive de ce
polynôme <I>G</I>. Lorsque <I>z</I> est assez grand par rapport aux coefficients des
polynômes <I>P</I> et <I>Q</I>, si pp ( <I>G</I> ) divise <I>P</I> et <I>Q</I>, on va montrer
que le pgcd de <I>P</I> et de <I>Q</I> est <I>D</I> = pp ( <I>G</I> ).</P><P>On remarque tout d&#X2019;abord que <I>d</I> : = <I>D</I> ( <I>z</I> ) divise <I>g</I>. En effet <I>D</I> divise
<I>P</I> et <I>Q</I> donc pour tout entier (ou entier de Gauss) <I>z</I>, <I>D</I> ( <I>z</I> ) divise <I>P</I>
( <I>z</I> ) et <I>Q</I> ( <I>z</I> ). Il existe donc une constante <I>a</I> telle que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I> = <I>a</I> <I>d</I> </TD></TR>
</TABLE><P>
On a aussi pp ( <I>G</I> ) divise <I>D</I>. Il existe donc un polynôme <I>C</I> tel
que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>D</I> = pp ( <I>G</I> ) <I>C</I> </TD></TR>
</TABLE><P>
Nous devons prouver que <I>C</I> est un polynôme constant. On suppose dans la suite
que ce n&#X2019;est pas le cas. Evaluons l&#X2019;égalité précédente au point <I>z</I>, on
obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>d</I> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>g</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>c</I> ( <I>G</I> )</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>C</I> ( <I>z</I> ) </TD></TR>
</TABLE><P>
Finalement
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">1 = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>c</I> ( <I>G</I> )</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>C</I> ( <I>z</I> ) </TD></TR>
</TABLE><P>
La procédure de construction de <I>G</I> nous donne une majoration de ces
coefficients par | <I>z</I> | / 2, donc de <I>c</I> ( <I>G</I> ) par | <I>z</I> | / 2, donc <I>C</I> ( <I>z</I>
) divise un entier de module plus petit que | <I>z</I> | / 2, donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>C</I> ( <I>z</I> ) | &#X2A7D; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">| <I>z</I> |</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
On considère maintenant les racines complexes <I>z</I><SUB>1</SUB>, &#X2026; ., <I>z</I><SUB><I>n</I></SUB> du polynôme
<I>C</I> (il en existe au moins une puisqu&#X2019;on a supposé <I>C</I> non constant). On a:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>C</I> ( <I>X</I> ) = <I>c</I><SUB><I>n</I></SUB> ( <I>X</I> &#X2212; <I>z</I><SUB>1</SUB> ) &#X2026; . ( <I>X</I> &#X2212; <I>z</I><SUB><I>n</I></SUB> ) </TD></TR>
</TABLE><P>
Donc, comme <I>c</I><SUB><I>n</I></SUB> est un entier (ou entier de Gauss) non nul, sa norme est
supérieure ou égale à 1 et :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>C</I> ( <I>z</I> ) | &#X2A7E; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> = 1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( | <I>z</I> | &#X2212; | <I>z</I><SUB><I>j</I></SUB> | ) </TD></TR>
</TABLE><P>
Il nous reste à majorer les racines de <I>C</I> pour minorer | <I>C</I> ( <I>z</I> ) |. Comme
<I>C</I> divise <I>D</I> il divise <I>P</I> et <I>Q</I> donc les racines de <I>C</I> sont des racines
communes à <I>P</I> et <I>Q</I>. On va appliquer le:</P><DIV CLASS="theorem"><B>Lemme 1</B>  <EM>
Soit x une racine complexe d&#X2019;un polynôme </EM><EM><I>P</I> = <I>a</I></EM><SUB><EM><I>n</I></EM></SUB><EM> <I>X</I></EM><SUP><EM><I>n</I></EM></SUP><EM> + &#X2026; . + <I>a</I></EM><SUB><EM>0</EM></SUB><EM>.</EM><P><EM>Alors 
</EM></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>| <I>x</I> | &lt; </EM><EM>| <I>P</I> |/| <I>a</I></EM><SUB><EM><I>n</I></EM></SUB><EM> |</EM><EM> + 1, | <I>P</I> | = </EM><EM>max</EM><SUB><EM>0 &#X2A7D; <I>i</I>
&#X2A7D; <I>n</I></EM></SUB><EM> ( | <I>a</I></EM><SUB><EM><I>i</I></EM></SUB><EM> | )</EM><EM> </EM></TD></TR>
</TABLE></DIV><P>Application du lemme à <I>C</I>(<I>X</I>) : on a 1/|<I>c</I><SUB><I>n</I></SUB>|&#X2264; 1
donc si on a choisi <I>z</I> tel que | <I>z</I> | &#X2A7E; 2 min( | <I>P</I> |, | <I>Q</I> | ) + 2,
alors pour tout <I>j</I>, | <I>z</I><SUB><I>j</I></SUB> | &lt; | <I>z</I> | / 2 donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>C</I> ( <I>z</I> ) | &gt; </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">| <I>z</I> |</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
qui contredit notre majoration de | <I>C</I> ( <I>z</I> ) |.</P><DIV CLASS="theorem"><B>Théorème 1</B>  <EM>
Soit </EM><EM><I>P</I></EM><EM> et Q deux polynômes à coefficients entiers. On
choisit un entier z tel que </EM><EM>| <I>z</I> | &#X2A7E; 2 </EM><EM>min</EM><EM>( | <I>P</I> |, | <I>Q</I> | ) + 2</EM><EM>,
si la partie primitive du polynôme </EM><EM><I>G</I></EM><EM> reconstruit à partir du pgcd de </EM><EM><I>P</I> (
<I>z</I> ) </EM><EM>et</EM><EM>Q(z) par écriture en base </EM><EM><I>z</I></EM><EM> (avec comme reste euclidien le
reste symétrique) divise </EM><EM><I>P</I></EM><EM> et </EM><EM><I>Q</I></EM><EM> alors c&#X2019;est le pgcd de </EM><EM><I>P</I></EM><EM> et </EM><EM><I>Q</I></EM><EM>.
</EM></DIV><P>Pour finir la démonstration du théorème, il nous faut encore montrer le lemme.
On a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X2212; <I>a</I><SUB><I>n</I></SUB> <I>x</I><SUP><I>n</I></SUP> = <I>a</I><SUB><I>n</I> &#X2212; 1</SUB> <I>x</I><SUP><I>n</I> &#X2212; 1</SUP> + &#X2026; . + <I>a</I><SUB>0</SUB> </TD></TR>
</TABLE><P>
Donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>a</I><SUB><I>n</I></SUB> | | <I>x</I> |<SUP><I>n</I></SUP> &#X2A7D; | <I>P</I> | ( 1 + &#X2026; . + | <I>x</I> |<SUP><I>n</I> &#X2212; 1</SUP> ) = | <I>P</I> |
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">| <I>x</I> |<SUP><I>n</I></SUP> &#X2212; 1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">| <I>x</I> | &#X2212; 1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Ici on peut supposer que | <I>x</I> | &#X2A7E; 1, sinon le lemme est démontré,
donc | <I>x</I> | &#X2212; 1 est positif et
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>a</I><SUB><I>n</I></SUB> | ( | <I>x</I> | &#X2212; 1 ) &#X2A7D; | <I>P</I> | </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">| <I>x</I> |<SUP><I>n</I></SUP> &#X2212; 1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">| <I>x</I> |<SUP><I>n</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
&#X21D2; | <I>x</I> | &#X2212; 1 &lt; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">| <I>P</I> |</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">| <I>a</I><SUB><I>n</I></SUB> |</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Remarques
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Le théorème publié par Char, Geddes et Gonnet 
porte sur des coefficients entiers et
c&#X2019;est comme cela qu&#X2019;il est utilisé par les systèmes de calcul formel (en
commençant historiquement par Maple). Peu de systèmes l&#X2019;utilisent pour les
polynômes à coefficients entiers de Gauss. On peut d&#X2019;ailleurs généraliser le
théorème à d&#X2019;autres types de coefficients, à condition d&#X2019;avoir un anneau
euclidien plongé dans &#X2102; avec une minoration sur la valeur absolue
des élements non nuls de l&#X2019;anneau.</LI><LI CLASS="li-itemize">Nous n&#X2019;avons jusqu&#X2019;à présent aucune certitude qu&#X2019;il existe des entiers
<I>z</I> tels que la partie primitive de <I>G</I> divise <I>P</I> et <I>Q</I>. Nous allons
montrer en utilisant l&#X2019;identité de Bézout que pour <I>z</I> assez grand c&#X2019;est
toujours le cas. Plus précisément, on sait qu&#X2019;il existe deux polynômes <I>U</I>
et <I>V</I> tels que
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I> <I>U</I> + <I>Q</I> <I>V</I> = <I>D</I> </TD></TR>
</TABLE>
Attention toutefois, <I>U</I> et <I>V</I> sont à coefficients rationnels, pour avoir
des coefficients entiers, on doit multiplier par une constante entière
&#X3B1;, donc en évaluant en <I>z</I> on obtient l&#X2019;existence d&#X2019;une égalité à
coefficients entiers
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I> ( <I>z</I> ) <I>u</I> + <I>Q</I> ( <I>z</I> ) <I>v</I> = &#X3B1; <I>D</I> ( <I>z</I> ) </TD></TR>
</TABLE><P>Donc le pgcd <I>g</I> de <I>P</I> ( <I>z</I> ) et <I>Q</I> ( <I>z</I> ) divise &#X3B1; <I>D</I> ( <I>z</I> ) = &#X3B1;
<I>d</I>. Comme <I>g</I> est un multiple de <I>d</I>, on en déduit que <I>g</I> = &#X3B2; <I>d</I>, où
&#X3B2; est un diviseur de &#X3B1;. Si on a choisi <I>z</I> tel que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>z</I> | &gt;  2 | <I>D</I> | | &#X3B1; | </TD></TR>
</TABLE><P>
alors | <I>z</I> | &gt; 2 | <I>D</I> | | &#X3B2; | donc l&#X2019;écriture symétrique en base <I>z</I> de
<I>g</I> est <I>G</I> = &#X3B2; <I>D</I>. Donc la partie primitive de <I>G</I> est <I>D</I>, le
pgcd de <I>P</I> et <I>Q</I>.</P></LI></UL><DIV CLASS="theorem"><B>Exemple 1</B>  <EM>
Si </EM><EM><I>P</I></EM><SUB><EM>0</EM></SUB><EM> = 6 ( <I>X</I></EM><SUP><EM>2</EM></SUP><EM> &#X2212; 1 )</EM><EM> et </EM><EM><I>Q</I></EM><SUB><EM>0</EM></SUB><EM> = 4 ( <I>X</I></EM><SUP><EM>3</EM></SUP><EM> &#X2212; 1 )</EM><EM>.</EM><P><EM>Le contenu de </EM><EM><I>P</I></EM><SUB><EM>0</EM></SUB><EM> est 6, celui de </EM><EM><I>Q</I></EM><SUB><EM>0</EM></SUB><EM> est 4.<BR>
 On a donc pgcd des contenus = 2, </EM><EM><I>P</I> = <I>X</I></EM><SUP><EM>2</EM></SUP><EM> &#X2212; 1, <I>Q</I> = <I>X</I></EM><SUP><EM>3</EM></SUP><EM> &#X2212; 1</EM><EM>. La valeur
initiale de </EM><EM><I>z</I></EM><EM> est donc </EM><EM>2 &#X2217; 1 + 2 = 4</EM><EM>. On trouve </EM><EM><I>P</I> ( 4 ) = 15, <I>Q</I> ( 4
) = 63</EM><EM>. Le pgcd entier de 15 et 63 est 3 que nous écrivons symétriquement
en base 4 sous la forme </EM><EM>3 = 1 &#X2217; 4 &#X2212; 1</EM><EM>, donc </EM><EM><I>G</I> = <I>X</I> &#X2212; 1</EM><EM>, sa partie
primitive est </EM><EM><I>X</I> &#X2212; 1</EM><EM>. On teste si </EM><EM><I>X</I> &#X2212; 1</EM><EM> divise </EM><EM><I>P</I></EM><EM> et </EM><EM><I>Q</I></EM><EM>, c&#X2019;est le cas,
donc c&#X2019;est le pgcd de </EM><EM><I>P</I></EM><EM> et </EM><EM><I>Q</I></EM><EM> et le pgcd de </EM><EM><I>P</I></EM><SUB><EM>0</EM></SUB><EM> et </EM><EM><I>Q</I></EM><SUB><EM>0</EM></SUB><EM> est </EM><EM>2 ( <I>X</I> &#X2212; 1
)</EM><EM>.
</EM></P></DIV><P><B>Algorithme gcdheu</B><BR>
En arguments deux polynômes <I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB> à coefficients entiers ou entiers
de Gauss. Retourne le pgcd de 
<I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB> ou faux en cas d&#X2019;échec.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Calculer le contenu de <I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB>. Vérifier que les coefficients
sont entiers de Gauss sinon retourner faux.</LI><LI CLASS="li-enumerate">Extraire la partie primitive <I>P</I> de <I>P</I><SUB>0</SUB> et <I>Q</I> de <I>Q</I><SUB>0</SUB>, calculer le
pgcd <I>c</I> des contenus de <I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB></LI><LI CLASS="li-enumerate">Déterminer <I>z</I> = 2 min( | <I>P</I> |, | <I>Q</I> | ) + 2.</LI><LI CLASS="li-enumerate">Début de boucle: initialisation du nombre d&#X2019;essais à 1, test d&#X2019;arrêt
sur un nombre maximal d&#X2019;essais, avec changement de <I>z</I> entre deux itérations
(par exemple <I>z</I> &#X2190; 2 <I>z</I>).</LI><LI CLASS="li-enumerate">Calculer le pgcd <I>g</I> de <I>P</I> ( <I>z</I> ) et <I>Q</I> ( <I>z</I> ) puis son écriture
symétrique en base <I>z</I> dont on extrait la partie primitive <I>G</I>.</LI><LI CLASS="li-enumerate">Si <I>G</I> ne divise pas<I>P</I> passer à l&#X2019;itération
suivante. De même pour <I>Q</I>.</LI><LI CLASS="li-enumerate">Retourner <I>c</I> <I>G</I></LI><LI CLASS="li-enumerate">Fin de la boucle</LI><LI CLASS="li-enumerate">Retourner faux.
</LI></OL><P>
On remarque au passage qu&#X2019;on a calculé le quotient de <I>P</I> par <I>G</I> et le
quotient de <I>Q</I> par <I>G</I> lorsque la procédure réussit. On peut donc passer à la
procédure gcdheu deux paramètres supplémentaires par référence, les deux
polynômes que l&#X2019;on affectera en cas de succès, ce qui optimise la
simplification d&#X2019;une fraction de 2 polynômes.</P><!--TOC subsubsection Le pgcd modulaire-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc19">4.2.2</A>  Le pgcd modulaire</H4><!--SEC END --><P>On part du fait que si <I>D</I> est le pgcd de <I>P</I> et <I>Q</I> dans &#X2124; (ou
&#X2124; [ <I>i</I> ] ) alors après réduction modulo un nombre premier <I>n</I> qui ne
divise pas les coefficients dominants de <I>P</I> et <I>Q</I>, <I>D</I> divise le pgcd <I>G</I> de
<I>P</I> et <I>Q</I> dans &#X2124; / <I>n</I> &#X2124; (par convention, le pgcd dans
&#X2124; / <I>n</I> &#X2124; est normalisé pour que son coefficient dominant
vaille 1). Comme on calcule <I>G</I> dans &#X2124; / <I>n</I> &#X2124;, les
coefficients des restes intermédiaires de l&#X2019;algorithme d&#X2019;Euclide sont bornés,
on évite ainsi la croissance exponentielle des coefficients. Il faudra ensuite
reconstruire <I>D</I> à partir de <I>G</I>.</P><P>On remarque d&#X2019;abord que si on trouve <I>G</I> = 1, alors <I>P</I> et <I>Q</I> sont premiers
entre eux. En général, on peut seulement dire que le degré de <I>G</I> est
supérieur ou égal au degré de <I>D</I>. En fait, le degré de <I>G</I> est égal au degré
de <I>D</I> lorsque les restes de l&#X2019;algorithme d&#X2019;Euclide (calculé en effectuant des
pseudo-divisions, cf. l&#X2019;exercice 1) ont leur coefficient dominant non
divisible par <I>n</I>. Donc plus <I>n</I> est grand, plus la probabilité est grande de
trouver <I>G</I> du bon degré.</P><P>Dans la suite, nous allons déterminer une borne <I>b</I> à priori majorant 
les coefficients de
<I>D</I>. On utilisera ensuite la même méthode que dans l&#X2019;algorithme modulaire de
recherche de racines évidentes: on multiplie <I>G</I> dans &#X2124; / <I>n</I>
&#X2124; par le pgcd dans &#X2124; des coefficients dominants <I>p</I> et
<I>q</I> de <I>P</I> et <I>Q</I>. Soit D = pgcd ( <I>p</I>, <I>q</I> ) <I>G</I> le résultat écrit
en représentation symétrique. Si <I>n</I> &#X2A7E; <I>b</I> pgcd ( <I>p</I>, <I>q</I> ) et si
<I>G</I> est du bon degré, on montre de la même manière que <I>D</I> = D. Comme 
on ne connait pas le degré de <I>D</I>, on est obligé de tester si D 
divise <I>P</I>
et <I>Q</I>. Si c&#X2019;est le cas, alors D divise <I>D</I> donc D = <I>D</I>
puisque degre ( D ) = degre ( <I>G</I> ) &#X2A7E;
degre ( <I>D</I> ). Sinon, <I>n</I> est un nombre premier malchanceux pour ce
calcul de pgcd (degre ( <I>G</I> ) &#X2A7E; degre ( <I>D</I> )), il faut
essayer un autre premier.</P><P><B>Remarque:</B> On serait tenté de dire que les coefficients de <I>D</I>
sont bornés par le plus grand coefficient de <I>P</I>. C&#X2019;est malheureusement faux,
par exemple ( <I>X</I> + 1 )<SUP>2</SUP> dont le plus grand coefficient est 2 divise ( <I>X</I> + 1
)<SUP>2</SUP> ( <I>X</I> &#X2212; 1 ) dont le plus grand coefficient (en valeur absolue) est 1.</P><P>Soit <I>P</I> = &#X2211;<I>p</I><SUB><I>i</I></SUB> <I>X</I><SUP><I>i</I></SUP> un polynôme à coefficients entiers. On utilise la
norme euclidienne
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
| <I>P</I> |<SUP>2</SUP> = <FONT SIZE=6>&#X2211;</FONT>| <I>p</I><SUB><I>i</I></SUB> |<SUP>2</SUP>
    (1)</TD></TR>
</TABLE><P>
On établit d&#X2019;abord une majoration du produit des racines de norme supérieure à
1 de <I>P</I> à l&#X2019;aide de | <I>P</I> |. Ensuite si <I>D</I> est un diviseur de <I>P</I>, le
coefficient dominant <I>d</I> de <I>D</I> divise le coefficient dominant <I>p</I> de <I>P</I> et 
les racines de <I>D</I> sont aussi des racines de <I>P</I>. On pourra donc déterminer une
majoration des polynômes symétriques des racines de <I>D</I> et donc des
coefficients de <I>D</I>.</P><DIV CLASS="theorem"><B>Lemme 2</B>  <EM> </EM><A NAME="lemme:A"></A><EM>
Soit </EM><EM><I>A</I> = &#X2211;</EM><SUB><EM><I>j</I> = 0</EM></SUB><SUP><EM><I>a</I></EM></SUP><EM> <I>a</I></EM><SUB><EM><I>j</I></EM></SUB><EM> <I>X</I></EM><SUP><EM><I>j</I></EM></SUP><EM> un polynôme et </EM><EM>&#X3B1; &#X2208; &#X2102;</EM><EM>.
Alors
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>| ( <I>X</I> &#X2212; &#X3B1; ) <I>A</I> | = | ( </EM><EM><SPAN style="text-decoration:overline">&#X3B1;</SPAN></EM><EM> <I>X</I> &#X2212; 1 ) <I>A</I> |</EM><EM> </EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>Pour prouver le lemme <A HREF="#lemme:A">2</A>, on développe les produits de polynômes. 
On pose <I>a</I><SUB>&#X2212;1</SUB> = <I>a</I><SUB><I>a</I> + 1</SUB> = 0 et on note &#X211C; la partie réelle.
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| ( <I>X</I> &#X2212; &#X3B1; ) <I>A</I> |<SUP>2</SUP> = &#X2211;<SUB><I>j</I> = 0</SUB><SUP><I>a</I> + 1</SUP> | <I>a</I><SUB><I>j</I> &#X2212; 1</SUB> &#X2212; &#X3B1;
<I>a</I><SUB><I>j</I></SUB> |<SUP>2</SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I> + 1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> = 0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> | <I>a</I><SUB><I>j</I> &#X2212; 1</SUB> |<SUP>2</SUP> + | &#X3B1; |<SUP>2</SUP> | <I>a</I><SUB><I>j</I></SUB> |<SUP>2</SUP> &#X2212; 2
&#X211C; ( <I>a</I><SUB><I>j</I> &#X2212; 1</SUB> </TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X3B1;  <I>a</I><SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ) </TD></TR>
</TABLE><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| ( <SPAN style="text-decoration:overline">&#X3B1;</SPAN> <I>X</I> &#X2212; 1 ) <I>A</I> |<SUP>2</SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I> + 1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> = 0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> | 
</TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X3B1;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>j</I> &#X2212; 1</SUB>
&#X2212; <I>a</I><SUB><I>j</I></SUB> |<SUP>2</SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I> + 1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> = 0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> | &#X3B1; |<SUP>2</SUP> | <I>a</I><SUB><I>j</I> &#X2212; 1</SUB> |<SUP>2</SUP> + | <I>a</I><SUB><I>j</I></SUB> |<SUP>2</SUP> &#X2212;
2 &#X211C; ( </TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X3B1;</TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>a</I><SUB><I>j</I> &#X2212; 1</SUB>   </TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>a</I><SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ) </TD></TR>
</TABLE><P>
Les deux donnent bien le même résultat.</P><P>Soit <I>P</I> ( <I>X</I> ) = <I>p</I> &#X220F;( <I>X</I> &#X2212; &#X3B1;<SUB><I>j</I></SUB> ) la factorisation de <I>P</I> sur
&#X2102;. On introduit le polynôme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">P = <I>p</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> / | &#X3B1;<SUB><I>j</I></SUB> | &#X2A7E; 1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( <I>X</I> &#X2212; &#X3B1;<SUB><I>j</I></SUB> )
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> / | &#X3B1;<SUB><I>j</I></SUB> | &lt; 1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (  </TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X3B1;<SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>X</I> &#X2212; 1 ) </TD></TR>
</TABLE><P>
qui d&#X2019;après le lemme a la même norme que <I>P</I>. La norme de <I>P</I> majore donc le
coefficient constant de P  d&#X2019;où:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
<A NAME="mignotte"></A>  &#X220F;<SUB><I>j</I> / | &#X3B1;<SUB><I>j</I></SUB> | &#X2A7E; 1</SUB> | &#X3B1;<SUB><I>j</I></SUB> |
&#X2A7D; | <I>P</I> |/| <I>p</I> |
    (2)</TD></TR>
</TABLE><P>
On remarque que (<A HREF="#mignotte">2</A>) reste vraie si on considère les
racines &#X3B4;<SUB><I>j</I></SUB> de norme plus grande que 1 d&#X2019;un diviseur <I>D</I> de <I>P</I> puisque
le produit porte alors sur un sous-ensemble. On écrit maintenant l&#X2019;expression
des coefficients <I>d</I><SUB><I>j</I></SUB> de <I>D</I> à l&#X2019;aide des racines &#X3B4;<SUB><I>j</I></SUB> de <I>D</I>:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">| <I>d</I><SUB><I>m</I> &#X2212; <I>j</I></SUB> | = | <I>d</I> | </TD><TD CLASS="dcell">&#X23AA;<BR>
&#X23AA;<BR>
&#X23AA;<BR>
&#X23AA;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">choix de <I>j</I> racines
parmi les <I>m</I> racines de <I>D</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">     </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">&#X3B4;<SUB><I>k</I></SUB> &#X2208;
racines choisies</TD></TR>
</TABLE></TD><TD CLASS="dcell"> &#X3B4;<SUB><I>k</I></SUB> </TD><TD CLASS="dcell">&#X23AA;<BR>
&#X23AA;<BR>
&#X23AA;<BR>
&#X23AA;</TD></TR>
</TABLE><P>
Pour majorer | <I>d</I><SUB><I>m</I> &#X2212; <I>j</I></SUB> |, on commence par majorer | &#X3B4;<SUB><I>k</I></SUB> | par
&#X3B2;<SUB><I>k</I></SUB> = max( 1, | &#X3B4;<SUB><I>k</I></SUB> | ). On est donc ramené à majorer
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X3C3;<SUB><I>j</I>, <I>m</I></SUB> ( &#X3B2; ) = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">choix de <I>j</I> parmi <I>m</I>
valeurs &#X3B2;<SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">    </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">&#X3B2;<SUB><I>k</I></SUB> &#X2208; choix</TD></TR>
</TABLE></TD><TD CLASS="dcell"> &#X3B2;<SUB><I>k</I></SUB>  </TD></TR>
</TABLE><P>
avec pour hypothèse une majoration de <I>M</I> = &#X220F;<SUB><I>k</I> = 1</SUB><SUP><I>m</I></SUP> &#X3B2;<SUB><I>k</I></SUB> donnée par
la relation (<A HREF="#mignotte">2</A>). Pour cela, on cherche le maximum de &#X3C3;<SUB><I>j</I>,
<I>m</I></SUB> ( &#X3B2; ) sous les contraintes <I>M</I> fixé et &#X3B2;<SUB><I>k</I></SUB> &#X2A7E; 1.</P><P>On va montrer que le maximum ne peut être atteint que si l&#X2019;un des &#X3B2;<SUB><I>k</I></SUB> =
<I>M</I> (et tous les autres &#X3B2;<SUB><I>k</I></SUB> = 1 ). Sinon, quitte à réordonner supposons
que les &#X3B2;<SUB><I>k</I></SUB> sont classés par ordre croissant. On a donc &#X3B2;<SUB><I>m</I> &#X2212; 1</SUB>
&#X2260; 1, on pose &#X3B2;<SUB><I>k</I></SUB> = &#X3B2;<SUB><I>k</I></SUB> pour <I>k</I> &#X2A7D; <I>m</I> &#X2212; 2,
&#X3B2;<SUB><I>m</I> &#X2212; 1</SUB> = 1 et &#X3B2;<SUB><I>m</I></SUB> = &#X3B2;<SUB><I>m</I> &#X2212; 1</SUB> &#X3B2;<SUB><I>m</I></SUB>.
Comparons &#X3C3;<SUB><I>j</I>, <I>m</I></SUB> ( &#X3B2; ) et &#X3C3;<SUB><I>j</I>, nm</SUB> ( &#X3B2;
). Si le choix de <I>j</I> parmi <I>m</I> comporte <I>k</I> = <I>m</I> &#X2212; 1 et <I>k</I> = <I>m</I>, le produit
est inchangé. Sinon on a la somme de deux produits, l&#X2019;un contenant <I>k</I> = <I>m</I> &#X2212; 1
et l&#X2019;autre <I>k</I> = <I>m</I>. On compare donc <I>B</I> ( &#X3B2;<SUB><I>m</I> &#X2212; 1</SUB> + &#X3B2;<SUB><I>m</I></SUB> ) et <I>B</I> ( 1
+ &#X3B2;<SUB><I>m</I> &#X2212; 1</SUB> &#X3B2;<SUB><I>m</I></SUB> ) avec <I>B</I> = &#X220F;<SUB>&#X3B2;<SUB><I>k</I></SUB> &#X2208; reste du
choix</SUB> &#X3B2;<SUB><I>k</I></SUB>. Comme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">1 + &#X3B2;<SUB><I>m</I> &#X2212; 1</SUB> &#X3B2;<SUB><I>m</I></SUB> &#X2A7E; &#X3B2;<SUB><I>m</I> &#X2212; 1</SUB> + &#X3B2;<SUB><I>m</I></SUB> </TD></TR>
</TABLE><P>
puisque la différence est le produit (1&#X2212;&#X3B2;<SUB><I>m</I></SUB>)(1&#X2212;&#X3B2;<SUB><I>m</I>&#X2212;1</SUB>) de deux
nombres positifs, on arrive à la contradiction souhaitée.</P><P>Ensuite on décompose les choix de &#X3C3;<SUB><I>m</I>, <I>j</I></SUB> en ceux contenant <I>M</I> et
des 1 et ceux ne contenant que des 1, d&#X2019;où la majoration
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X3C3;<SUB><I>j</I>, <I>m</I></SUB> ( &#X3B2; ) &#X2A7D; </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>     <I>m</I> &#X2212; 1</TD></TR>
<TR><TD ALIGN=center NOWRAP>     <I>j</I> &#X2212; 1</TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><I>M</I> + </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>     <I>m</I> &#X2212; 1</TD></TR>
<TR><TD ALIGN=center NOWRAP>     <I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
et finalement
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
| <I>d</I><SUB><I>m</I> &#X2212; <I>j</I></SUB> | &#X2A7D; | <I>d</I> | </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>    <I>m</I> &#X2212; 1</TD></TR>
<TR><TD ALIGN=center NOWRAP>    <I>j</I> &#X2212; 1</TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">| <I>P</I> |</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">| <I>p</I> |</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>    <I>m</I> &#X2212; 1</TD></TR>
<TR><TD ALIGN=center NOWRAP>    <I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><A NAME="pgcdd"></A>
    (3)</TD></TR>
</TABLE><P>
On peut en déduire une majoration indépendante de <I>j</I> sur les coefficients de
<I>D</I>, en majorant | <I>d</I> | par | <I>p</I> | (puisque <I>d</I> divise <I>p</I>) et les
coefficients binomiaux par 2<SUP><I>m</I> &#X2212; 1</SUP> (obtenue en développant ( 1 + 1 )<SUP><I>m</I> &#X2212;
1</SUP>). D&#X2019;où le</P><DIV CLASS="theorem"><B>Théorème 2</B>  <EM>
(Landau-Mignotte) Soit </EM><EM><I>P</I></EM><EM> un polynôme à coefficients entiers (ou entiers de
Gauss) et </EM><EM><I>D</I></EM><EM> un diviseur de </EM><EM><I>P</I></EM><EM> de degré </EM><EM><I>m</I></EM><EM>. Si </EM><EM>| <I>P</I> |</EM><EM> désigne la norme
euclidienne du vecteur des coefficients de </EM><EM><I>P</I></EM><EM> et </EM><EM><I>p</I></EM><EM> le coefficient
dominant de </EM><EM><I>P</I></EM><EM> alors les coefficients </EM><EM><I>d</I></EM><SUB><EM><I>j</I></EM></SUB><EM> de </EM><EM><I>D</I></EM><EM> satisfont l&#X2019;inégalité
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>
| <I>d</I></EM><SUB><EM><I>j</I></EM></SUB><EM> | &#X2A7D; 2</EM><SUP><EM><I>m</I> &#X2212; 1</EM></SUP><EM> ( | <I>P</I> | + | <I>p</I> | )
    (4)</EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>Avec cette estimation, on en déduit que si <I>n</I> est un premier plus grand que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
min( 2<SUP>degre ( <I>P</I> ) &#X2212; 1</SUP> ( | <I>P</I> | + | <I>p</I> | ),
2<SUP>degre ( <I>Q</I> ) &#X2212; 1</SUP> ( | <I>Q</I> | + | <I>q</I> | ) ), <A NAME="pgcdbound"></A>
    (5)</TD></TR>
</TABLE><P>
alors le pgcd trouvé dans &#X2124; / <I>n</I> &#X2124; va se reconstruire en un
pgcd dans &#X2124; si son degré est le bon.</P><P>Malheureusement la borne précédente est souvent très grande par rapport aux
coefficients du pgcd et calculer dans &#X2124; / <I>n</I> &#X2124; s&#X2019;avèrera
encore inefficace (surtout si le pgcd est 1). Cela reste vrai même si on
optimise un peu la majoration (<A HREF="#pgcdbound">5</A>) en repartant de (<A HREF="#pgcdd">3</A>).</P><P>L&#X2019;idée est donc de travailler modulo plusieurs nombres premiers plus petits et
reconstruire le pgcd des 2 polynômes à coefficients entiers à partir des pgcd
des polynômes dans &#X2124; / <I>n</I> &#X2124; et du
théorème des restes chinois. En pratique on prend des nombres premiers
inférieurs à la racine carrée du plus grand entier hardware de la machine
(donc plus petits que 2<SUP>16</SUP> sur une machine 32 bits) ce qui permet 
d&#X2019;utiliser l&#X2019;arithmétique hardware du processeur sans risque de débordement.</P><P><B>Algorithme du PGCD modulaire en 1 variable:</B></P><P>En argument: 2 polynômes primitifs <I>P</I> et <I>Q</I> à coefficients entiers. Le
résultat renvoyé sera le polynôme pgcd.</P><P>Variable auxiliaire: un entier <I>N</I> initialisé à 1 qui représente le produit
des nombres premiers utilisés jusqu&#X2019;ici et un polynôme <I>H</I> initialisé à 0 qui
représente le pgcd dans &#X2124; / <I>N</I> &#X2124;.</P><P>Boucle infinie :
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Chercher un nouveau nombre premier <I>n</I> qui ne divise pas les
coefficients dominants <I>p</I> et <I>q</I> de <I>P</I> et <I>Q</I></LI><LI CLASS="li-enumerate">Calculer le pgcd <I>G</I> de <I>P</I> et <I>Q</I> dans &#X2124; / <I>n</I> &#X2124;.
Si <I>G</I>=1, renvoyer 1.</LI><LI CLASS="li-enumerate">Si <I>H</I> = 0 ou si le degré de <I>G</I> est plus petit que le degré
de <I>H</I>, recopier <I>G</I> dans <I>H</I> et <I>n</I> dans <I>N</I>, passer à la 6ème étape</LI><LI CLASS="li-enumerate">Si le degré de <I>G</I> est plus grand que celui de <I>H</I> passer à
l&#X2019;itération suivante</LI><LI CLASS="li-enumerate">Si le degré de <I>G</I> est égal au degré de <I>H</I>, 
en utilisant le théorème des restes chinois, calculer un polynôme
H tel que H = <I>H</I> modulo <I>N</I> et H = <I>G</I> modulo
<I>n</I>. Recopier H dans <I>H</I> et <I>n</I> <I>N</I> dans <I>N</I>.</LI><LI CLASS="li-enumerate">Ecrire pgcd ( <I>p</I>, <I>q</I> ) <I>H</I> en représentation symétrique. Soit
H le résultat rendu primitif. Tester si H divise <I>P</I> et
<I>Q</I>. Si c&#X2019;est le cas, renvoyer H, sinon passer à l&#X2019;itération
suivante.
</LI></OL><P>
Finalement on n&#X2019;a pas utilisé <I>b</I>, la borne de Landau-Mignotte. 
On peut penser que l&#X2019;étape
6 ne devrait être effectuée que lorsque <I>N</I> est plus grand que pgcd (
<I>p</I>, <I>q</I> ) <I>b</I>. En pratique, on effectue le test de l&#X2019;étape 6 plus tôt parce que
les coefficients du pgcd sont rarement aussi grand que <I>b</I>. Mais pour éviter
de faire le test trop tôt, on introduit une variable auxiliaire <I>H</I>&#X2032; qui
contient la valeur de <I>H</I> de l&#X2019;itération précédente et on ne fait le test que
si <I>H</I>&#X2032; = <I>H</I> (ou bien sûr si on a dépassé la borne).</P><P><B>Remarque</B>:</P><P>L&#X2019;algorithme ci-dessus fonctionne également pour des polynômes à plusieurs
variables.</P><P><B>Exemple 1:</B></P><P>Calcul du pgcd de ( <I>X</I> + 1 )<SUP>3</SUP> ( <I>X</I> &#X2212; 1 )<SUP>4</SUP> et ( <I>X</I><SUP>4</SUP> &#X2212; 1 ). Prenons pour
commencer <I>n</I> = 2. On trouve comme pgcd <I>X</I><SUP>4</SUP> + 1 (en effet &#X2212; 1 = 1 donc on
cherchait le pgcd de ( <I>X</I> + 1 )<SUP>7</SUP> et de <I>X</I><SUP>4</SUP> + 1 = ( <I>X</I> + 1 )<SUP>4</SUP>). On teste si
<I>X</I><SUP>4</SUP> + 1 divise <I>P</I> et <I>Q</I>, ce n&#X2019;est pas le cas donc on passe au nombre
premier suivant. Pour <I>n</I> = 3, on trouve <I>X</I><SUP>2</SUP> &#X2212; 1. Donc <I>n</I> = 2 n&#X2019;était pas un
bon nombre premier pour ce calcul de pgcd puisqu&#X2019;on a trouvé un pgcd de degré
plus petit. On teste si <I>X</I><SUP>2</SUP> &#X2212; 1 divise <I>P</I> et <I>Q</I>, c&#X2019;est le cas ici donc on
peut arrêter, le pgcd cherché est <I>X</I><SUP>2</SUP>&#X2212;1.</P><P><B>Exemple</B><B> 2 :</B></P><P>Calcul du pgcd de ( <I>X</I> + 1 )<SUP>3</SUP> ( <I>X</I> &#X2212; 1 )<SUP>4</SUP> et ( <I>X</I><SUP>4</SUP> &#X2212; 1 )<SUP>3</SUP>. 
Pour <I>n</I> = 2, on trouve un polynôme de degré 7.
Pour <I>n</I> = 3, on trouve <I>X</I><SUP>6</SUP> &#X2212; 1 donc <I>n</I> = 2 était une mauvaise réduction.
Comme <I>X</I><SUP>6</SUP> &#X2212; 1 ne divise pas <I>P</I> et <I>Q</I>, on passe à <I>n</I> = 5. On trouve <I>X</I><SUP>6</SUP> +
2 <I>X</I><SUP>4</SUP> &#X2212; 2 <I>X</I><SUP>2</SUP> &#X2212; 1. On applique le théorème des restes chinois qui va nous
donner un polynôme dans &#X2124; / 15 &#X2124;. On cherche donc un
entier congru à 2 modulo 5 et à 0 modulo 3, -3 est la solution (écrite en
représentation symétrique), donc le polynôme modulo 15 est <I>X</I><SUP>6</SUP> &#X2212; 3 <I>X</I><SUP>4</SUP> + 3
<I>X</I><SUP>2</SUP> &#X2212; 1 = ( <I>X</I><SUP>2</SUP> &#X2212; 1 )<SUP>3</SUP>. Ce polynôme divise <I>P</I> et <I>Q</I>, c&#X2019;est donc le pgcd de
<I>P</I> et de <I>Q</I>.</P><!--TOC subsection Le pgcd à plusieurs variables.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc20">4.3</A>  Le pgcd à plusieurs variables.</H3><!--SEC END --><!--TOC subsubsection Le pgcd heuristique.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc21">4.3.1</A>  Le pgcd heuristique.</H4><!--SEC END --><P>On suppose comme dans le cas à une variable que les polynômes sont primitifs,
donc qu&#X2019;on a simplifié les polynômes par le pgcd entier de leurs coefficients
entiers.</P><P>Le principe est identique à celui du PGCD à 1 variable, on évalue les deux
polynômes <I>P</I> et <I>Q</I> de <I>k</I> variables <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>k</I></SUB> en un <I>X</I><SUB><I>k</I></SUB> = <I>z</I> et
on calcule le pgcd <I>g</I> des 2 polynômes <I>P</I> ( <I>z</I> ) et <I>Q</I> ( <I>z</I> ) de <I>k</I> &#X2212; 1
variables. On remonte ensuite à un polynôme <I>G</I> par écriture symétrique en
base <I>z</I> de <I>g</I> et on teste si pp ( <I>G</I> ) divise <I>P</I> et <I>Q</I>. Il s&#X2019;agit
à nouveau de montrer que si <I>z</I> est assez grand, alors pp ( <I>G</I> ) est
le pgcd cherché. On sait que <I>d</I> = <I>D</I> ( <I>z</I> ) divise <I>g</I>. Il existe donc un
polynôme <I>a</I> de <I>k</I> &#X2212; 1 variables tel que <I>g</I> = <I>a</I> <I>d</I>. On sait aussi que
pp ( <I>G</I> ) divise <I>D</I>, donc il existe un polynôme <I>C</I> de <I>k</I> variables
tel que <I>D</I> = <I>C</I> &#X2217; pp ( <I>G</I> ) . On évalue en <I>z</I> et on obtient <I>d</I> = <I>C</I> (
<I>z</I> ) <I>g</I> / <I>c</I> ( <I>G</I> ), où <I>c</I> ( <I>G</I> ) est un entier, donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>c</I> ( <I>G</I> ) = <I>a</I> &#X2217; <I>C</I> ( <I>z</I> ) </TD></TR>
</TABLE><P>
Comme <I>c</I> ( <I>G</I> ) est un entier, <I>a</I> et <I>C</I> ( <I>z</I> ) sont des polynômes constants.
Comme précédemment, on a aussi | <I>C</I> ( <I>z</I> ) | &#X2A7D; | <I>z</I> | / 2 puisque | <I>c</I>
( <I>G</I> ) | &#X2A7D; | <I>z</I> | / 2.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Premier cas: si <I>C</I> ne dépend que de la variable <I>X</I><SUB><I>k</I></SUB>. On continue le
raisonnement comme dans le cas unidimensionnel.</LI><LI CLASS="li-itemize">Deuxième cas: si <I>C</I> dépend d&#X2019;une autre variable, par exemple <I>X</I><SUB>1</SUB>.
On regarde le coefficient de plus haut degre de <I>C</I> par rapport a <I>X</I><SUB>1</SUB>. Ce
coefficient divise le coefficient de plus haut degre de <I>P</I> et de <I>Q</I> par
rapport a <I>X</I><SUB>1</SUB>. Comme <I>C</I> ( <I>z</I> ) est constant, on en deduit que le
coefficient de plus haut degre de <I>P</I> et <I>Q</I> par rapport a <I>X</I><SUB>1</SUB> est
divisible par <I>X</I><SUB><I>k</I></SUB> &#X2212; <I>z</I> donc le coefficient de plus bas degre en <I>X</I><SUB><I>k</I></SUB> de
ces coefficients de plus haut degre est divisible par <I>z</I>, ce qui contredit
la majoration de ce coefficient.
</LI></UL><P>En pratique, cet algorithme nécessite le calcul récursif de pgcd sans
garantie de réussite. On l&#X2019;évite donc s&#X2019;il y a beaucoup de variables (la
limite est par exemple de 5 pour MuPAD).</P><!--TOC subsubsection Le pgcd modulaire multivariables.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc22">4.3.2</A>  Le pgcd modulaire multivariables.</H4><!--SEC END --><P>Ici, on travaille modulo <I>X</I><SUB><I>n</I></SUB> &#X2212; &#X3B1;, où <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I></SUB> désignent
les variables des polynômes. On considère donc deux polynômes <I>P</I> et <I>Q</I> comme
polynômes de la variables <I>X</I><SUB><I>n</I></SUB> avec des coefficients dans &#X2124; [ <I>X</I><SUB>1</SUB>,
&#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB> ]. On évalue en <I>X</I><SUB><I>n</I></SUB> = &#X3B1;, on obtient deux polynômes
en <I>n</I> &#X2212; 1 variables dont on calcule le pgcd (récursivement).</P><P>Il s&#X2019;agit de reconstruire le pgcd par interpolation. Tout d&#X2019;abord, on a une 
borne évidente sur le degré du pgcd par rapport à la variable <I>X</I><SUB><I>n</I></SUB>, c&#X2019;est le
minimum &#X3B4; des degrés par rapport à <I>X</I><SUB><I>n</I></SUB> des polynômes <I>P</I> et <I>Q</I>. A
première vue, il suffit donc d&#X2019;évaluer les polynômes
en &#X3B4; + 1 points &#X3B1;.</P><P>Il faut toutefois prendre garde aux mauvaises évaluations et à la
normalisation des pgcd avant d&#X2019;interpoler. En effet, si <I>D</I> ( <I>X</I><SUB>1</SUB>, &#X2026; .,
<I>X</I><SUB><I>n</I></SUB> ) désigne le pgcd de <I>P</I> et <I>Q</I> et <I>G</I> ( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB> ) le
pgcd de <I>P</I> ( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB>, &#X3B1; ) et de <I>Q</I> ( <I>X</I><SUB>1</SUB>, &#X2026; .,
<I>X</I><SUB><I>n</I> &#X2212; 1</SUB>, &#X3B1; ), 
on peut seulement dire <I>D</I> ( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB>, &#X3B1; )
divise <I>G</I>. Plusieurs cas sont donc possibles lorsqu&#X2019;on évalue en un nouveau
point &#X3B1;:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
l&#X2019;un des degrés de <I>G</I> est plus petit que le degré du polynôme <I>D</I>&#X2032;
reconstruit par interpolation jusque là. Dans ce cas, toutes les évaluations
qui ont conduit à reconstruire <I>D</I>&#X2032; étaient mauvaises. Il faut recommencer
l&#X2019;interpolation à zéro ou à partir de <I>G</I> (si tous les degrés de <I>G</I> sont
inférieurs ou égaux aux degrés du <I>D</I>&#X2032; reconstruit).</LI><LI CLASS="li-itemize">l&#X2019;un des degrés de <I>G</I> est plus grand que le degré du <I>D</I>&#X2032; reconstruit
jusque là. Il faut alors ignorer &#X3B1;.</LI><LI CLASS="li-itemize">Tous les degrés de <I>G</I> sont égaux aux degrés du <I>D</I>&#X2032; reconstruit
jusque là. Dans ce cas, <I>G</I> est un multiple entier du polynôme <I>D</I>&#X2032;
reconstruit jusque là et évalué en <I>X</I><SUB><I>n</I></SUB> = &#X3B1;. Si on suppose qu&#X2019;on a pu
s&#X2019;arranger pour que ce multiple soit 1, on ajoute le point &#X3B1; aux
points d&#X2019;évaluation précédents &#X3B1;<SUB><I>j</I></SUB> en posant:
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>D</I>&#X2032; = <I>D</I>&#X2032; + ( <I>G</I> &#X2212; <I>D</I>&#X2032; ) </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">&#X3B1;<SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( <I>X</I><SUB><I>n</I></SUB> &#X2212; &#X3B1;<SUB><I>j</I></SUB>
)</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">&#X3B1;<SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( &#X3B1; &#X2212; &#X3B1;<SUB><I>j</I></SUB> )</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE>
</LI></UL><P>
On voit que les mauvaises évaluations se détectent simplement par les degrés.
Pour la normalisation, on utilise une petite astuce: au lieu de reconstruire
le pgcd <I>D</I>, on va reconstruire un multiple du pgcd <I>D</I> (ce
multiple appartiendra à &#X2124; [ <I>X</I><SUB><I>n</I></SUB> ] ). On voit maintenant <I>P</I> et <I>Q</I>
comme des polynômes en <I>n</I> &#X2212; 1 variables <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB> à
coefficients dans &#X2124; [ <I>X</I><SUB><I>n</I></SUB> ]. Alors lcoeff(<I>D</I>), 
le coefficient dominant de <I>D</I>
(relativement à l&#X2019;ordre lexicographique sur les variables <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB>),
est un polynôme en <I>X</I><SUB><I>n</I></SUB> qui divise le coefficient dominant de <I>P</I> et de <I>Q</I>
donc divise le coefficient dominant du pgcd des coefficients dominants de <I>P</I>
et de <I>Q</I>. On va donc reconstruire le polynôme :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>D</I>&#X2032; = <I>D</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X394; ( <I>X</I><SUB><I>n</I></SUB> )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">lcoeff ( <I>D</I> ) ( <I>X</I><SUB><I>n</I></SUB> )</TD></TR>
</TABLE></TD><TD CLASS="dcell">, &#X394; ( <I>X</I><SUB><I>n</I></SUB> ) =
pgcd ( lcoeff ( <I>P</I> ) ( <I>X</I><SUB><I>n</I></SUB> ), lcoeff ( <I>Q</I> ) ( <I>X</I><SUB><I>n</I></SUB> )) </TD></TR>
</TABLE><P>
c&#X2019;est-à-dire <I>D</I> multiplié par un polynôme qui ne dépend que de <I>X</I><SUB><I>n</I></SUB>.</P><P>Revenons à <I>G</I> en un point &#X3B1; de bonne évaluation. C&#X2019;est un multiple
entier de <I>D</I> ( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB>, &#X3B1; ):
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>G</I> = &#X3B2; <I>D</I> ( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB>, &#X3B1; ) </TD></TR>
</TABLE><P>
Donc, comme polynômes de <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB> à coefficients dans 
&#X2124;[<I>X</I><SUB><I>n</I></SUB>] ou dans &#X2124;,
lcoeff ( <I>G</I> ) = &#X3B2; lcoeff ( <I>D</I> )<SUB>| <I>X</I><SUB><I>n</I></SUB> = &#X3B1;</SUB>. Comme
lcoeff ( <I>D</I> ) divise &#X394; ( <I>X</I><SUB><I>n</I></SUB> ), il en est de même en <I>X</I><SUB><I>n</I></SUB> =
&#X3B1; donc lcoeff(<I>G</I>) divise &#X3B2; &#X394;(&#X3B1;). 
On en déduit que  &#X394; ( &#X3B1;) <I>G</I> qui 
est divisible par  &#X394; (&#X3B1;) &#X3B2; est
divisible par lcoeff ( <I>G</I> ). On va donc considérer le polynôme
 &#X394; (&#X3B1;) <I>G</I> / lcoeff ( <I>G</I> ) :
ses coefficients sont entiers et son coefficient dominant est 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X394; ( &#X3B1;) = lcoeff(<I>D</I>&#X2032;( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB>, &#X3B1; ))</TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X394; (&#X3B1;) <I>G</I>  / lcoeff ( <I>G</I> )=
<I>D</I>&#X2032;( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB>, &#X3B1; )</TD></TR>
</TABLE><P><B>Algorithme du pgcd modulaire à plusieurs variables (interpolation
dense)</B>:</P><P>Arguments: 2 polynômes primitifs <I>P</I> et <I>Q</I> de <I>n</I> variables <I>X</I><SUB>1</SUB>, &#X2026; .,
<I>X</I><SUB><I>n</I></SUB> à coefficients entiers. Renvoie le pgcd de <I>P</I> et <I>Q</I>.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Si <I>n</I> = 1, renvoyer le pgcd de <I>P</I> et <I>Q</I> en une variable.</LI><LI CLASS="li-enumerate">Test rapide de pgcd trivial par rapport à <I>X</I><SUB><I>n</I></SUB>. On cherche des <I>n</I> &#X2212;
1-uplets &#X3B1; tels que <I>P</I> ( &#X3B1;, <I>X</I><SUB><I>n</I></SUB> ) et <I>Q</I> ( &#X3B1;, <I>X</I><SUB><I>n</I></SUB> )
soient de même degré que <I>P</I> et <I>Q</I> par rapport à la variable <I>X</I><SUB><I>n</I></SUB>. On
calcule le pgcd <I>G</I> de ces 2 polynômes en une variable. Si le pgcd est
constant, alors on retourne le pgcd des coefficients de <I>P</I> et <I>Q</I>.</LI><LI CLASS="li-enumerate">On divise <I>P</I> et <I>Q</I> par leur contenu respectifs vu comme polynômes en
<I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB> à coefficients dans &#X2124; [ <I>X</I><SUB><I>n</I></SUB> ], on note
<I>C</I> ( <I>X</I><SUB><I>n</I></SUB> ) le pgcd des contenus. On calcule aussi le pgcd &#X394; ( <I>X</I><SUB><I>n</I></SUB> )
des coefficients dominants de <I>P</I> et de <I>Q</I>.</LI><LI CLASS="li-enumerate">On initialise <I>D</I>&#X2032; le pgcd reconstruit à 0, <I>I</I> ( <I>X</I><SUB><I>n</I></SUB> ) le polynôme
d&#X2019;interpolation à 1, &#X3B4;=(&#X3B4;<SUB>1</SUB>,...,&#X3B4;<SUB><I>n</I>&#X2212;1</SUB>) 
la liste des degrés partiels du pgcd par
rapport à <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB> au minimum des degrés partiels de <I>P</I>
et <I>Q</I> par rapport à <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB>, <I>e</I> le nombre d&#X2019;évaluation
à 0 et <I>E</I> l&#X2019;ensemble des points d&#X2019;interpolation à la liste vide.</LI><LI CLASS="li-enumerate">Boucle infinie:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Faire &#X3B1;=entier aléatoire n&#X2019;appartenant pas à <I>E</I> jusqu&#X2019;à ce
que
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>      degre(<I>P</I> ( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB>, &#X3B1;
))=degre<SUB><I>X</I><SUB><I>n</I></SUB></SUB> ( <I>P</I> ( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I></SUB> )</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>      degre ( <I>Q</I> ( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB>, &#X3B1; )) =
degre<SUB><I>X</I><SUB><I>n</I></SUB></SUB> ( <I>Q</I> ( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I></SUB> ))</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>    </TD></TR>
</TABLE></TD></TR>
</TABLE>
</LI><LI CLASS="li-itemize">Calculer le pgcd <I>G</I> ( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB> ) en <I>n</I> &#X2212; 1
variables de <I>P</I> ( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB>, &#X3B1; ) et <I>Q</I> ( <I>X</I><SUB>1</SUB>, &#X2026;
., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB>, &#X3B1; ).</LI><LI CLASS="li-itemize">Si degre ( <I>G</I> )<SUB><I>i</I></SUB> &lt; &#X3B4;<SUB><I>i</I></SUB> pour un indice au moins.
Si degre ( <I>G</I> ) &#X2A7D; &#X3B4;, on pose &#X3B4; =
degre ( <I>G</I> ), <I>D</I>&#X2032; = <I>G</I> &#X394; ( &#X3B1; )/lcoeff ( <I>G</I>
), <I>I</I> = <I>X</I><SUB><I>n</I></SUB> &#X2212; &#X3B1;, <I>e</I> = 1 et <I>E</I> = [ &#X3B1; ], sinon on pose &#X3B4;
= min( &#X3B4;, degre ( <I>G</I> )), <I>D</I>&#X2032; = 0, <I>I</I> = 1, <I>e</I> = 0, <I>E</I> = [ ].
On passe à l&#X2019;itération suivante.</LI><LI CLASS="li-itemize">Si degre ( <I>G</I> ) &gt; &#X3B4;, on passe à l&#X2019;itération suivante.</LI><LI CLASS="li-itemize">Si degre ( <I>G</I> ) = &#X3B4;, on interpole:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<I>G</I> := <I>G</I> &#X394; ( &#X3B1; )/lcoeff ( <I>G</I> )</LI><LI CLASS="li-itemize"><I>D</I>&#X2032; := <I>D</I>&#X2032; + <I>I</I> ( <I>X</I><SUB><I>n</I></SUB> )/&#X220F;<SUB>&#X3B1;<SUB><I>j</I></SUB> &#X2208; <I>E</I></SUB> ( &#X3B1; &#X2212;
&#X3B1;<SUB><I>j</I></SUB> ) ( <I>G</I> &#X2212; <I>D</I>&#X2032; ( <I>X</I><SUB>1</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I> &#X2212; 1</SUB>, &#X3B1; ))</LI><LI CLASS="li-itemize"><I>I</I> := <I>I</I> &#X2217; ( <I>X</I><SUB><I>n</I></SUB> &#X2212; &#X3B1; )</LI><LI CLASS="li-itemize"><I>e</I> := <I>e</I> + 1 et ajouter &#X3B1; à <I>E</I></LI><LI CLASS="li-itemize">Si <I>e</I> est strictement plus grand que le minimum des degrés
partiels de <I>P</I> et <I>Q</I> par rapport à <I>X</I><SUB><I>n</I></SUB>, on pose D la
partie primitive de <I>D</I>&#X2032; (vu comme polynôme à coefficients dans
&#X2124; [ <I>X</I><SUB><I>n</I></SUB> ]), on teste si <I>P</I> et <I>Q</I> sont divisibles par
D, si c&#X2019;est le cas, on renvoie <I>D</I> = <I>C</I> ( <I>X</I><SUB><I>n</I></SUB> ) D
</LI></UL>
</LI></UL>
</LI></OL><P>
On observe que dans cet algorithme, on fait le test de divisibilite de
D par <I>P</I> et <I>Q</I>. En effet, même après avoir évalué en suffisamment
de points, rien n&#X2019;indique que tous ces points sont des points de bonne
évaluation. En pratique cela reste extrêmement improbable. En pratique, on
teste la divisibilité plus tôt, dès que <I>D</I>&#X2032; n&#X2019;est pas modifié par l&#X2019;ajout
d&#X2019;un nouveau point à la liste des &#X3B1;<SUB><I>j</I></SUB>.</P><P>Il existe une variation de cet algorithme, appelé SPMOD (sparse modular), qui
suppose que seuls les coefficients non nuls du pgcd en <I>n</I> &#X2212; 1 variables sont
encore non nuls en <I>n</I> variables (ce qui a de fortes chances d&#X2019;être le cas).
L&#X2019;étape d&#X2019;interpolation est alors remplacée par la résolution d&#X2019;un
sous-système d&#X2019;un système de Vandermonde. Cette variation est intéressante si
le nombre de coefficients non nuls en <I>n</I> &#X2212; 1 variables est petit devant le
degré. Si elle échoue, on revient à l&#X2019;interpolation dense.</P><P>Notons enfin qu&#X2019;on peut appliquer cette méthode lorsque les coefficients de
<I>P</I> et <I>Q</I> sont dans &#X2124; / <I>n</I> &#X2124; mais il faut alors vérifier
qu&#X2019;on dispose de suffisamment de points d&#X2019;interpolation. Ce qui en combinant
avec l&#X2019;algorithme modulaire à une variable donne un algorithme doublement
modulaire pour calculer le pgcd de 2 polynômes à coefficients entiers. C&#X2019;est
cette méthode qu&#X2019;utilise par exemple MuPAD (en essayant d&#X2019;abord SPMOD puis
l&#X2019;interpolation dense).</P><P><B>Exemple:</B></P><P>Dans cet exemple, on donne <I>F</I> et <I>G</I> sous forme factorisée, le but étant de
faire comprendre l&#X2019;algorithme. En utilisation normale, on n&#X2019;exécuterait cet
algorithme que si <I>F</I> et <I>G</I> étaient développés.</P><P><I>P</I> = (( <I>x</I> + 1 ) <I>y</I> + <I>x</I><SUP>2</SUP> + 1 ) ( <I>y</I><SUP>2</SUP> + <I>x</I> <I>y</I> + 1 ), <I>Q</I> = (( <I>x</I> + 1 ) <I>y</I> +
<I>x</I><SUP>2</SUP> + 1 ) ( <I>y</I><SUP>2</SUP> &#X2212; <I>x</I> <I>y</I> &#X2212; 1 ).</P><P>Prenons <I>x</I> comme variable <I>X</I><SUB>1</SUB> et <I>y</I> comme variable <I>X</I><SUB>2</SUB>. Les coefficients
dominants de <I>P</I> et <I>Q</I> sont respectivement <I>y</I> et &#X2212; <I>y</I> donc &#X394; = <I>y</I>.</P><P>En <I>y</I> = 0, <I>P</I> ( <I>x</I>, 0 ) = <I>x</I><SUP>2</SUP> + 1 n&#X2019;est pas du bon degré.</P><P>En <I>y</I> = 1, <I>P</I> ( <I>x</I>, 1 ) = ( <I>x</I> + <I>x</I><SUP>2</SUP> + 2 ) ( <I>x</I> + 2 ) et <I>Q</I> ( <I>x</I>, 1 ) = ( <I>x</I> +
<I>x</I><SUP>2</SUP> + 2 ) ( &#X2212; <I>x</I> ) sont du bon degré. Leur pgcd est <I>G</I> = <I>x</I><SUP>2</SUP> + <I>x</I> + 2, &#X394;
( 1 ) = 1, donc <I>D</I>&#X2032; = <I>x</I><SUP>2</SUP> + <I>x</I> + 1. On teste la divisibilité de <I>P</I> par <I>D</I>&#X2032;,
le teste échoue.</P><P>En <I>y</I> = 2, <I>P</I> ( <I>x</I>, 2 ) = ( <I>x</I><SUP>2</SUP> + 2 <I>x</I> + 3 ) ( 2 <I>x</I> + 5 ) et <I>Q</I> ( <I>x</I>, 2 ) = (
<I>x</I><SUP>2</SUP> + 2 <I>x</I> + 3 ) ( &#X2212; 2 <I>x</I> + 3 ) donc <I>G</I> = <I>x</I><SUP>2</SUP> + 2 <I>x</I> + 3, &#X394; ( 2 ) = 2.
On interpole:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>D</I>&#X2032; = <I>x</I><SUP>2</SUP> + <I>x</I> + 2 + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I> &#X2212; 1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2 &#X2212; 1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( 2 ( <I>x</I><SUP>2</SUP> + 2 <I>x</I> + 3 ) &#X2212; ( <I>x</I><SUP>2</SUP> + <I>x</I> +
2 )) = <I>y</I> ( <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) &#X2212; ( 2 <I>x</I> + 2 ) </TD></TR>
</TABLE><P>
On teste la divisibilité de <I>P</I> par <I>D</I>&#X2032;, le test échoue.</P><P>En <I>y</I> = 3, <I>P</I> ( <I>x</I>, 3 ) = ( <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) ( 3 <I>x</I> + 10 ) et <I>Q</I> ( <I>x</I>, 3 ) = (
<I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) ( &#X2212; 3 <I>x</I> + 8 ) donc <I>G</I> = <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4, &#X394; ( 3 ) = 3.
On interpole:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>  <I>D</I>&#X2032;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>y</I> ( <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) &#X2212; ( 2 <I>x</I> + 2 ) + </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">( <I>y</I> &#X2212; 2 ) ( <I>y</I> &#X2212; 1 )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">( 3 &#X2212; 2
) ( 3 &#X2212; 1 )</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239D;</TD><TD CLASS="dcell">3 ( <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) &#X2212; ( 3 ( <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) &#X2212; ( 2 <I>x</I> + 2
)) </TD><TD CLASS="dcell">&#X239E;<BR>
&#X23A0;</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>D</I>&#X2032; = <I>y</I> ( <I>x</I><SUP>2</SUP> + 3 <I>x</I> + 4 ) &#X2212; ( 2 <I>x</I> + 2 ) + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">( <I>y</I> &#X2212; 2 ) ( <I>y</I> &#X2212; 1 )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> ( &#X2212;
2 <I>x</I> &#X2212; 2 ) = <I>x</I><SUP>2</SUP> <I>y</I> + <I>x</I> <I>y</I><SUP>2</SUP> + <I>y</I><SUP>2</SUP> + <I>y</I> </TD></TR>
</TABLE><P>
On divise <I>D</I>&#X2032; par son contenu et on trouve <I>x</I><SUP>2</SUP> + <I>x</I> <I>y</I> + <I>y</I> + 1 qui est bien
le pgcd de <I>P</I> et <I>Q</I>.</P><!--TOC subsubsection EZGCD.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc23">4.3.3</A>  EZGCD.</H4><!--SEC END --><P>Il s&#X2019;agit d&#X2019;une méthode <I>p</I>-adique. On évalue toutes les variables sauf une,
on calcule le pgcd en une variable et on remonte au pgcd variable par variable
(EEZGCD) ou toutes les variables simultanément (EZGCD) par un lemme de Hensel.
Il semble qu&#X2019;il est plus efficace de remonter les variables séparément.</P><P>Soit donc <I>F</I> et <I>G</I> deux polynômes primitifs dépendant des variables <I>X</I><SUB>1</SUB>,
&#X2026;, <I>X</I><SUB><I>n</I></SUB> de pgcd <I>D</I>, on fixe une des variables qu&#X2019;on appelera <I>X</I><SUB>1</SUB> dans
la suite. Soient lcoeff ( <I>F</I> ) et lcoeff ( <I>G</I> ) les
coefficients dominants de <I>F</I> et <I>G</I> par rapport à <I>X</I><SUB>1</SUB>. On évalue <I>F</I> et <I>G</I>
en un <I>n</I> &#X2212; 1 uplet <I>b</I> tel que le degré de <I>F</I> et <I>G</I> par rapport à <I>X</I><SUB>1</SUB>
soit conservé après evaluation en <I>b</I>. On suppose que <I>D</I><SUB><I>b</I></SUB> ( <I>X</I><SUB>1</SUB> ) =
pgcd ( <I>F</I> ( <I>b</I> ), <I>G</I> ( <I>b</I> )) a le même degré que <I>D</I> ( <I>b</I> ). On a donc
l&#X2019;égalité:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">( <I>F</I> &#X2217; lcoeff ( <I>F</I> )) ( <I>b</I> ) = </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><I>D</I><SUB><I>b</I></SUB>  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">lcoeff ( <I>F</I> (
<I>b</I> ))</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">lcoeff ( <I>D</I><SUB><I>b</I></SUB> )</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">&#X2217; </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>F</I> ( <I>b</I> )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUB><I>b</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">lcoeff ( <I>F</I> ) ( <I>b</I> )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">lcoeff ( </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>F</I> ( <I>b</I> )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUB><I>b</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> )</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
et de même en remplaçant <I>F</I> par <I>G</I>.</P><P>Pour pouvoir lifter cette égalité (c&#X2019;est-à-dire généraliser à plusieurs 
variables), il faut que <I>D</I><SUB><I>b</I></SUB> et <I>F</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB>
soient premiers entre eux. Sinon, on peut essayer de lifter l&#X2019;égalité analogue
avec <I>G</I>. En général, on montre qu&#X2019;il existe un entier <I>j</I> tel que <I>D</I><SUB><I>b</I></SUB> et
<I>F</I> ( <I>b</I> ) + <I>j</I> <I>G</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB> soient premiers entre eux. En effet, sinon
au moins un des facteurs irréductibles de <I>D</I><SUB><I>b</I></SUB> va diviser <I>F</I> ( <I>b</I> ) + <I>j</I>
<I>G</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB> pour deux valeurs distinctes de <I>j</I> et va donc diviser à la
fois <I>F</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB> et <I>G</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB> en contradiction avec la
définition de <I>D</I><SUB><I>b</I></SUB> = pgcd ( <I>F</I> ( <I>b</I> ), <I>G</I> ( <I>b</I> )). On lifte alors
l&#X2019;égalité obtenue en remplaçant <I>F</I> par ( <I>F</I> + <I>k</I> <I>G</I> ) ci-dessus. Dans la
suite, on suppose qu&#X2019;on peut prendre <I>j</I> = 0 pour alléger les notations.</P><P>On va aussi supposer que <I>b</I> = 0. Sinon, on fait un changement d&#X2019;origine sur
les polynômes <I>F</I> et <I>G</I> pour que <I>b</I> = 0 convienne, on calcule le pgcd et on
lui applique la translation d&#X2019;origine opposée.</P><P>On adopte ensuite la notation suivante: si <I>k</I> est un entier, on dit qu&#X2019;un
polynôme <I>P</I> est un <I>O</I> ( <I>k</I> ) si la valuation de <I>P</I> vu comme polynôme en
<I>X</I><SUB>2</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I></SUB> à coefficients dans &#X2124; [ <I>X</I><SUB>1</SUB> ] est supérieure
ou égale à <I>k</I>, ou de manière équivalente si
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I> ( <I>X</I><SUB>1</SUB>, <I>h</I> <I>X</I><SUB>2</SUB>, &#X2026; ., <I>h</I> <I>X</I><SUB><I>n</I></SUB> ) = <I>O</I><SUB><I>h</I> &#X2192; 0</SUB> ( <I>h</I><SUP><I>k</I></SUP> ) </TD></TR>
</TABLE><P>
L&#X2019;égalité à lifter se réécrit donc:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I> lcoeff ( <I>F</I> ) = <I>P</I><SUB>0</SUB> <I>Q</I><SUB>0</SUB> + <I>O</I> ( 1 ) </TD></TR>
</TABLE><P> 
où <I>P</I><SUB>0</SUB> =<I>D</I><SUB><I>b</I></SUB> lcoeff ( <I>F</I> ( <I>b</I> ))/lcoeff ( <I>D</I><SUB><I>b</I></SUB> ) et
<I>Q</I><SUB>0</SUB> = <I>F</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB> lcoeff ( <I>F</I> ) ( <I>b</I> )/lcoeff (
<I>F</I> ( <I>b</I> )/<I>D</I><SUB><I>b</I></SUB> ) sont premiers entre eux et de degré 0 par rapport aux
variables <I>X</I><SUB>2</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I></SUB>. Cherchons <I>P</I><SUB>1</SUB> = <I>O</I> ( 1 ) et <I>Q</I><SUB>1</SUB> = <I>O</I> ( 1 )
de degré 1 par rapport aux variables <I>X</I><SUB>2</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I></SUB> tels que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I> lcoeff ( <I>F</I> ) = ( <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> ) ( <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> ) + <I>O</I> ( 2 ) </TD></TR>
</TABLE><P>
Il faut donc résoudre
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I> lcoeff ( <I>F</I> ) &#X2212; <I>P</I><SUB>0</SUB> <I>Q</I><SUB>0</SUB> = <I>P</I><SUB>0</SUB> <I>Q</I><SUB>1</SUB> + <I>Q</I><SUB>0</SUB> <I>P</I><SUB>1</SUB> + <I>O</I> ( 2 ) </TD></TR>
</TABLE><P>
On peut alors appliquer l&#X2019;identité de Bézout qui permet de déterminer des
polynômes <I>P</I><SUB>1</SUB> et <I>Q</I><SUB>1</SUB> satisfaisant l&#X2019;égalité ci-dessus (avec comme reste <I>O</I>
( 2 ) nul) puisque <I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB> sont premiers entre eux. De plus, on
choisit <I>P</I><SUB>1</SUB> et <I>Q</I><SUB>1</SUB> tels que degre<SUB><I>X</I><SUB>1</SUB></SUB> <I>P</I><SUB>1</SUB> &#X2A7D;
degre<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>F</I> ) &#X2212; degre ( <I>Q</I><SUB>0</SUB> ) = degre ( <I>P</I><SUB>0</SUB> ) et
degre<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>Q</I><SUB>1</SUB> ) &#X2A7D; degre ( <I>Q</I><SUB>0</SUB> ) et
lcoeff<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> ) + <I>O</I> ( 2 ) = lcoeff<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB>
) + <I>O</I> ( 2 ) = lcoeff<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>F</I> ). On tronque ensuite <I>P</I><SUB>1</SUB> et <I>Q</I><SUB>1</SUB> en
ne conservant que les termes de degré 1 par rapport à <I>X</I><SUB>2</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I></SUB>.</P><P>On trouve de la même manière par récurrence <I>P</I><SUB><I>k</I></SUB> et <I>Q</I><SUB><I>k</I></SUB> homogènes de degré
<I>k</I> par rapport à <I>X</I><SUB>2</SUB>, &#X2026; ., <I>X</I><SUB><I>k</I></SUB>, de degré par rapport à <I>X</I><SUB>1</SUB>
respectivement inférieur aux degrés de <I>Q</I><SUB>0</SUB> et de <I>P</I><SUB>0</SUB> et tels que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
<I>F</I> lcoeff ( <I>F</I> ) = ( <I>P</I><SUB>0</SUB> + &#X2026; . + <I>P</I><SUB><I>k</I></SUB> ) ( <I>Q</I><SUB>0</SUB> + &#X2026; . + <I>Q</I><SUB><I>k</I></SUB> ) +
<I>O</I> ( <I>k</I> + 1  ) <A NAME="ezgcd"></A>
    (6)</TD></TR>
</TABLE><P>
et lcoeff ( <I>F</I> ) = lcoeff<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>P</I><SUB>0</SUB> + &#X2026; . + <I>P</I><SUB><I>k</I></SUB> ) + <I>O</I> ( <I>k</I>
+ 1 ) = lcoeff<SUB><I>X</I><SUB>1</SUB></SUB> ( <I>Q</I><SUB>0</SUB> + &#X2026; . + <I>Q</I><SUB><I>k</I></SUB> ) + <I>O</I> ( <I>k</I> + 1 ).</P><P>Si on est bien en un point de bonne évaluation et si <I>k</I> est plus grand que le
degré total (par rapport aux variables <I>X</I><SUB>2</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I></SUB>) du polynôme
<I>F</I> lcoeff ( <I>F</I> ) on va vérifier que <I>P</I><SUB>0</SUB> + &#X2026; . + <I>P</I><SUB><I>k</I></SUB> = <I>D</I>
lcoeff ( <I>F</I> )/lcoeff ( <I>D</I> ). En effet, si on a deux
suites de polynômes <I>P</I> et <I>P</I>&#X2032; et <I>Q</I> et <I>Q</I>&#X2032; satisfaisant (<A HREF="#ezgcd">6</A>) avec
les même termes de degré zéro <I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB>, alors en prenant la différence,
on obtient:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">( <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> &#X2026;  + <I>P</I><SUB><I>k</I></SUB> ) ( <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> &#X2026;  + <I>Q</I><SUB><I>k</I></SUB> ) = ( <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB>&#X2032;
&#X2026;  + <I>P</I><SUB><I>k</I></SUB>&#X2032; ) ( <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB>&#X2032; &#X2026;  + <I>Q</I><SUB><I>k</I></SUB>&#X2032; ) + <I>O</I> ( <I>k</I> + 1 ) </TD></TR>
</TABLE><P>
On égale alors les termes homogènes de degré <I>j</I>, pour <I>j</I> = 1, on obtient
<I>P</I><SUB>0</SUB> ( <I>Q</I><SUB>1</SUB> &#X2212; <I>Q</I><SUB>1</SUB>&#X2032; ) = <I>Q</I><SUB>0</SUB> ( <I>P</I><SUB>1</SUB> &#X2212; <I>P</I><SUB>1</SUB>&#X2032; ), donc <I>Q</I><SUB>0</SUB> divise <I>Q</I><SUB>1</SUB> &#X2212; <I>Q</I><SUB>1</SUB>&#X2032; qui
est de degré strictement inférieur au degré de <I>Q</I><SUB>0</SUB> par rapport à <I>X</I><SUB>1</SUB> (car
on a l&#X2019;inégalité large et les termes de plus haut degré sont égaux),
donc <I>Q</I><SUB>1</SUB> = <I>Q</I><SUB>1</SUB>&#X2032; et <I>P</I><SUB>1</SUB> = <I>P</I><SUB>1</SUB>&#X2032;. On montre de la même manière que <I>Q</I><SUB><I>j</I></SUB> =
<I>Q</I><SUB><I>j</I></SUB>&#X2032; et <I>P</I><SUB><I>j</I></SUB> = <I>P</I><SUB><I>j</I></SUB>&#X2032;. L&#X2019;écriture est donc unique, c&#X2019;est donc l&#X2019;écriture en
polynôme homogène de degré croissant de <I>D</I> lcoeff ( <I>F</I>
)/lcoeff ( <I>D</I> ) que l&#X2019;on reconstruit.</P><P>Cet algorithme permet donc de reconstruire <I>D</I>, il suffit de tester à chaque
étape si <I>P</I><SUB>0</SUB> + &#X2026; . + <I>P</I><SUB><I>k</I></SUB> divise <I>F</I> lcoeff ( <I>F</I> ). On appelle
cette méthode de remontée lemme de Hensel linéaire. Il existe une variante
dite lemme de Hensel quadratique qui consiste à passer de <I>O</I> ( <I>k</I> ) à <I>O</I> ( 2 <I>k</I>
). Elle nécessite toutefois un calcul supplémentaire, celui de l&#X2019;identité de
Bézout à <I>O</I> ( 2 <I>k</I> ) près pour les polynômes <I>P</I><SUB>0</SUB> + &#X2026; . + <I>P</I><SUB><I>k</I> &#X2212; 1</SUB> et
<I>Q</I><SUB>0</SUB> + &#X2026; . + <I>Q</I><SUB><I>k</I> &#X2212; 1</SUB>. Ce calcul se fait également par lifting.</P><P><B>Algorithme EZGCD (Hensel linéaire)</B></P><P>Arguments: 2 polynômes <I>F</I> et <I>G</I> à coefficients entiers et primitifs. Renvoie
le pgcd de <I>F</I> et <I>G</I> ou false.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Evaluer <I>F</I> et <I>G</I> en ( <I>X</I><SUB>2</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I></SUB> ) = ( 0, &#X2026; ., 0 ),
vérifier que les coefficients dominants de <I>F</I> et de <I>G</I> ne s&#X2019;annulent pas.
Calculer le pgcd <I>D</I><SUB><I>b</I></SUB> de <I>F</I> ( 0 ) et de <I>G</I> ( 0 ). Prendre un autre point
d&#X2019;évaluation au hasard qui n&#X2019;annule pas les coefficients dominants de <I>F</I> et
de <I>G</I> et vérifier que le pgcd a le même degré que <I>D</I><SUB><I>b</I></SUB>. Sinon, renvoyer
false (on peut aussi faire une translation d&#X2019;origine de <I>F</I> et de <I>G</I> en un
autre point mais cela diminue l&#X2019;efficacité de l&#X2019;algorithme).</LI><LI CLASS="li-enumerate">On note lcF et lcG les coefficients dominants de <I>F</I>
et de <I>G</I> par rapport à <I>X</I><SUB>1</SUB>.</LI><LI CLASS="li-enumerate">Si degre ( <I>F</I> ) &#X2A7D; degre ( <I>G</I> ) et degre
( <I>D</I><SUB><I>b</I></SUB> ) = degre ( <I>G</I> ) et <I>F</I> divise <I>G</I> renvoyer <I>F</I></LI><LI CLASS="li-enumerate">Si degre ( <I>G</I> ) &lt; degre ( <I>F</I> ) et degre ( <I>D</I><SUB><I>b</I></SUB> )
= degre ( <I>F</I> ) et <I>G</I> divise <I>F</I> renvoyer <I>G</I></LI><LI CLASS="li-enumerate">Si degre ( <I>F</I> ) = degre ( <I>D</I><SUB><I>b</I></SUB> ) ou si degre ( <I>G</I>
) = degre ( <I>D</I><SUB><I>b</I></SUB> ) renvoyer false</LI><LI CLASS="li-enumerate">Boucle infinie sur <I>j</I> entier initialisé à 0, incrémenté de 1 à chaque
itération: si pgcd ( <I>D</I><SUB><I>b</I></SUB>, <I>F</I> ( 0 ) + <I>j</I> <I>G</I> ( 0 )/<I>D</I><SUB><I>b</I></SUB> ) = <I>C</I>
constant, alors arrêter la boucle</LI><LI CLASS="li-enumerate">Lifter l&#X2019;égalité ( <I>F</I> + <I>j</I> <I>G</I> ) ( lcF + <I>j</I> lcG ) ( 0 ) =
( <I>D</I><SUB><I>b</I></SUB> ( lcF + <I>j</I> lcG ) ( 0 )/lcoeff ( <I>D</I><SUB><I>b</I>
)</SUB> ) &#X2217; &#X2026; . par remontée de Hensel linéaire ou quadratique.
Si le résultat est false, renvoyer false. Sinon renvoyer le premier polynôme
du résultat divisé par son contenu vu comme polynôme en <I>X</I><SUB>1</SUB> à coefficients
dans &#X2124; [ <I>X</I><SUB>2</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I></SUB> ].
</LI></OL><P>
<B>Remontée de Hensel linéaire</B>:</P><P>Arguments: <I>F</I> un polynôme, lcF=lcoeff(<I>F</I>) 
son coefficient dominant, <I>P</I><SUB>0</SUB> un
facteur de <I>F</I> ( 0 ) ayant comme coefficient dominant lcF ( 0 ) et
dont le cofacteur <I>Q</I><SUB>0</SUB> est premier avec <I>P</I><SUB>0</SUB>.</P><P>Renvoie deux polynômes <I>P</I> et <I>Q</I> tels que <I>F</I> lcF = <I>P</I> <I>Q</I> et <I>P</I> ( 0 ) =
<I>P</I><SUB>0</SUB> et lcoeff ( <I>P</I> ) = lcoeff ( <I>Q</I> ) = lcF.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Soit <I>G</I> = <I>F</I> lcF, , <I>Q</I><SUB>0</SUB> = <I>G</I> ( 0 ) / <I>P</I><SUB>0</SUB>, <I>P</I> = <I>P</I><SUB>0</SUB>, <I>Q</I> =
<I>Q</I><SUB>0</SUB>.</LI><LI CLASS="li-enumerate">Déterminer les deux polynômes <I>U</I> et <I>V</I> de l&#X2019;identité de Bézout
(tels que <I>P</I><SUB>0</SUB> <I>U</I> + <I>Q</I><SUB>0</SUB> <I>V</I> = <I>d</I> où <I>d</I> est un entier).</LI><LI CLASS="li-enumerate">Boucle infinie avec un compteur <I>k</I> initialisé à 1, incrémenté de 1 à
chaque itération
<UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>k</I> &gt; degre<SUB><I>X</I><SUB>2</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I></SUB></SUB> ( <I>G</I> ), renvoyer false.</LI><LI CLASS="li-itemize">Si <I>P</I> divise <I>G</I>, renvoyer <I>P</I> et <I>G</I> / <I>P</I>.</LI><LI CLASS="li-itemize">Soit <I>H</I> = <I>G</I> &#X2212; <I>P</I> <I>Q</I> = <I>O</I> ( <I>k</I> ). Soit <I>u</I> = <I>U</I> <I>H</I>/<I>d</I> et <I>v</I> = <I>V</I>
<I>H</I>/<I>d</I>, on a <I>P</I><SUB>0</SUB> <I>u</I> + <I>Q</I><SUB>0</SUB> <I>v</I> = <I>H</I></LI><LI CLASS="li-itemize">Remplacer <I>v</I> par le reste de la division euclidienne de <I>v</I> par
<I>P</I><SUB>0</SUB> et <I>u</I> par le reste de la division euclidienne de <I>u</I> par <I>Q</I><SUB>0</SUB>. La
somme des deux quotients est égale au quotient euclidien de <I>H</I> par <I>P</I><SUB>0</SUB>
<I>Q</I><SUB>0</SUB>, c&#X2019;est-à-dire au coefficient dominant de <I>H</I> divisé par le produit
des coefficients dominants de <I>P</I><SUB>0</SUB> et <I>Q</I><SUB>0</SUB> (qui sont égaux) donc on a
l&#X2019;égalité:
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB>0</SUB> <I>u</I> + <I>Q</I><SUB>0</SUB> <I>v</I> = <I>H</I> &#X2212; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">lcoeff ( <I>H</I> )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">lcoeff ( <I>P</I><SUB>0</SUB>
)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB>0</SUB> <I>Q</I><SUB>0</SUB> </TD></TR>
</TABLE>
</LI><LI CLASS="li-itemize">Soit
&#X3B1; = ( lcoeff ( <I>F</I> ) &#X2212; lcoeff ( <I>P</I> )) / lcoeff (
<I>P</I><SUB>0</SUB> ) et &#X3B2; = ( lcoeff ( <I>F</I> ) &#X2212; lcoeff ( <I>Q</I> )) /
lcoeff ( <I>P</I><SUB>0</SUB> ).
On ajoute &#X3B1; <I>P</I><SUB>0</SUB> à <I>v</I>, ainsi lcoeff ( <I>P</I> + <I>v</I> ) =
lcoeff ( <I>F</I> ) + <I>O</I> ( <I>k</I> + 1 ) et &#X3B2; <I>Q</I><SUB>0</SUB> à <I>u</I>, ainsi
lcoeff ( <I>Q</I> + <I>u</I> ) = lcoeff ( <I>F</I> ) + <I>O</I> ( <I>k</I> + 1 ) <P>Remarque: on montre alors que &#X3B1; + &#X3B2; = lcoeff ( <I>H</I>
)/lcoeff ( <I>P</I><SUB>0</SUB> <I>Q</I><SUB>0</SUB> ) + <I>O</I> ( <I>k</I> + 1 ) donc <I>P</I><SUB>0</SUB> <I>u</I> + <I>Q</I><SUB>0</SUB> <I>v</I> = <I>H</I> + <I>O</I> (
<I>k</I> + 1 ) en utilisant les propriétés :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">lcoeff ( <I>F</I> ) = lcoeff ( <I>P</I> ) + <I>O</I> ( <I>k</I> ) =
lcoeff ( <I>Q</I> ) + <I>O</I> ( <I>k</I> ) = lcoeff ( <I>P</I><SUB>0</SUB> ) + <I>O</I> ( 1 ) </TD></TR>
</TABLE></LI><LI CLASS="li-itemize">Réduire <I>u</I> et <I>v</I> en éliminant les termes de degré strictement
supérieur à <I>k</I> par rapport à <I>X</I><SUB>2</SUB>, &#X2026; ., <I>X</I><SUB><I>n</I></SUB>. S&#X2019;il reste un
coefficient non entier, renvoyer false</LI><LI CLASS="li-itemize">Remplacer <I>P</I> par <I>P</I> + <I>v</I> et <I>Q</I> par <I>Q</I> + <I>u</I>, passer à l&#X2019;itération
suivante.
</LI></UL>
</LI></OL><P>
<B>Exemple</B>:</P><P><I>F</I> = (( <I>x</I> + 1 ) <I>y</I> + <I>x</I><SUP>2</SUP> + 1 ) ( <I>y</I><SUP>2</SUP> + <I>x</I> <I>y</I> + 1 ), <I>G</I> = (( <I>x</I> + 1 ) <I>y</I> + <I>x</I><SUP>2</SUP> + 1 )
( <I>y</I><SUP>2</SUP> &#X2212; <I>x</I> <I>y</I> &#X2212; 1 )</P><P>On a <I>F</I> ( 0, <I>y</I> ) = ( <I>y</I> + 1 ) ( <I>y</I><SUP>2</SUP> + 1 ) et <I>G</I> ( 0, <I>y</I> ) = ( <I>y</I> + 1 ) ( <I>y</I><SUP>2</SUP> &#X2212; 1
), le pgcd est donc <I>D</I><SUB><I>b</I></SUB> = ( <I>y</I> + 1 ). On remarque que <I>D</I><SUB><I>b</I></SUB> est premier avec
le cofacteur de <I>F</I> mais pas avec le cofacteur de <I>G</I>. Si on évalue en un
autre point, par exemple <I>x</I> = 1, on trouve un pgcd <I>D</I><SUB>1</SUB> de même degré, donc
0 est vraissemblablement un bon point d&#X2019;évaluation (ici on en est sûr puisque
le pgcd de <I>F</I> et <I>G</I> se calcule à vue...). On a lcoeff ( <I>F</I> ) = <I>x</I> +
1, on va donc lifter <I>G</I> = (( <I>x</I> + 1 ) <I>y</I> + <I>x</I><SUP>2</SUP> + 1 ) ( <I>y</I><SUP>2</SUP> + <I>x</I> <I>y</I> + 1 ) ( <I>x</I> + 1
) = <I>P</I> <I>Q</I> où <I>P</I><SUB>0</SUB> = ( <I>y</I> + 1 ) et <I>Q</I><SUB>0</SUB> = ( <I>y</I><SUP>2</SUP> + 1 ).</P><P>On calcule les polynômes de l&#X2019;identité de Bézout <I>U</I> = ( 1 &#X2212; <I>y</I> ) et <I>V</I> = 1
avec <I>d</I> = 2, puis à l&#X2019;ordre <I>k</I> = 1:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>H</I> = <I>G</I> &#X2212; <I>P</I><SUB>0</SUB> <I>Q</I><SUB>0</SUB> = ( 2 <I>y</I><SUP>3</SUP> + 2 <I>y</I><SUP>2</SUP> + 3 <I>y</I> + 1 ) <I>x</I> + <I>O</I> ( 2 ) </TD></TR>
</TABLE><P>
donc <I>u</I> = reste ( <I>U</I> <I>H</I> / <I>d</I>, <I>Q</I><SUB>0</SUB> ) = <I>x</I> <I>y</I> et <I>v</I> = reste ( <I>V</I> <I>H</I> / <I>d</I>,
<I>P</I><SUB>0</SUB> ) = &#X2212; <I>x</I>.</P><P>Donc <I>Q</I><SUB>1</SUB> = <I>x</I> <I>y</I> + &#X3B1; <I>Q</I><SUB>0</SUB> avec &#X3B1; = ( <I>x</I> + 1 &#X2212; 1 ) / lcoeff (
<I>P</I><SUB>0</SUB> ) = <I>x</I> et <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> = ( <I>y</I><SUP>2</SUP> + 1 ) ( <I>x</I> + 1 ) + <I>x</I> <I>y</I>. De
même, <I>P</I><SUB>1</SUB> = &#X2212; <I>x</I> + &#X3B2; <I>P</I><SUB>0</SUB>, avec &#X3B2; = ( <I>x</I> + 1 &#X2212; 1 ) / lcoeff (
<I>P</I><SUB>0</SUB> ) = <I>x</I> donc <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> = ( <I>y</I> + 1 ) ( <I>x</I> + 1 ) &#X2212; <I>x</I>. On remarque que <I>P</I><SUB>0</SUB> +
<I>P</I><SUB>1</SUB> et <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> sont bien à <I>O</I> ( 2 ) près les facteurs de <I>F</I>
lcoeff ( <I>F</I> ):
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I> = ( <I>x</I> + 1 ) <I>y</I> + <I>x</I><SUP>2</SUP> + 1 = <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> + <I>O</I> ( 2 ),  <I>Q</I> = ( <I>x</I> +
1 ) ( <I>y</I><SUP>2</SUP> + <I>x</I> <I>y</I> + 1 ) = <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> + <I>O</I> ( 2 ) </TD></TR>
</TABLE><P>
Une deuxième itération est nécessaire. On calcule
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>H</I> = <I>G</I> &#X2212; ( <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> ) ( <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> ) = ( 2 <I>y</I><SUP>2</SUP> + <I>y</I> + 1 ) <I>x</I><SUP>2</SUP> + <I>O</I> ( 3
) </TD></TR>
</TABLE><P>
puis reste ( <I>U</I> <I>H</I> / <I>d</I>, <I>Q</I><SUB>0</SUB> ) = <I>y</I> <I>x</I><SUP>2</SUP> et reste ( <I>V</I> <I>H</I> / <I>d</I>, <I>P</I><SUB>0</SUB> )
= <I>x</I><SUP>2</SUP>. Ici les coefficients &#X3B1; et &#X3B2; sont nuls car lcoeff
( <I>F</I> ) n&#X2019;a pas de partie homogène de degré 2. On trouve alors <I>P</I> = <I>P</I><SUB>0</SUB> + <I>P</I><SUB>1</SUB> +
<I>P</I><SUB>2</SUB> et <I>Q</I> = <I>Q</I><SUB>0</SUB> + <I>Q</I><SUB>1</SUB> + <I>Q</I><SUB>2</SUB>. Pour calculer le pgcd, il suffit de calculer la
partie primitive de <I>P</I> vu comme polynôme en <I>y</I>, ici c&#X2019;est encore <I>P</I> car le
contenu de <I>P</I> est 1 (remarque: pour <I>Q</I> le contenu est <I>x</I> + 1).<BR>
On trouve donc <I>P</I> comme pgcd.</P><!--TOC subsection Quel algorithme choisir?-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc24">4.4</A>  Quel algorithme choisir?</H3><!--SEC END --><P>Il est toujours judicieux de faire une évaluation en quelques <I>n</I> &#X2212; 1 uplets
pour traquer les pgcd triviaux. (E)EZGCD sera efficace si (0,...,0) est un
point de bonne évaluation et si le nombre de remontées nécessaires pour le
lemme de Hensel est petit donc pour les pgcd de petit degré, GCDMOD est aussi
efficace si le degré du pgcd est petit. Le sous-résultant est efficace pour
les pgcd de grand degré car il y a alors peu de divisions euclidiennes à
effectuer et les coefficients n&#X2019;ont pas trop le temps de croitre. SPMOD est
intéressant pour les polynômes creux de pgcd non trivial creux. GCDHEU est
intéressant pour les problèmes relativement petits.</P><P>Avec des machines multiprocesseurs, on a probablement intérêt à lancer en
parallèle plusieurs algorithmes et à s&#X2019;arrêter dès que l&#X2019;un deux recontre le
succès.</P><!--TOC subsection Pour en savoir plus.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc25">4.5</A>  Pour en savoir plus.</H3><!--SEC END --><P>
Parmi les références citées dans le premier article, ce sont les livres de
Knuth, H. Cohen, et Davenport-Siret-Tournier qui traitent des algorithmes de
pgcd. On peut bien sûr consulter le source de son système de calcul formel
lorsqu&#X2019;il est disponible :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
pour MuPAD sur un système Unix, depuis le
répertoire d&#X2019;installation de MuPAD (en général <TT>/usr/local/MuPAD</TT>)
après avoir désarchivé le fichier <TT>lib.tar</TT> du répertoire <TT>share/lib</TT> 
par la commande<BR>
<TT>cd share/lib &amp;&amp; tar xvf lib.tar</TT><BR>
on trouve les algorithmes de calcul de PGCD dans le répertoire<BR>
<TT>share/lib/lib/POLYLIB/GCD</TT>
</LI><LI CLASS="li-itemize">Pour l&#X2019;algorithme EZGCD, je me suis inspiré de l&#X2019;implémentation de 
Singular (logiciel libre disponible à <TT>www.singular.uni-kl.de</TT>)
</LI></UL><P>
Sur le web on trouve quelques articles en lignes sur le
sujet en cherchant les mots clefs GCDHEU, EZGCD, SPMOD sur un moteur de 
recherche, il y a par exemple une description un peu différente du pgcd
heuristique sur:<BR>
<TT>www.inf.ethz.ch/personal/gonnet/CAII/HeuristicAlgorithms/node1.html</TT><BR>
et un article de comparaison de ces algorithmes 
par Fateman et Liao (dont la référence bibliographique est
Evaluation of the heuristic polynomial GCD.
in: ISSAC pages 240&#X2013;247, 1995). Quelques autres références :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
K.O.Geddes et al "Alg. for Computer Algebra", Kluwer 1992.
</LI><LI CLASS="li-itemize">pour GCDHEU Char, Geddes, Gonnet, 
Gcdheu: Heuristic polynomial gcd algorithm based on integer gcd computation,
in: Journal of Symbolic Computation, 7:31&#X2013;48, 1989.
</LI><LI CLASS="li-itemize">pour SPMOD "Probabilistic Algorithms for Sparse Polynomials",
in: Symbolic &amp; Algebraic Comp. (Ed E.W.Ng), Springer 1979, pp216,
</LI></UL><!--TOC section Le résultant-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc26">5</A>  Le résultant</H2><!--SEC END --><P>
Il s&#X2019;agit d&#X2019;un point de vue d&#X2019;algèbre linéaire sur le PGCD. Considérons
deux polynômes <I>A</I> et <I>B</I> de degrés <I>p</I> et <I>q</I> et de pgcd <I>D</I> et 
l&#X2019;identité de Bézout correspondante :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:bezout"></A>
<I>A</I> <I>U</I> + <I>B</I> <I>V</I> =<I>D</I>
    (7)</TD></TR>
</TABLE><P>
avec degré(<I>U</I>)&lt;<I>q</I> et degré(<I>V</I>)&lt;<I>p</I>.
Imaginons qu&#X2019;on cherche <I>U</I> et <I>V</I> en oubliant qu&#X2019;il s&#X2019;agit d&#X2019;une
identité de Bézout, en considérant simplement qu&#X2019;il s&#X2019;agit d&#X2019;un
problème d&#X2019;algèbre linéaire de <I>p</I>+<I>q</I> équations (obtenues en développant
et en identifiant chaque puissance de <I>X</I> de 0 à <I>p</I>+<I>q</I>&#X2212;1) 
à <I>p</I>+<I>q</I> inconnues (les <I>p</I> coefficients de <I>V</I> et les <I>q</I> coefficients de <I>U</I>)
On sait que <I>A</I> et <I>B</I> sont premiers entre eux si et seulement si ce problème
d&#X2019;algèbre linéaire a une solution pour <I>D</I>=1. Donc si le déterminant
du système est non nul, alors <I>A</I> et <I>B</I> sont premiers entre eux.
Réciproquement si <I>A</I> et <I>B</I> sont premiers entre eux, le système a
une solution unique non seulement avec comme second membre 1 mais avec
n&#X2019;importe quel polynôme de degré inférieur <I>p</I>+<I>q</I>, donc le
déterminant du système est non nul.</P><P><B>Définition:</B><BR>
On appelle résultant de <I>A</I> et <I>B</I> le déterminant de ce système 
(<A HREF="#eq:bezout">7</A>). Il s&#X2019;annule si et seulement si <I>A</I> et <I>B</I>
ne sont pas premiers entre eux (ont au moins une racine commune).
On appelle matrice de Sylvester la transposée de la matrice du système
(les inconnues étant par ordre décroissant les coefficients de <I>U</I>
et <I>V</I>)
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I>(<I>A</I>,<I>B</I>)=</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>a</I><SUB><I>a</I></SUB></TD><TD ALIGN=center NOWRAP><I>a</I><SUB><I>a</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP>&#X2026;</TD><TD ALIGN=center NOWRAP>&#X2026;</TD><TD ALIGN=center NOWRAP><I>a</I><SUB>0</SUB></TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>&#X2026;</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>a</I><SUB><I>a</I></SUB></TD><TD ALIGN=center NOWRAP>&#X2026;</TD><TD ALIGN=center NOWRAP>&#X2026;</TD><TD ALIGN=center NOWRAP><I>a</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP><I>a</I><SUB>0</SUB></TD><TD ALIGN=center NOWRAP>&#X2026;</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X22EE; </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>&#X2026;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP><I>a</I><SUB>0</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>b</I><SUB><I>b</I></SUB></TD><TD ALIGN=center NOWRAP><I>b</I><SUB><I>b</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP>&#X2026;</TD><TD ALIGN=center NOWRAP><I>b</I><SUB>0</SUB></TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>&#X2026;</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&#X22EE; </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>&#X2026;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP><I>b</I><SUB>0</SUB> </TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
(cette matrice contient <I>b</I>=degré(<I>B</I>) lignes de coefficients
du polynôme <I>A</I> et <I>a</I>=degré(<I>A</I>) lignes de coefficients du
polynôme <I>B</I>)</P><P><B>Lien avec l&#X2019;algorithme du sous-résultant (calcul de PGCD)</B><BR>
On peut calculer le déterminant avec la suite des restes de divisions
euclidiennes de la manière suivante, on part de la pseudo-division
de <I>A</I> par <I>B</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>b</I><SUB><I>b</I></SUB><SUP><I>a</I>&#X2212;<I>b</I>+1</SUP> <I>A</I>=<I>BQ</I>+<I>R</I> </TD></TR>
</TABLE><P>
on effectue alors sur chaque ligne contenant les coefficients de <I>A</I>
la manipulation de ligne correspondante, c&#X2019;est-à-dire multiplier
la ligne par <I>b</I><SUB><I>b</I></SUB><SUP><I>a</I>&#X2212;<I>b</I>+1</SUP> et soustraire (<I>q</I><SUB>0</SUB> fois la ligne
de <I>B</I> terminant dans la même colonne+<I>q</I><SUB>1</SUB> fois la ligne
de <I>B</I> terminant une colonne avant+...). Toutes les lignes
contenant les coefficients de <I>A</I> ont été remplacées par des lignes 
contenant les coefficients de <I>R</I>. Ces lignes contiennent <I>k</I> zéros initiaux
avec <I>k</I> &#X2265; 1, ce qui permet de réduire le déterminant à celui
de la matrice de Sylvester de <I>R</I> et <I>B</I> (à un coefficient multiplicatif
près qui vaut <I>b</I><SUB><I>b</I></SUB><SUP><I>k</I></SUP> par rapport au précédent donc
<I>b</I><SUB><I>b</I></SUB><SUP><I>k</I>&#X2212;<I>b</I>(<I>a</I>&#X2212;<I>b</I>+1)</SUP> par rapport au déterminant de départ). 
On échange ensuite <I>R</I> et <I>B</I> ce qui change
éventuellement le signe et on continue en faisant les
divisions euclidiennes de l&#X2019;algorithme du sous-résultant (cf.
Knuth où on utilise la matrice de Sylvester pour prouver que
l&#X2019;algorithme du sous-résultant est correct). Rappelons que
le sous-résultant définit les suites <I>A</I><SUB><I>k</I></SUB> (<I>A</I><SUB>0</SUB>=<I>A</I>, <I>A</I><SUB>1</SUB>=<I>B</I>),
<I>d</I><SUB><I>k</I></SUB> le degré de <I>A</I><SUB><I>k</I></SUB>, &#X3B4;<SUB><I>k</I></SUB>=<I>d</I><SUB><I>k</I></SUB>&#X2212;<I>d</I><SUB><I>k</I>+1</SUB>,
<I>g</I><SUB><I>k</I></SUB> (<I>g</I><SUB>0</SUB>=1, si <I>k</I>&#X2260; 0, <I>g</I><SUB><I>k</I></SUB> coefficient dominant de <I>A</I><SUB><I>k</I></SUB>) 
<I>h</I><SUB><I>k</I></SUB> (<I>h</I><SUB>0</SUB>=1, <I>h</I><SUB><I>k</I>+1</SUB>=<I>h</I><SUB><I>k</I></SUB><SUP>1&#X2212;&#X3B4;<SUB><I>k</I></SUB></SUP> <I>g</I><SUB><I>k</I>+1</SUB><SUP>&#X3B4;<SUB><I>k</I></SUB></SUP>) et
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I><SUB><I>k</I></SUB><SUP>&#X3B4;<SUB><I>k</I>&#X2212;1</SUB>+1</SUP> <I>A</I><SUB><I>k</I>&#X2212;1</SUB> = <I>A</I><SUB><I>k</I></SUB> <I>Q</I><SUB><I>k</I>+1</SUB> + 
<I>g</I><SUB><I>k</I>&#X2212;1</SUB> <I>h</I><SUB><I>k</I>&#X2212;1</SUB><SUP>&#X3B4;<SUB><I>k</I>&#X2212;1</SUB></SUP> <I>A</I><SUB><I>k</I>+1</SUB> </TD></TR>
</TABLE><DIV CLASS="theorem"><B>Théorème 3</B>  <EM>
Le résultant est égal au signe près au coefficient </EM><EM><I>h</I></EM><SUB><EM><I>k</I></EM></SUB><EM> où </EM><EM><I>k</I></EM><EM>
correspond au reste </EM><EM><I>A</I></EM><SUB><EM><I>k</I></EM></SUB><EM> constant (en supposant que le résultant
soit non nul).
</EM></DIV><P><B>Preuve</B><BR>
La transcription de l&#X2019;égalité précédente sur les
résultants donne par la méthode ci-dessus :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>g</I><SUB><I>k</I></SUB><SUP>(&#X3B4;<SUB><I>k</I>&#X2212;1</SUB>+1)<I>d</I><SUB><I>k</I></SUB></SUP>Res(<I>A</I><SUB><I>k</I>&#X2212;1</SUB>,<I>A</I><SUB><I>k</I></SUB>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>&#X2212;1</SUB>&#X2212;<I>d</I><SUB><I>k</I>+1</SUB></SUP> Res(<I>g</I><SUB><I>k</I>&#X2212;1</SUB> <I>h</I><SUB><I>k</I>&#X2212;1</SUB><SUP>&#X3B4;<SUB><I>k</I>&#X2212;1</SUB></SUP> <I>A</I><SUB><I>k</I>+1</SUB>,<I>A</I><SUB><I>k</I></SUB>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>&#X2212;1</SUB>&#X2212;<I>d</I><SUB><I>k</I>+1</SUB></SUP> (<I>g</I><SUB><I>k</I>&#X2212;1</SUB> <I>h</I><SUB><I>k</I>&#X2212;1</SUB><SUP>&#X3B4;<SUB><I>k</I>&#X2212;1</SUB></SUP>)<SUP><I>d</I><SUB><I>k</I></SUB></SUP>
Res(<I>A</I><SUB><I>k</I>+1</SUB>,<I>A</I><SUB><I>k</I></SUB>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On en déduit que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Res(<I>A</I><SUB><I>k</I>&#X2212;1</SUB>,<I>A</I><SUB><I>k</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB><I>k</I>&#X2212;1</SUB><SUP><I>d</I><SUB><I>k</I></SUB></SUP> <I>h</I><SUB><I>k</I>&#X2212;1</SUB><SUP><I>d</I><SUB><I>k</I>&#X2212;1</SUB>&#X2212;1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
= <I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>&#X2212;1</SUB>&#X2212;<I>d</I><SUB><I>k</I>+1</SUB>&#X2212;(&#X3B4;<SUB><I>k</I>&#X2212;1</SUB>+1)<I>d</I><SUB><I>k</I></SUB></SUP>  
<I>h</I><SUB><I>k</I>&#X2212;1</SUB><SUP>&#X3B4;<SUB><I>k</I>&#X2212;1</SUB><I>d</I><SUB><I>k</I></SUB>+1&#X2212;<I>d</I><SUB><I>k</I>&#X2212;1</SUB></SUP> Res(<I>A</I><SUB><I>k</I>+1</SUB>,<I>A</I><SUB><I>k</I></SUB>) </TD></TR>
</TABLE><P>
On observe que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>h</I><SUB><I>k</I>&#X2212;1</SUB><SUP>&#X3B4;<SUB><I>k</I>&#X2212;1</SUB><I>d</I><SUB><I>k</I></SUB>+1&#X2212;<I>d</I><SUB><I>k</I>&#X2212;1</SUB></SUP> =<I>h</I><SUB><I>k</I>&#X2212;1</SUB><SUP>(&#X3B4;<SUB><I>k</I>&#X2212;1</SUB>&#X2212;1)(<I>d</I><SUB><I>k</I></SUB>&#X2212;1)</SUP>
= </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239D;</TD><TD CLASS="dcell"><I>h</I><SUB><I>k</I>&#X2212;1</SUB><SUP>&#X3B4;<SUB><I>k</I>&#X2212;1</SUB>&#X2212;1</SUP></TD><TD CLASS="dcell">&#X239E;<BR>
&#X23A0;</TD><TD CLASS="dcell"><SUP><I>d</I><SUB><I>k</I></SUB>&#X2212;1</SUP>
= </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB><I>k</I></SUB><SUP>&#X3B4;<SUB><I>k</I>&#X2212;1</SUB></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>h</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>d</I><SUB><I>k</I></SUB>&#X2212;1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Res(<I>A</I><SUB><I>k</I>&#X2212;1</SUB>,<I>A</I><SUB><I>k</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB><I>k</I>&#X2212;1</SUB><SUP><I>d</I><SUB><I>k</I></SUB></SUP> <I>h</I><SUB><I>k</I>&#X2212;1</SUB><SUP><I>d</I><SUB><I>k</I>&#X2212;1</SUB>&#X2212;1</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>&#X2212;1</SUB>&#X2212;<I>d</I><SUB><I>k</I>+1</SUB>&#X2212;(&#X3B4;<SUB><I>k</I>&#X2212;1</SUB>+1)<I>d</I><SUB><I>k</I></SUB></SUP>  
</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB><I>k</I></SUB><SUP>&#X3B4;<SUB><I>k</I>&#X2212;1</SUB></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>h</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>d</I><SUB><I>k</I></SUB>&#X2212;1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
Res(<I>A</I><SUB><I>k</I>+1</SUB>,<I>A</I><SUB><I>k</I></SUB>) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>&#X2212;1</SUB>&#X2212;<I>d</I><SUB><I>k</I>+1</SUB>&#X2212;<I>d</I><SUB><I>k</I></SUB>&#X2212;&#X3B4;<SUB><I>k</I>&#X2212;1</SUB></SUP>  
</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>h</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>d</I><SUB><I>k</I></SUB>&#X2212;1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><BR>
<BR>
<BR>
</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
Res(<I>A</I><SUB><I>k</I>+1</SUB>,<I>A</I><SUB><I>k</I></SUB>) </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"> Res(<I>A</I><SUB><I>k</I>+1</SUB>,<I>A</I><SUB><I>k</I></SUB>) </TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"> <I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>+1</SUB></SUP> <I>h</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I></SUB>&#X2212;1</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Donc en valeur absolue
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Res(<I>A</I><SUB>0</SUB>,<I>A</I><SUB>1</SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB>0</SUB><SUP><I>d</I><SUB>1</SUB></SUP> <I>h</I><SUB>0</SUB><SUP><I>d</I><SUB>0</SUB>&#X2212;1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">|
= |</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">Res(<I>A</I><SUB><I>k</I>&#X2212;1</SUB>,<I>A</I><SUB><I>k</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB><I>k</I>&#X2212;1</SUB><SUP><I>d</I><SUB><I>k</I></SUB></SUP> <I>h</I><SUB><I>k</I>&#X2212;1</SUB><SUP><I>d</I><SUB><I>k</I>&#X2212;1</SUB>&#X2212;1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> |</TD></TR>
</TABLE><P>
En prenant le rang <I>k</I> tel que <I>A</I><SUB><I>k</I></SUB> est constant, on a <I>d</I><SUB><I>k</I></SUB>=0
et le résultant est égal à <I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>&#X2212;1</SUB></SUP>, on obtient donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|Res(<I>A</I><SUB>0</SUB>,<I>A</I><SUB>1</SUB>)|=|</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>g</I><SUB><I>k</I></SUB><SUP><I>d</I><SUB><I>k</I>&#X2212;1</SUB></SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"> <I>h</I><SUB><I>k</I>&#X2212;1</SUB><SUP><I>d</I><SUB><I>k</I>&#X2212;1</SUB>&#X2212;1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> |
</TD></TR>
</TABLE><P>
Comme ici &#X3B4;<SUB><I>k</I>&#X2212;1</SUB>=<I>d</I><SUB><I>k</I>&#X2212;1</SUB>, le terme de droite est |<I>h</I><SUB><I>k</I></SUB>|.</P><P><B>Remarque</B><BR>
On peut calculer au fur et à mesure le signe du résultant en tenant 
compte des degrés de <I>A</I><SUB><I>k</I></SUB> pour inverser l&#X2019;ordre de <I>A</I><SUB><I>k</I>&#X2212;1</SUB> et
<I>A</I><SUB><I>k</I></SUB> dans le résultant.</P><P><B>Utilisation</B><BR>
La valeur du résultant est très utile pour savoir si 2 polynômes
dépendant de paramètres sont premiers entre eux en fonction
de la valeur des paramètres. En effet, la fonction <TT>gcd</TT> d&#X2019;un
logiciel de calcul formel calculera le PGCD par rapport à toutes
les variables en incluant les paramètres. En cherchant quand le résultant
s&#X2019;annule en fonction des paramètres on obtient un autre type
d&#X2019;information.</P><P><B>Exemple :</B><BR>
Chercher quand le polynône <I>P</I>=<I>x</I><SUP>3</SUP>+<I>px</I>+<I>q</I> possède
une racine multiple en fonction de <I>p</I> et <I>q</I>. On calcule le
résultant de <I>P</I> et <I>P</I>&#X2032; et on trouve 4<I>p</I><SUP>3</SUP>+27<I>q</I><SUP>2</SUP>, donc <I>P</I>
a une racine multiple si et seulement si 4<I>p</I><SUP>3</SUP>+27<I>q</I><SUP>2</SUP>=0.</P><P><B>Remarque :</B><BR>
On peut montrer que le résultant de <I>P</I> et <I>P</I>&#X2032; est divisible
par le coefficient dominant de <I>P</I>, on appelle le quotient discriminant.</P><!--TOC section Les suites de Sturm-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc27">6</A>  Les suites de Sturm</H2><!--SEC END --><P>
L&#X2019;algorithme du sous-résultant appliqué à un polynôme sans
racine multiple <I>P</I> et à sa dérivée
permet, à condition de changer les signes dans la suite des restes, 
de connaitre le nombre de racines réelles d&#X2019;un polynôme dans un 
intervalle. Ceci est trè utile pour par exemple simplifier des valeurs
absolues de polynômes dans un intervalle.</P><P>On définit donc la suite de polynômes <I>A</I><SUB>0</SUB>=<I>P</I>, <I>A</I><SUB>1</SUB>=<I>P</I>&#X2032;, ..., <I>A</I><SUB><I>k</I></SUB>,0
par :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:sturm"></A>
<I>A</I><SUB><I>i</I></SUB> = <I>A</I><SUB><I>i</I>+1</SUB> <I>Q</I><SUB><I>i</I>+2</SUB> &#X2212; <I>A</I><SUB><I>i</I>+2</SUB> 
    (8)</TD></TR>
</TABLE><P>
avec <I>A</I><SUB><I>k</I></SUB>, le dernier reste non nul, un polynôme constant puisque
<I>P</I> n&#X2019;a pas de racine multiple. On utilise plutot l&#X2019;algorithme du 
sous-résultant que l&#X2019;algorithme d&#X2019;Euclide, il faut alors
s&#X2019;assurer que les signes de <I>A</I><SUB><I>i</I></SUB> et <I>A</I><SUB><I>i</I>+2</SUB> sont opposés lorsque
<I>A</I><SUB><I>i</I>+1</SUB>  s&#X2019;annule quitte à changer le signe de <I>A</I><SUB><I>i</I>+2</SUB> en fonction
du signe du coefficient dominant de <I>A</I><SUB><I>i</I>+1</SUB>, de la parité de
la différence des degrés et du signe du coefficient <I>gh</I><SUP>1&#X2212;&#X3B4;</SUP>.</P><P>On définit <I>s</I>(<I>a</I>) comme étant le nombre de changements de signes
de la suite <I>A</I><SUB><I>i</I></SUB>(<I>a</I>) en ignorant les 0.
Alors le nombre de racines réelles de <I>A</I><SUB>0</SUB>=<I>P</I> sur l&#X2019;intervalle
]<I>a</I>,<I>b</I>] est égal à <I>s</I>(<I>a</I>)&#X2212;<I>s</I>(<I>b</I>).</P><P><B>Preuve</B><BR>
On considére la suite des signes en un point : elle ne peut contenir
deux 0 successifs (sinon toute la suite vaudrait 0 en ce point en appliquant
(<A HREF="#eq:sturm">8</A>), or <I>A</I><SUB><I>k</I></SUB> est constant non nul). Elle ne peut pas
non plus contenir +,0,+ ni -,0,- à cause de la convention de signe
sur les restes de (<A HREF="#eq:sturm">8</A>). Donc une racine <I>b</I>
de <I>A</I><SUB><I>i</I></SUB> pour 0&lt;<I>i</I>&lt;<I>k</I>, n&#X2019;influe pas sur la valeur de <I>s</I> au voisinage
de <I>b</I> (il y a toujours un changement de signe entre les positions
<I>i</I>&#X2212;1 et <I>i</I>+1). Comme <I>A</I><SUB><I>k</I></SUB> est constant, seules les racines de <I>A</I><SUB>0</SUB>=<I>P</I>
sont susceptibles de faire varier <I>s</I>. Comme <I>A</I><SUB>1</SUB>=<I>P</I>&#X2032;, le sens de
variations de <I>A</I><SUB>0</SUB> au voisinage d&#X2019;une racine de <I>A</I><SUB>0</SUB> est déterminé
par le signe de <I>A</I><SUB>1</SUB>, donc les possibilités sont -,+ vers +,+
ou +,- vers -,-, ce qui diminue <I>s</I> d&#X2019;une unité.</P><!--TOC section Exercices (PGCD, résultant, ...)-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc28">7</A>  Exercices (PGCD, résultant, ...)</H2><!--SEC END --><!--TOC subsection Instructions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc29">7.1</A>  Instructions</H3><!--SEC END --><P>
Les instructions arithmétiques sont en général dans
la librairie standard. 
Elles sont dans les menus
Math-&gt;Integer et Alg-&gt;Polynomes/Arit.polynomiale de <CODE>Xcas</CODE>.
Certaines de ces instructions
sont dans la librairie <CODE>numtheory</CODE> (en maple) ou 
<CODE>numlib</CODE> (en MuPAD)
(utilisez <CODE>?numtheory</CODE> ou <CODE>?numlib</CODE> pour avoir la liste 
des fonctions de ces librairies), 
pour éviter de taper <CODE>numlib::</CODE> ou <CODE>numtheory::</CODE>
à chaque fois, on peut lancer en maple la commande 
<CODE>with(numtheory);</CODE> ou en MuPAD 
<CODE>export(numlib);</CODE>.</P><!--TOC subsubsection Entiers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc30">7.1.1</A>  Entiers</H4><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>chrem</CODE> (en MuPAD <CODE>numlib::ichrem</CODE>) :
restes chinois (entier)
</LI><LI CLASS="li-itemize"><CODE>divisors</CODE>
(en maple <CODE>numtheory::divisors</CODE>, en MuPAD 
<CODE>numlib::divisors</CODE>) :
liste des diviseurs d&#X2019;un entier
</LI><LI CLASS="li-itemize"><CODE>gcd, lcm</CODE> : PGCD et PPCM
</LI><LI CLASS="li-itemize"><CODE>igcdex</CODE>: Bézout pour des entiers
</LI><LI CLASS="li-itemize"><CODE>iquo</CODE> et <CODE>irem</CODE> quotient et reste de la division 
euclidienne de deux entiers
</LI><LI CLASS="li-itemize"><CODE>isprime</CODE> test de primalité. En maple et MuPAD, il
s&#X2019;agit d&#X2019;un test de pseudo-primalité. En Xcas, utiliser
<CODE>is_pseudoprime</CODE> pour effectuer un test plus rapide
de pseudo-primalité.
</LI><LI CLASS="li-itemize"><CODE>mods</CODE>: reste euclidien symétrique
</LI><LI CLASS="li-itemize"><CODE>nextprime</CODE> et <CODE>prevprime</CODE> 
(en MuPAD <CODE>numlib::prevprime</CODE>): nombre premier suivant 
ou précédent
</LI><LI CLASS="li-itemize"><CODE>powmod(a,b,n)</CODE> (Xcas), <CODE>a &amp;^ b mod n</CODE> (Maple),
<CODE>powermod(a,b,n)</CODE> (Mupad): calcul de <I>a</I><SUP><I>b</I></SUP> (mod <I>n</I> ) par
l&#X2019;algorithme de la puissance rapide
</LI></UL><!--TOC subsubsection Polynômes-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc31">7.1.2</A>  Polynômes</H4><!--SEC END --><P>
On peut représenter les polynômes par leur écriture symbolique
(par exemple <CODE>x^2+1</CODE>), ou par des listes (représentation dense
ou creuse, récursive ou distribuée). Xcas, Maple et MuPAD
acceptent la représentation symbolique. Xcas propose deux types
de représentation, dense à une variable (<CODE>poly1[ ]</CODE>), ou
distribuée (<CODE>%%%{ }%%%</CODE>) et des instructions de conversion
(<CODE>poly2symb</CODE> et <CODE>symb2poly</CODE>) entre représentations.
MuPAD propose également une représentation non symbolique, cf.
la documentation <CODE>?poly</CODE>. L&#X2019;intérêt d&#X2019;une représentation
non symbolique est l&#X2019;efficacité des opérations polynomiales, (et la
possibilité de chronométrer des opérations comme le produit
de 2 polynômes).</P><P>Les instructions qui suivent
utilisent la représentation symbolique, certaines acceptent
les autres représentations.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>coeff</CODE> coefficient(s) d&#X2019;un polynôme, 
</LI><LI CLASS="li-itemize"><CODE>coeffs</CODE> liste des coefficients d&#X2019;un polynôme
(à développer auparavant, en mupad on utilise <CODE>coeff</CODE>)
</LI><LI CLASS="li-itemize"><CODE>content</CODE> contenu (pgcd des coefficients)
</LI><LI CLASS="li-itemize"><CODE>degree</CODE> degré
</LI><LI CLASS="li-itemize"><CODE>divide</CODE> division euclidienne, 
</LI><LI CLASS="li-itemize"><CODE>gcd, lcm</CODE> PGCD et PPCM
</LI><LI CLASS="li-itemize"><CODE>gcdex</CODE> Bézout, 
</LI><LI CLASS="li-itemize"><CODE>genpoly</CODE> (en MuPAD <CODE>numlib::genpoly</CODE>): 
crée un polynôme à partir de la
représentation <I>z</I>-adique d&#X2019;un entier (utile pour le PGCD heuristique) 
</LI><LI CLASS="li-itemize"><CODE>icontent</CODE>: contenu entier pour un polynôme à plusieurs
variables
</LI><LI CLASS="li-itemize"><CODE>indets</CODE>: 
liste des noms de variables d&#X2019;une expression
</LI><LI CLASS="li-itemize"><CODE>lcoeff</CODE>: coefficient dominant d&#X2019;un polynôme
</LI><LI CLASS="li-itemize"><CODE>ldegree</CODE>: valuation
</LI><LI CLASS="li-itemize">(MuPAD) <CODE>multcoeffs</CODE> 
multiplie les coefficients d&#X2019;un polynôme
</LI><LI CLASS="li-itemize">(MuPAD) <CODE>pdivide</CODE> pseudo-division
</LI><LI CLASS="li-itemize">(MuPAD) <CODE>poly(expr,[var],coeff)</CODE> crée un polynôme à partir de
l&#X2019;expression symbolique <CODE>expr</CODE> par rapport une variable ou
à une liste de variables <CODE>var</CODE>, on peut indiquer dans quel anneau 
vivent les coefficients (par exemple dans &#X2124;/13&#X2124; avec comme 3ème argument
<CODE>IntMod(13)</CODE>)
</LI><LI CLASS="li-itemize"><CODE>primpart</CODE>: partie primitive d&#X2019;un polynôme
</LI><LI CLASS="li-itemize"><CODE>quo</CODE>, <CODE>rem</CODE> (xcas et Maple) quotient et reste euclidien
(en MuPAD utiliser les options Quo et Rem de <CODE>divide</CODE>)
</LI><LI CLASS="li-itemize"><CODE>tcoeff</CODE>: coefficient de plus bas degré d&#X2019;un polynôme
</LI><LI CLASS="li-itemize"><CODE>interp</CODE> (MuPAD <CODE>interpolate</CODE>) : interpolation de Lagrange
</LI><LI CLASS="li-itemize"><CODE>convert(.,sqrfree)</CODE> 
(MuPAD <CODE>polylib::sqrfree</CODE>) :
décomposition en facteurs n&#X2019;ayant pas de racine multiples
</LI><LI CLASS="li-itemize"><CODE>convert(.,parfrac)</CODE> 
(MuPAD <CODE>polylib::partfrac</CODE>) : décomposition en éléments simples
</LI><LI CLASS="li-itemize"><CODE>resultant</CODE> (MuPAD <CODE>polylib::resultant</CODE>) : 
calcule le résultant de 2 polynômes par rapport à une variable.
</LI></UL><P>Notez aussi que le menu <CODE>Exemples-&gt;poly-&gt;pgcd.xws</CODE> de Xcas contient 
des exemples de programmes de calcul de pgcd de type Euclide.</P><!--TOC subsubsection Calculs modulo <I>n</I>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc32">7.1.3</A>  Calculs modulo <I>n</I></H4><!--SEC END --><P>
Pour travailler dans &#X2124;/<I>n</I>&#X2124;[<I>X</I>] :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
avec <CODE>Xcas</CODE> on utilise la notation % comme en C, par
exemple <TT>gcd(P % 3, Q % 3)</TT>. On peut aussi utiliser la notation
Maple en mode &#X201C;syntaxe Maple&#X201D; (cf. ci-dessous)
</LI><LI CLASS="li-itemize">avec Maple,
on utilise les formes inertes des instructions (qui renvoient l&#X2019;instruction
non évaluée), dont le nom est le même que le nom de commande
habituel mais précédé par une majuscule, puis on indique
<CODE>mod n</CODE>, par exemple <CODE>Gcd(P,Q) mod 11</CODE>.
</LI><LI CLASS="li-itemize">avec MuPAD, on désigne le type des coefficients par exemple par 
<CODE>IntMod(13)</CODE> puis on construit des objets ayant des coefficients
de ce type (par exemple des polynômes, cf. infra). Par exemple
<CODE>poly(x^2+1,[x],IntMod(13))</CODE>. 
</LI></UL><!--TOC subsection Exercices PGCD-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc33">7.2</A>  Exercices PGCD</H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Calculez le pgcd de <I>x</I><SUP>202</SUP>+<I>x</I><SUP>101</SUP>+1
et sa dérivée modulo 3 et modulo 5. Conclusion?</LI><LI CLASS="li-enumerate"><I>P</I>=51<I>x</I><SUP>3</SUP>&#X2212;35<I>x</I><SUP>2</SUP>+39<I>x</I>&#X2212;115 et <I>Q</I>=17<I>x</I><SUP>4</SUP>&#X2212;23<I>x</I><SUP>3</SUP>+34<I>x</I><SUP>2</SUP>+39<I>x</I>&#X2212;115.
Calculez le pgcd de <I>P</I> et <I>Q</I> modulo 5, 7 et 11. En déduire
le pgcd de <I>P</I> et <I>Q</I> par le théorème des restes chinois. Pourquoi
ne doit-on pas essayer modulo 17?</LI><LI CLASS="li-enumerate">Écrire un programme qui détermine le degré probable
du pgcd de 2 polynômes en une variable en utilisant le pgcd modulaire 
(on considère le degré probable déterminé lorsqu&#X2019;on trouve
deux nombres premiers réalisant le minimum des degrés trouvés)</LI><LI CLASS="li-enumerate">Détaillez l&#X2019;algorithme du PGCD heuristique pour les
polynômes <I>P</I>=(<I>x</I>+1)<SUP>7</SUP>&#X2212;(<I>x</I>&#X2212;1)<SUP>6</SUP> et sa dérivée. Comparez avec l&#X2019;algorithme
d&#X2019;Euclide naïf.</LI><LI CLASS="li-enumerate">Écrire un programme mettant en oeuvre le pgcd heuristique
pour des polynômes à une variable.</LI><LI CLASS="li-enumerate">On veut comprendre comment un logiciel de calcul formel calcule
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>6</SUP>+2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>x</I><SUP>3</SUP>+1)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dx</I> </TD></TR>
</TABLE>
On se ramène d&#X2019;abord à une fraction propre (numérateur <I>N</I> de degré 
inférieur au dénominateur),
Soit <I>P</I>=<I>X</I><SUP>3</SUP>+1, calculez le PGCD de <I>P</I> et <I>P</I>&#X2032;, puis
deux polynômes <I>U</I> et <I>V</I> tels que:
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I>=<I>UP</I>+<I>VP</I>&#X2032; </TD></TR>
</TABLE>
On décompose alors l&#X2019;intégrale en deux morceaux :<BR>
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>U</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  + </TD><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><I>V</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD></TR>
</TABLE>
Faites une intégration par parties sur le deuxième terme
et en déduire la valeur de l&#X2019;intégrale du départ.</LI><LI CLASS="li-enumerate">Écrire un programme mettant en oeuvre l&#X2019;algorithme modulaire
de calcul du PGCD.</LI><LI CLASS="li-enumerate">Écrire un programme qui détermine le degré probable du PGCD 
par rapport à toutes les
variables de 2 polynôme à plusieurs variables
en utilisant l&#X2019;évaluation en toutes les variables
sauf une.</LI><LI CLASS="li-enumerate">Calculer le pgcd par une méthode modulaire de
(<I>xy</I>&#X2212;<I>x</I>+1)(<I>xy</I>+<I>x</I><SUP>2</SUP>+1) et (<I>xy</I>&#X2212;<I>x</I>&#X2212;<I>y</I>)(<I>xy</I>&#X2212;<I>x</I>+1)</LI></OL><!--TOC subsection Exercices (résultant)-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc34">7.3</A>  Exercices (résultant)</H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Pour quelles valeurs de <I>p</I> le polynôme <I>X</I><SUP>5</SUP>+<I>X</I><SUP>3</SUP>&#X2212;<I>pX</I>+1 admet-il
une racine multiple?
</LI><LI CLASS="li-enumerate">Résoudre le système en éliminant successivement les
variables grâce au résultant :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X23A7;<BR>
&#X23AA;<BR>
&#X23A8;<BR>
&#X23AA;<BR>
&#X23A9;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>a</I><SUP>3</SUP>+<I>b</I><SUP>3</SUP>+<I>c</I><SUP>3</SUP></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>8 </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>a</I><SUP>2</SUP>+<I>b</I><SUP>2</SUP>+<I>c</I><SUP>2</SUP></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>6 </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>a</I>+<I>b</I>+2<I>c</I></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>4</TD></TR>
</TABLE></TD></TR>
</TABLE>
</LI><LI CLASS="li-enumerate">Donner le détail des calculs avec Bézout de la décomposition
en éléments simples de :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>x</I><SUP>2</SUP>&#X2212;1)<SUP>2</SUP>(<I>x</I>+2)</TD></TR>
</TABLE></TD></TR>
</TABLE>
puis calculer le coefficient de <I>x</I><SUP><I>n</I></SUP> du développement en séries
entières de cette fraction en 0.
</LI><LI CLASS="li-enumerate">Calculer 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1&#X2212;<I>x</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1+<I>x</I><SUP>4</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>dx</I> </TD></TR>
</TABLE>
en utilisant le résultant pour calculer les logarithmes.
</LI><LI CLASS="li-enumerate">En utilisant uniquement l&#X2019;instruction de calcul de PGCD
déterminer la multiplicité maximale d&#X2019;un facteur irréductible
de 
<I>x</I><SUP>14</SUP>&#X2212;<I>x</I><SUP>13</SUP>&#X2212;14<I>x</I><SUP>12</SUP>+12<I>x</I><SUP>11</SUP>+78<I>x</I><SUP>10</SUP>&#X2212;54<I>x</I><SUP>9</SUP>&#X2212;224<I>x</I><SUP>8</SUP>+116<I>x</I><SUP>7</SUP>+361<I>x</I><SUP>6</SUP>&#X2212;129<I>x</I><SUP>5</SUP>&#X2212;330<I>x</I><SUP>4</SUP>+72<I>x</I><SUP>3</SUP>+160<I>x</I><SUP>2</SUP>&#X2212;16<I>x</I>&#X2212;32
</LI></OL><!--TOC subsection Exercice (Bézout modulaire)-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc35">7.4</A>  Exercice (Bézout modulaire)</H3><!--SEC END --><P>
Soit <I>A</I> et <I>B</I> deux polynômes à coefficients entiers et premiers
entre eux. Soit <I>c</I> &#X2208; &#X2124;<SUP>*</SUP>  le résultant de <I>A</I> et <I>B</I>,
on va calculer les polynômes <I>U</I> et <I>V</I> de l&#X2019;identité de Bézout 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:bezoutmod"></A>
<I>A</I> <I>U</I> + <I>B</I> <I>V</I> = <I>c</I> ,    deg(<I>U</I>)&lt;deg(<I>B</I>), deg(<I>V</I>)&lt;deg(<I>A</I>)
    (9)</TD></TR>
</TABLE><P>
par une méthode modulaire.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Montrer, en utilisant les formules de Cramer,
que les coefficients de <I>U</I> et <I>V</I> sont des entiers de
valeur absolue inférieure ou égale à la borne de Hadamard <I>h</I> de
la matrice de Sylvester de <I>A</I> et <I>B</I> (dont le déterminant est <I>c</I>,
le résultant de <I>A</I> et <I>B</I>). Calculer <I>h</I> en fonction
de la norme euclidienne de <I>A</I>, <I>B</I> et de leurs degrés. 
</LI><LI CLASS="li-enumerate">On calcule <I>c</I> &#X2208; &#X2124;<SUP>*</SUP> puis on
résoud (<A HREF="#eq:bezoutmod">9</A>) dans &#X2124;/<I>p</I><SUB><I>i</I></SUB> <I>Z</I>[<I>X</I>] pour
plusieurs nombres premiers <I>p</I><SUB><I>i</I></SUB> (choisis si possible inférieurs 
à &#X221A;<SPAN style="text-decoration:overline">2</SPAN><SUP><SPAN style="text-decoration:overline">31</SPAN></SUP> pour des raisons d&#X2019;efficacité), puis on calcule par le
théorème des restes chinois (<A HREF="#eq:bezoutmod">9</A>) 
dans &#X2124;/&#X220F;<I>p</I><SUB><I>i</I></SUB> <I>Z</I>[<I>X</I>]. Donner une minoration de 
&#X220F;<SUB><I>i</I></SUB> <I>p</I><SUB><I>i</I></SUB> faisant intervenir <I>h</I> qui permette de garantir
que l&#X2019;écriture en représentation symétrique de (<A HREF="#eq:bezoutmod">9</A>)
dans &#X2124;/&#X220F;<I>p</I><SUB><I>i</I></SUB> <I>Z</I>[<I>X</I>] est identique à (<A HREF="#eq:bezoutmod">9</A>) dans &#X2124;[<I>X</I>].
</LI><LI CLASS="li-enumerate">Application : résoudre de cette manière l&#X2019;équation de
Bézout pour 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=(<I>X</I>+1)<SUP>4</SUP>(<I>X</I>&#X2212;3),    <I>B</I>=(<I>X</I>&#X2212;1)<SUP>4</SUP>(<I>X</I>+2)</TD></TR>
</TABLE> 
(vous pouvez utiliser
sans justifications l&#X2019;instruction de calcul de résultant,
des coefficients de Bézout dans &#X2124;/<I>p</I><SUB><I>i</I></SUB><I>Z</I>[<I>X</I>] et 
de reste chinois de votre logiciel).
</LI><LI CLASS="li-enumerate">Écrire une fonction mettant en oeuvre cet algorithme.
</LI><LI CLASS="li-enumerate">Que pensez-vous de l&#X2019;intérêt de cet algorithme par rapport à
l&#X2019;algorithme d&#X2019;Euclide étendu dans &#X2124;[<I>X</I>]?
</LI></OL><!--TOC subsection Exercice (Géométrie et résultants).-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc36">7.5</A>  Exercice (Géométrie et résultants).</H3><!--SEC END --><P>
On cherche une relation algébrique entre les coordonnées de 4 points
<I>A</I>,<I>B</I>,<I>C</I>,<I>D</I> qui traduise le fait que ces 4 points sont cocycliques. Cette
condition étant invariante par translation, on cherche une
relation entre les 6 coordonnées des 3 vecteurs <I>v</I><SUB>1</SUB>=(<I>x</I><SUB>1</SUB>,<I>y</I><SUB>1</SUB>), 
<I>v</I><SUB>2</SUB>=(<I>x</I><SUB>2</SUB>,<I>y</I><SUB>2</SUB>) et <I>v</I><SUB>3</SUB>=(<I>x</I><SUB>3</SUB>,<I>y</I><SUB>3</SUB>) 
d&#X2019;origine <I>A</I> et d&#X2019;extrémité <I>B</I>, <I>C</I> et <I>D</I>.
On peut supposer quitte à translater que le centre du cercle est
l&#X2019;origine, on a donc 5 paramètres : le rayon du cercle <I>R</I> et les
4 angles des points sur le cercle &#X3B8;<SUB>0</SUB>, &#X3B8;<SUB>1</SUB>, &#X3B8;<SUB>2</SUB> et
&#X3B8;<SUB>3</SUB>. La relation cherchée va s&#X2019;obtenir en éliminant les
5 paramètres des expressions des 6 coordonnées en fonction de
ces paramètres.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Exprimer les 6 coordonnées en fonction de 
<I>R</I> et <I>a</I>=tan(&#X3B8;<SUB>0</SUB>/2), <I>b</I>=tan(&#X3B8;<SUB>1</SUB>/2), <I>c</I>=tan(&#X3B8;<SUB>2</SUB>/2)
et <I>d</I>=tan(&#X3B8;<SUB>3</SUB>/2). On obtient ainsi 6 équations, par exemple les
deux premières sont de la forme
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I><SUB>1</SUB>&#X2212; <I>F</I>(<I>R</I>,<I>a</I>,<I>b</I>)= 0,    <I>y</I><SUB>1</SUB>&#X2212; <I>G</I>(<I>R</I>,<I>a</I>,<I>b</I>)= 0 </TD></TR>
</TABLE>
où <I>F</I> et <I>G</I> sont deux fractions rationnelles.
</LI><LI CLASS="li-enumerate">En réduisant au même dénominateur, calculer 6 
polynômes, fonction de
<I>x</I><SUB>1</SUB>,<I>y</I><SUB>1</SUB>,<I>x</I><SUB>2</SUB>,<I>y</I><SUB>2</SUB>,<I>x</I><SUB>3</SUB>,<I>y</I><SUB>3</SUB>,<I>R</I>,<I>a</I>,<I>b</I>,<I>c</I>,<I>d</I>, qui doivent s&#X2019;annuler
pour que les points soient cocycliques
(Vous pouvez utiliser l&#X2019;instruction <CODE>numer</CODE> pour obtenir le
numérateur d&#X2019;une fraction rationnelle).
</LI><LI CLASS="li-enumerate">Éliminer <I>b</I> des polynômes
contenant <I>x</I><SUB>1</SUB> et <I>y</I><SUB>1</SUB> et factoriser
le polynôme obtenu, faire de même avec <I>c</I>, <I>x</I><SUB>2</SUB> et <I>y</I><SUB>2</SUB>
et <I>d</I>, <I>x</I><SUB>3</SUB> et <I>y</I><SUB>3</SUB>, en déduire (en supposant que les points sont
tous distincts) 3 polynômes en <I>x</I><SUB>1</SUB>,<I>y</I><SUB>1</SUB>,<I>x</I><SUB>2</SUB>,<I>y</I><SUB>2</SUB>,<I>x</I><SUB>3</SUB>,<I>y</I><SUB>3</SUB>,<I>R</I>,<I>a</I> qui
s&#X2019;annulent.
</LI><LI CLASS="li-enumerate">Éliminer <I>R</I> et <I>a</I>, en déduire la relation cherchée.
</LI><LI CLASS="li-enumerate">Vérifier que cette relation est équivalente à la nullité
de la partie imaginaire du birapport des affixes &#X3B1;, &#X3B2;, &#X3B3;,
&#X3B4; des 4 points :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X2111; </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X3B1;&#X2212;&#X3B2;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">&#X3B1;&#X2212;&#X3B3;</TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X3B4;&#X2212;&#X3B3;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">&#X3B4;&#X2212;&#X3B2;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">= 0</TD></TR>
</TABLE>
</LI></OL><!--TOC subsection Décalage entier entre racines.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc37">7.6</A>  Décalage entier entre racines.</H3><!--SEC END --><P>
Soit <I>P</I> un polynôme à coefficients entiers sans racines multiples. 
On dira que <I>P</I> a la propriété <FONT COLOR=red><I>I</I></FONT> si
deux des racines de <I>P</I> sont décalées d&#X2019;un entier. 
En d&#X2019;autres termes, si <I>r</I><SUB>1</SUB>,...,<I>r</I><SUB><I>n</I></SUB> désignent
les racines complexes distinctes de <I>P</I>, <I>P</I> possède la
propriété <FONT COLOR=red><I>I</I></FONT>
s&#X2019;il existe 
au moins un entier parmi les différences <I>r</I><SUB><I>i</I></SUB>&#X2212;<I>r</I><SUB><I>j</I></SUB> pour <I>i</I> &#X2260; <I>j</I>. 
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Soit
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I>(<I>t</I>)=resultant<SUB><I>x</I></SUB>(<I>P</I>(<I>x</I>),<I>P</I>(<I>x</I>+<I>t</I>)) </TD></TR>
</TABLE>
Montrer que <I>R</I> est à coefficients entiers.
Montrer que la propriété <FONT COLOR=red><I>I</I></FONT> est équivalente à
la propriété &#X201C;<I>R</I> possède une racine entière non nulle&#X201D;.
On va maintenant construire un algorithme déterminant les racines
entières du polynôme <I>R</I>.
</LI><LI CLASS="li-enumerate">Après division de <I>R</I> par une puissance de <I>t</I>, on peut
supposer que <I>R</I> a un coefficient constant non nul. Après division de
<I>R</I> par son contenu, on peut aussi supposer
que le contenu de <I>R</I> est 1. En effectuant ensuite une factorisation
square-free de <I>R</I>, on peut se ramener au cas où <I>R</I> et <I>R</I>&#X2032; sont
premiers entre eux.
Soit <I>a</I> une racine de <I>R</I>.
<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
Donner une majoration de |<I>a</I>| 
en fonction du coefficient constant de <I>R</I>.
</LI><LI CLASS="li-enumerate">Soit <I>p</I> un nombre premier ne divisant pas le coefficient dominant
de <I>R</I> et tel que <I>R</I> et <I>R</I>&#X2032; soient premiers entre eux modulo <I>p</I>. 
On peut calculer <I>a</I> à partir d&#X2019;une racine
de <I>R</I> modulo <I>p</I> en la &#X201C;remontant&#X201D; modulo <I>p</I><SUP><I>k</I></SUP> pour <I>k</I>
assez grand (algorithme p-adique). Pour quelle valeur de <I>k</I> peut-on
reconstruire toutes les racines entières de <I>R</I> ? 
</LI><LI CLASS="li-enumerate">Comparer l&#X2019;algorithme ci-dessus avec les algorithmes suivants :
la factorisation de <I>R</I> sur &#X2124;, 
la recherche numérique des racines complexes de <I>R</I>,
la recherche des racines entières de <I>R</I> parmi les diviseurs 
entiers du coefficient constant de <I>R</I> et leurs opposés.
</LI></OL>
</LI><LI CLASS="li-enumerate">Une fois les racines entières de <I>R</I> connues, comment
peut-on en déduire les facteurs de <I>P</I> dont les racines diffèrent
de cet(ces) entier(s)?
</LI><LI CLASS="li-enumerate">Soit 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>x</I>)=<I>x</I><SUP>6</SUP>+9<I>x</I><SUP>5</SUP>+29<I>x</I><SUP>4</SUP>+41<I>x</I><SUP>3</SUP>+37 <I>x</I><SUP>2</SUP>+59<I>x</I>+31</TD></TR>
</TABLE>
Montrer que <I>P</I> a la propriété <FONT COLOR=red><I>I</I></FONT>. Calculer
la ou les racines entières de <I>R</I> et donner la factorisation
correspondante de <I>P</I>. 
</LI><LI CLASS="li-enumerate">Écrire un programme qui effectue cet algorithme sur un
polynôme quelconque. On pourra utiliser la fonction 
<CODE>rationalroot</CODE> de Xcas pour déterminer les racines
entières de <I>R</I>.
</LI><LI CLASS="li-enumerate">Application : on cherche à calculer
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq"></A>
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;9<I>x</I><SUP>2</SUP>&#X2212;27<I>x</I>&#X2212;30</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I>(<I>x</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">
    (10)</TD></TR>
</TABLE>
Décomposer cette fraction
en éléments simples (donner le détail des calculs en utilisant
la factorisation précédente et l&#X2019;identité de Bezout 
<CODE>abcuv</CODE> en Xcas). 
</LI><LI CLASS="li-enumerate">Calculer la somme précédente (<A HREF="#eq">10</A>).
On pourra remarquer que pour <I>k</I> entier strictement positif,
1/<I>f</I>(<I>x</I>+<I>k</I>)&#X2212;1/<I>f</I>(<I>x</I>)
s&#X2019;exprime comme une somme de différences 
1/<I>f</I>(<I>x</I>+<I>j</I>+1)&#X2212;1/<I>f</I>(<I>x</I>+<I>j</I>).
</LI><LI CLASS="li-enumerate">Écrire un programme effectuant ce calcul avec une fraction
quelconque, lorsque cela est possible.
</LI></OL><!--TOC section Factorisation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc38">8</A>  Factorisation</H2><!--SEC END --><P>On présente ici quelques algorithmes utilisés pour factoriser un polynôme 
à coefficients entiers. 
Pour un polynôme en une variable,
cele se fait en plusieurs étapes : on commence
par se ramener à un polynôme <I>P</I> dont tous les facteurs sont de multiplicité
un, ensuite on factorise <I>P</I> dans &#X2124;/<I>p</I>&#X2124; (par la méthode de Berlekamp
ou Cantor-Zassenhauss), puis on remonte à &#X2124;/<I>p</I><SUP><I>k</I></SUP> <I>Z</I>
pour <I>k</I> suffisamment grand (en fonction de la borne de Landau sur les
facteurs de <I>P</I>), et on recombine enfin les facteurs modulaires pour
trouver les facteurs de <I>P</I>. Lorsque <I>P</I> à plusieurs variables, on utilise
une méthode analogue à celle permettant de trouver le pgcd de polynômes
à plusieurs variables. 
</P><P><B>Rappel</B><BR>
Le pgcd des coefficients d&#X2019;un polynôme est appelé contenu de ce polynôme.
Un polynôme est dit primitif si son contenu est égal à 1.</P><!--TOC subsection Les facteurs multiples-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc39">8.1</A>  Les facteurs multiples</H3><!--SEC END --><P>
Étant donné un polynôme <I>P</I> à coefficients entiers, on cherche à 
écrire :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>=&#X3A0;<SUB><I>k</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>k</I></SUB><SUP><I>k</I></SUP> </TD></TR>
</TABLE><P>
où les <I>P</I><SUB><I>k</I></SUB> n&#X2019;ont pas de facteurs multiples et sont premiers entre
eux deux à deux. Comme on est en
caractéristique 0, cela revient à dire que pgcd(<I>P</I><SUB><I>k</I></SUB>,<I>P</I><SUB><I>k</I></SUB>&#X2032;)=1
et pgcd(<I>P</I><SUB><I>k</I></SUB>,<I>P</I><SUB><I>j</I></SUB>)=1. Bien entendu
on va utiliser la dérivée de <I>P</I> dans l&#X2019;algorithme de recherche des <I>P</I><SUB><I>k</I></SUB> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>&#X2032;=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>kP</I><SUB><I>k</I></SUB>&#X2032; <I>P</I><SUB><I>k</I></SUB><SUP><I>k</I>&#X2212;1</SUP> &#X3A0;<SUB><I>j</I>&#X2260; <I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB><SUP><I>j</I></SUP> </TD></TR>
</TABLE><P>
Soit <I>G</I> le pgcd de <I>P</I> et de <I>P</I>&#X2032;. On a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>G</I>=&#X3A0;<SUB><I>k</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>k</I></SUB><SUP><I>k</I>&#X2212;1</SUP>, </TD></TR>
</TABLE><P>
en effet <I>G</I> divise <I>P</I> et <I>P</I>&#X2032; :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>W</I><SUB>1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>G</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">=&#X3A0;<SUB><I>k</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>k</I></SUB>,    
<I>Z</I><SUB>1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>G</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>kP</I><SUB><I>k</I></SUB>&#X2032;&#X3A0;<SUB><I>j</I>&#X2260; <I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
il s&#X2019;agit de vérifier que <I>W</I><SUB>1</SUB> et <I>Z</I><SUB>1</SUB> sont premiers entre eux. Soit <I>F</I> un
facteur irréductible du pgcd de <I>W</I><SUB>1</SUB> et <I>Z</I><SUB>1</SUB>, alors <I>F</I> divise l&#X2019;un des 
<I>P</I><SUB><I>k</I></SUB>,
appelons <I>P</I><SUB><I>l</I></SUB> ce facteur. Comme <I>F</I> divise &#X3A0;<SUB><I>j</I>&#X2260; <I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB> si <I>k</I>&#X2260; <I>l</I>,
on en déduit que <I>F</I> divise le dernier terme de la somme de <I>Z</I><SUB>1</SUB>, c&#X2019;est-à-dire
que <I>F</I> divise <I>lP</I><SUB><I>l</I></SUB>&#X2032;&#X3A0;<SUB><I>j</I>&#X2260; <I>l</I></SUB> <I>P</I><SUB><I>j</I></SUB> donc <I>F</I> divise <I>P</I><SUB><I>l</I></SUB>&#X2032; puisque
les <I>P</I><SUB><I>k</I></SUB> sont premiers entre eux. Donc <I>P</I><SUB><I>l</I></SUB> et <I>P</I><SUB><I>l</I></SUB>&#X2032; ont un facteur
en commun, ce qui est contraire aux hypothèses.</P><P>On pose alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Y</I><SUB>1</SUB>=<I>Z</I><SUB>1</SUB>&#X2212;<I>W</I><SUB>1</SUB>&#X2032;=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>&gt;1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>k</I>&#X2212;1)<I>P</I><SUB><I>k</I></SUB>&#X2032; &#X3A0;<SUB><I>j</I>&#X2260; <I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
On définit alors par récurrence des suites de polynômes <I>W</I><SUB><I>n</I></SUB>, <I>Y</I><SUB><I>n</I></SUB> et
<I>G</I><SUB><I>m</I></SUB> par :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>G</I><SUB><I>m</I></SUB>=pgcd(<I>W</I><SUB><I>m</I></SUB>,<I>Y</I><SUB><I>m</I></SUB>)
</LI><LI CLASS="li-itemize"><I>W</I><SUB><I>m</I>+1</SUB>=<I>W</I><SUB><I>m</I></SUB>/<I>G</I><SUB><I>m</I></SUB> et <I>Y</I><SUB><I>m</I>+1</SUB>=<I>Y</I><SUB><I>m</I></SUB>/<I>G</I><SUB><I>m</I></SUB>&#X2212;<I>W</I><SUB><I>m</I></SUB>&#X2032;
</LI></UL><P>
On va montrer que <I>P</I><SUB><I>m</I></SUB>=<I>G</I><SUB><I>m</I></SUB>. Commençons au rang <I>n</I>=1, on voit que <I>P</I><SUB>1</SUB>
divise <I>Y</I><SUB>1</SUB> (puisqu&#X2019;il est commun à tous les &#X3A0;<SUB><I>j</I>&#X2260; <I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB> car
<I>k</I>&gt;1) et divise <I>W</I><SUB>1</SUB>. Et c&#X2019;est le seul facteur commun, car tout autre
facteur irréductible serait un diviseur d&#X2019;un <I>P</I><SUB><I>l</I></SUB> pour <I>l</I>&gt;1, donc diviserait
(<I>l</I>&#X2212;1)<I>P</I><SUB><I>l</I></SUB>&#X2032;&#X3A0;<SUB><I>j</I>&#X2260; <I>l</I>,<I>j</I>&gt;1</SUB> <I>P</I><SUB><I>j</I></SUB>, donc diviserait <I>P</I><SUB><I>l</I></SUB>&#X2032;.
Le raisonnement en un rang quelconque est identique, les polynômes sont
donnés par :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>G</I><SUB><I>m</I></SUB>=<I>P</I><SUB><I>m</I></SUB>,  <I>W</I><SUB><I>m</I></SUB>=&#X3A0;<SUB><I>k</I>&gt;=<I>m</I></SUB> <I>P</I><SUB><I>k</I></SUB>,  
<I>Y</I><SUB><I>m</I></SUB>=<FONT SIZE=6>&#X2211;</FONT><I>k</I>&gt;<I>m</I> (<I>k</I>&#X2212;<I>m</I>)<I>P</I><SUB><I>k</I></SUB>&#X2032;&#X3A0;<SUB><I>j</I>&#X2265; <I>m</I>, <I>j</I>&#X2260; <I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>Lorsqu&#X2019;on programme cet algorithme, le test d&#X2019;arrêt est <I>G</I><SUB><I>m</I></SUB>=1.</P><P><B>Square-free factorisation (Algorithme de Yun)</B><BR>
Argument: un polynôme primitif <I>P</I> à coefficients entiers (ou dans &#X2124;[<I>i</I>]
ou dans un corps de caractéristique nulle).<BR>
Valeur renvoyée: une liste de polynômes <I>P</I><SUB><I>m</I></SUB> telle que 
<I>P</I>=&#X3A0;<SUB><I>k</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>k</I></SUB><SUP><I>k</I></SUP>.<BR>
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Initialiser la liste résultat à liste vide.
</LI><LI CLASS="li-enumerate">Initialiser <I>W</I> à <I>P</I> et <I>Y</I> à <I>P</I>&#X2032;. Calculer le pgcd <I>G</I> de <I>W</I> et <I>Y</I>
et simplifier <I>W</I> et <I>Y</I> par leur pgcd puis poser <I>Y</I>=<I>Y</I>&#X2212;<I>W</I>&#X2032;.
</LI><LI CLASS="li-enumerate">Boucle infinie.
</LI><LI CLASS="li-enumerate">Calculer le pgcd <I>G</I> de <I>W</I> et <I>Y</I>. Si <I>G</I>=1, on renvoie la liste
résultat sinon ajouter <I>G</I> à la liste résultat.
</LI><LI CLASS="li-enumerate">Simplifier <I>W</I> et <I>Y</I> par <I>G</I>, puis poser <I>Y</I>=<I>Y</I>&#X2212;<I>W</I>&#X2032; et passer à 
l&#X2019;itération suivante.
</LI></OL><P>Remarque : lorsqu&#X2019;on veut factoriser un polynôme à coefficients modulaires,
il faut aussi se ramener à un polynôme sans facteurs multiples mais
on ne peut pas utiliser cet algorithme tel quel car la caractéristique
du corps n&#X2019;est pas nulle.</P><P><B>Exemple</B> :<BR>
Factorisation sans facteurs multiples de 
<I>P</I>(<I>X</I>)=(<I>X</I><SUP>3</SUP>&#X2212;1)(<I>X</I>+2)<SUP>2</SUP>(<I>X</I><SUP>2</SUP>+3)<SUP>3</SUP>.
En mode interactif avec un logiciel de calcul formel, effectuons l&#X2019;étape
d&#X2019;initialisation :
</P><PRE CLASS="verbatim">W:=normal((x^3-1)*(x+2)^2*(x^2+3)^3);
Y:=diff(W,x);
G:=gcd(W,Y);
        x^5+2*x^4+6*x^3+12*x^2+9*x+18
W:=normal(W/G); 
        x^6+2*x^5+3*x^4+5*x^3+-2*x^2+-3*x-6
Y:=normal(Y/G);
Y:=normal(Y-diff(W,x));
        5*x^5+8*x^4+3*x^3+-5*x^2+-8*x-3
</PRE><P>On vérifie bien que <I>W</I>=(<I>x</I>+2)*(<I>x</I><SUP>3</SUP>&#X2212;1)*(<I>x</I><SUP>2</SUP>+3) est le produit 
des facteurs <I>P</I><SUB><I>i</I></SUB>. On entame maintenant la boucle :
</P><PRE CLASS="verbatim">G:=gcd(W,Y);
        x^3-1   -&gt; P1
Y:=normal(Y/G);
W:=normal(W/G);
Y:=normal(Y-diff(W,x));
        2*x^2+4*x
G:=gcd(W,Y);
        x+2     -&gt; P2
Y:=normal(Y/G);
W:=normal(W/G);
Y:=normal(Y-diff(W,x));
        0
G:=gcd(W,Y);
        x^2+3   -&gt;  P3
</PRE><P>puis <I>W</I>=1 et <I>Y</I>=0 et le prochain <I>G</I> vaut 1, on a bien trouvé tous
les facteurs <I>P</I><SUB><I>i</I></SUB>.</P><!--TOC subsection Factorisation en une variable-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc40">8.2</A>  Factorisation en une variable</H3><!--SEC END --><P>
On suppose maintenant qu&#X2019;on veut factoriser un polynôme <I>P</I> sans facteur
multiple (et primitif). En général on commence par simplifier <I>P</I> par
ses facteurs linéaires (détectés avec l&#X2019;algorithme présenté dans le
premier article de cette série). On commence par chercher un nombre premier <I>p</I>
tel que <I>P</I> dans &#X2124;/<I>p</I>&#X2124; conserve le même degré et reste sans facteur 
multiple (donc pgcd(<I>P</I>,<I>P</I>&#X2032;)=1 dans &#X2124;/<I>p</I>&#X2124;), ce qui est toujours
possible (il suffit de prendre <I>p</I> plus grand que le plus grand entier 
apparaissant dans l&#X2019;algorithme du sous-résultant pour calculer
le pgcd de <I>P</I> et <I>P</I>&#X2032; dans &#X2124;).</P><P><B>Convention</B><BR>
Tous les polynômes ayant leurs coefficients dans un corps fini sont
supposés avoir comme coefficient dominant 1 lorsque le choix
existe (par exemple les facteurs d&#X2019;un polynôme modulo <I>p</I>).</P><!--TOC subsubsection Factorisation dans &#X2124;/<I>p</I>&#X2124;[<I>X</I>]-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc41">8.2.1</A>  Factorisation dans &#X2124;/<I>p</I>&#X2124;[<I>X</I>]</H4><!--SEC END --><P>
On suppose qu&#X2019;on a un polynôme <I>P</I> à coefficients dans &#X2124;/<I>p</I>&#X2124; sans
facteur multiple. Il s&#X2019;agit de factoriser <I>P</I> dans &#X2124;/<I>p</I>&#X2124;[<I>X</I>].
Il existe essentiellement deux stratégies, l&#X2019;une commence par factoriser par
groupes de facteurs de même degré puis casse les facteurs et l&#X2019;autre 
plus directe à base d&#X2019;algèbre linéaire modulaire (méthode de Berlekamp). 
Dans les deux cas, on utilise le fait que si <I>F</I> est un polynôme, 
alors les polynômes à coefficients dans &#X2124;/<I>p</I>&#X2124;
modulo <I>F</I> forment un anneau <I>A</I> qui est aussi un espace vectoriel 
sur &#X2124;/<I>p</I>&#X2124; de dimension le degré de <I>F</I> 
(si <I>F</I> est irréductible, alors <I>A</I> est un corps).
On s&#X2019;intéresse alors aux propriétés de l&#X2019;application 
&#X3D5;: <I>x</I> &#X2208; <I>A</I> &#X21A6; <I>x</I><SUP><I>p</I></SUP>.
On observe d&#X2019;abord que cette application est une application <EM>linéaire</EM>.
Cela découle du petit théorème de Fermat pour &#X3D5;(&#X3BB; <I>x</I>)=&#X3BB;
&#X3D5;(<I>x</I>) et de la formule de Newton et de la primalité de <I>p</I> pour
&#X3D5;(<I>x</I>+<I>y</I>)=&#X3D5;(<I>x</I>)+&#X3D5;(<I>y</I>).</P><P><B>Calcul de </B><B>&#X3D5;</B><BR>
Pour mettre en oeuvre ces algorithmes, on commence par déterminer la matrice
de l&#X2019;endomorphisme &#X3D5;: <I>x</I> &#X21A6; <I>x</I><SUP><I>p</I></SUP> dans &#X2124;/<I>p</I>&#X2124;[<I>X</I>] (mod <I>P</I>(<I>X</I>) )
muni de sa base canonique { 1, <I>X</I>,...,<I>X</I><SUP>deg(<I>P</I>)&#X2212;1</SUP> }.</P><!--TOC subsubsection Distinct degree factorization-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc42">8.2.2</A>  Distinct degree factorization</H4><!--SEC END --><P>
Cette méthode consiste à détecter les groupes de facteurs
ayant un degré donné (distinct degree factorization). Si nécessaire, 
on utilise ensuite un autre algorithme pour casser ces groupes.
On utilise ici les propriétés des itérées de l&#X2019;application linéaire 
&#X3D5; sur des espaces vectoriels de corps de base &#X2124;/<I>p</I>&#X2124;.
On va déterminer le produit <I>P</I><SUB><I>k</I></SUB> de tous les facteurs de <I>P</I> de degré <I>k</I>
en calculant le pgcd de <I>P</I> et de <I>X</I><SUP>(<I>p</I><SUP><I>k</I></SUP>)</SUP>&#X2212;<I>X</I> dans &#X2124;/<I>p</I>&#X2124;[<I>X</I>].</P><P>Pour <I>k</I>=1, <I>X</I><SUP><I>p</I></SUP>&#X2212;<I>X</I> est le produit des <I>X</I>&#X2212;<I>k</I> pour tout <I>k</I>&#X2208; &#X2124;/<I>p</I>&#X2124;
par le petit théorème de Fermat (<I>k</I><SUP><I>p</I></SUP>=<I>k</I> (mod <I>p</I> )), donc le pgcd
de <I>P</I> et de <I>X</I><SUP>(<I>p</I><SUP>1</SUP>)</SUP>&#X2212;<I>X</I> dans &#X2124;/<I>p</I>&#X2124;[<I>X</I>] est le produit des facteurs
de <I>P</I> de degré 1.</P><P>Pour <I>k</I>&gt;1, le raisonnement se généralise de la manière suivante : on
considère un facteur irréductible <I>F</I>(<I>X</I>) de <I>P</I> de degré <I>k</I> et le corps
<I>K</I>=(&#X2124;/<I>p</I>&#X2124;)[<I>Y</I>] (mod <I>F</I>(<I>Y</I>) ). Le corps <I>K</I> est un corps fini, c&#X2019;est
aussi un espace vectoriel sur &#X2124;/<I>p</I>&#X2124; de dimension <I>k</I>, donc <I>K</I> possède
<I>p</I><SUP><I>k</I></SUP> éléments et <I>K</I><SUP>*</SUP> est un groupe multiplicatif à <I>p</I><SUP><I>k</I></SUP>&#X2212;1 éléments,
donc tout élément de <I>K</I><SUP>*</SUP> vérifie l&#X2019;équation <I>x</I><SUP><I>p</I><SUP><I>k</I></SUP>&#X2212;1</SUP>=1 donc
tout élément de <I>K</I> vérifie <I>x</I><SUP>(<I>p</I><SUP><I>k</I></SUP>)</SUP>=<I>x</I>. En particulier pour 
<I>x</I>=<I>Y</I> (mod <I>F</I>(<I>Y</I>) ) 
on trouve que <I>Y</I><SUP>(<I>p</I><SUP><I>k</I></SUP>)</SUP>=<I>Y</I> (mod <I>F</I>(<I>Y</I>) ) donc <I>F</I>(<I>X</I>) divise <I>X</I><SUP>(<I>p</I><SUP><I>k</I></SUP>)</SUP>&#X2212;<I>X</I>
dans &#X2124;/<I>p</I>&#X2124;.</P><P>Réciproquement, si on se donne un facteur irréductible <I>F</I> qui divise
<I>X</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>&#X2212;<I>X</I>, soit <I>K</I> le corps correspondant à <I>F</I>, 
alors le noyau de l&#X2019;application linéaire
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I> &#X2208; <I>K</I> &#X21A6; <I>x</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>&#X2212;<I>x</I> &#X2208; <I>K</I> </TD></TR>
</TABLE><P>
est <I>K</I> tout entier, car <I>Y</I>=<I>Y</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP> (mod <I>F</I> )
entraine (<I>Y</I><SUP>2</SUP>)<SUP>(<I>p</I><SUP><I>k</I></SUP>)</SUP>=<I>Y</I><SUP>2 <I>p</I><SUP><I>k</I></SUP></SUP>=(<I>Y</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>)<SUP>2</SUP>=<I>Y</I><SUP>2</SUP> (mod <I>F</I> ) et de même
pour les autres puissances de <I>Y</I> qui, avec <I>Y</I><SUP>0</SUP>=1 également dans le
noyau, forment une base de l&#X2019;espace vectoriel <I>K</I> sur &#X2124;/<I>p</I>&#X2124;. Donc le
nombre d&#X2019;éléments de <I>K</I> est inférieur ou égal au degré du polynôme
<I>X</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>&#X2212;<I>X</I> (puisque <I>X</I><SUP>(<I>p</I><SUP><I>k</I></SUP>)</SUP>&#X2212;<I>X</I> est divisible par
<I>X</I>&#X2212;<I>x</I> pour tout <I>x</I>&#X2208; <I>K</I>),
donc le degré de <I>F</I> est inférieur ou égal à <I>k</I>.</P><P>Donc <I>P</I><SUB><I>k</I></SUB> est égal au pgcd de <I>P</I>/&#X3A0;<SUB><I>j</I>&lt;<I>k</I></SUB> <I>P</I><SUB><I>j</I></SUB> avec <I>X</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>&#X2212;<I>X</I>.</P><P><B>Algorithme distinct degree factorization</B><BR>
Argument: un polynôme <I>P</I> à coefficients entiers 
sans facteur multiple et primitif.<BR>
Valeur renvoyée: la liste <I>L</I> des produits des facteurs irréductibles et du
degré correspondant de <I>P</I> (ordonné par ordre croissant de degré).<BR>
On commence par initialiser <I>L</I> à vide et un polynôme auxiliaire <I>Q</I> à <I>X</I>
(il contiendra les valeurs de <I>X</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>&#X2212;<I>X</I> (mod <I>P</I> )), on fait une boucle
indéfinie sur <I>k</I> commençant à 1 et incrémenté de 1 à chaque itération
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>k</I> est strictement plus grand que le degré de <I>P</I> divisé par 2,
on rajoute le couple (<I>P</I>,degre(<I>P</I>)) à <I>L</I> et on renvoie <I>L</I>
</LI><LI CLASS="li-itemize">On remplace <I>Q</I> par <I>Q</I><SUP><I>p</I></SUP> (mod <I>P</I> ) en utilisant le calcul de &#X3D5;
modulo <I>P</I>
</LI><LI CLASS="li-itemize">On calcule le pgcd <I>G</I> de <I>Q</I>&#X2212;<I>X</I> et de <I>P</I>. 
</LI><LI CLASS="li-itemize">Si <I>G</I> vaut 1, on passe à l&#X2019;itération suivante
</LI><LI CLASS="li-itemize">On rajoute le couple (<I>G</I>,<I>k</I>) à la liste <I>L</I> et on remplace <I>P</I>
par le quotient de <I>P</I> par <I>G</I>.
</LI></UL><P><B>Exemple</B> :<BR>
Factorisation en degré distincts de (<I>X</I><SUP>3</SUP>+<I>X</I>+1)(<I>X</I><SUP>4</SUP>&#X2212;<I>X</I>+1) dans
&#X2124;/5&#X2124;. On regarde d&#X2019;abord si <I>P</I> reste sans facteur multiple après
réduction modulo 5.
</P><PRE CLASS="verbatim">P:=normal((x^3+x+1)*(x^4-x+1) mod 5);
gcd(P,diff(P,x));
    1 mod 5  -&gt; ok P est sans facteur multiple
P1:=gcd(P,(x^5-x)mod 5);
    (1 mod 5)*x -2 mod 5  -&gt; P1
P:=normal(P/P1);
P2:=gcd(P,(x^(5^2)-x)mod 5);
    1 mod 5  -&gt; pas de facteur de degre 2
P3:=gcd(P,(x^(5^3)-x)mod 5);
    (x^6+2*x^5+x^2+x+2) mod 5
</PRE><P>Donc <I>P</I> admet 3 facteurs dans &#X2124;/5&#X2124;: un de degré 1 (<I>x</I>&#X2212;2) et
deux de degré 3 (dont le produit est <I>x</I><SUP>6</SUP>+2<I>x</I><SUP>5</SUP>+<I>x</I><SUP>2</SUP>+<I>x</I>+2).</P><P>Le même calcul dans &#X2124;/7&#X2124; donne
</P><PRE CLASS="verbatim">P:=normal((x^3+x+1)*(x^4-x+1) mod 7);
gcd(P,diff(P,x));
    1 mod 7  -&gt; ok P est sans facteur multiple
P1:=gcd(P,(x^7-x)mod 7);
    1 mod 7
P2:=gcd(P,(x^(7^2)-x)mod 7);
    1 mod 7
P3:=gcd(P,(x^(7^3)-x)mod 7);
    (x^3+x+1) mod 7
</PRE><P>donc <I>P</I> possède un facteur de degré 3 modulo 7, donc le facteur restant
de degré 4 est forcément irréductible.</P><P>On remarque sur cet exemple que 7 est plus intéressant que 5, car
la factorisation modulo 7 donne moins de facteurs (à recombiner pour
trouver la factorisation dans &#X2124;) et la factorisation est
complète modulo 7 alors que modulo 5 il faut casser le facteur de
degré 6 en deux facteurs de degré 3. La plupart des algorithmes
de factorisation effectuent la factorisation en degré distinct
modulo plusieurs entiers (ce qui peut de plus être parallélisé)
et choisissent le meilleur.</P><!--TOC subsubsection La méthode de Cantor-Zassenhaus-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc43">8.2.3</A>  La méthode de Cantor-Zassenhaus</H4><!--SEC END --><P>Cet algorithme sert à casser des groupes de facteurs de même degré,
c&#X2019;est une méthode probabiliste. On suppose donc qu&#X2019;on a un produit <I>P</I>
d&#X2019;au moins deux facteurs irréductibles de degré <I>d</I> à casser.
Soit <I>D</I> l&#X2019;un des polynômes irréductibles de degré <I>d</I> à coefficients
dans &#X2124;/<I>p</I>&#X2124;, et soit <I>K</I>=&#X2124;/<I>p</I>&#X2124;[<I>Y</I>] (mod <I>D</I>(<I>Y</I>) ), on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>X</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>&#X2212;<I>X</I>=&#X3A0;<SUB>&#X3B1; &#X2208; <I>K</I> </SUB>(<I>X</I>&#X2212;&#X3B1;) </TD></TR>
</TABLE><P>
puisque le corps <I>K</I> possède <I>p</I><SUP><I>d</I></SUP> éléments tous racines
de l&#X2019;équation <I>X</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>=<I>X</I>.</P><P>On considère un polynôme <I>T</I> non constant, et le polynôme
<I>T</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>&#X2212;<I>T</I>. En remplaçant <I>X</I> par <I>T</I> ci-dessus, on en déduit :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>T</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>&#X2212;<I>T</I>=&#X3A0;<SUB>&#X3B1; &#X2208; <I>K</I> </SUB>(<I>T</I>&#X2212;&#X3B1;) </TD></TR>
</TABLE><P>
Donc pour tout élément &#X3B2; &#X2208; <I>K</I>=&#X2124;/<I>p</I>&#X2124;[<I>Y</I>] (mod <I>D</I>(<I>Y</I>) ), on a
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>T</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>&#X2212;<I>T</I>)(&#X3B2;)=&#X3A0;<SUB>&#X3B1; &#X2208; <I>K</I> </SUB>(<I>T</I>(&#X3B2;)&#X2212;&#X3B1;)=0</TD></TR>
</TABLE><P>
Donc <I>T</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>&#X2212;<I>T</I> est divisible par <I>X</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>&#X2212;<I>X</I> (puisque toutes les racines
du second sont racines du premier), donc est divisible par tout polynôme
irréductible de degré inférieur ou égal à <I>d</I> à coefficients dans <I>Z</I>/<I>p</I>&#X2124;.
Comme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:cantor"></A>
<I>T</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>&#X2212;<I>T</I>=<I>T</I>(<I>T</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>d</I></SUP>&#X2212;1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X2212;1)(<I>T</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>d</I></SUP>+1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X2212;1)
    (11)</TD></TR>
</TABLE><P>
et que ces trois facteurs sont premiers entre eux, on en déduit que tout 
polynôme irréductible de degré inférieur ou égal à <I>d</I> à coefficients dans 
<I>Z</I>/<I>p</I>&#X2124; divise l&#X2019;un des trois facteurs ci-dessus. Pour casser <I>P</I>, l&#X2019;idée
consiste alors à calculer le pgcd de <I>P</I> et <I>T</I><SUP><I>p</I><SUP><I>d</I></SUP>&#X2212;1/2</SUP>&#X2212;1
pour un polynôme pris au hasard. On sait que <I>P</I> divise le produit des
3 termes de (<A HREF="#eq:cantor">11</A>), et on espère que les facteurs irréductibles
de <I>P</I> ne diviseront pas tous le même terme.</P><P>On va montrer que si <I>T</I> est un polynôme de degré &#X2264; 2<I>d</I>&#X2212;1 choisi au hasard,
la probabilité que deux facteurs irréductibles de <I>P</I> ne divisent pas 
<I>T</I><SUP><I>p</I><SUP><I>d</I></SUP></SUP>&#X2212;<I>T</I> est proche de 0.5. Soient donc <I>A</I> et <I>B</I> deux facteurs
irréductibles de <I>P</I> de degré <I>d</I>. D&#X2019;après l&#X2019;identité de Bézout, tout 
polynôme <I>T</I> de degré &#X2264; 2<I>d</I>&#X2212;1 s&#X2019;écrit de manière unique sous la forme :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:bezout2"></A> 
<I>T</I> = <I>A</I> <I>U</I> + <I>B</I> <I>V</I> 
    (12)</TD></TR>
</TABLE><P>
avec degre(<I>U</I> &#X2264; <I>d</I>&#X2212;1) et degre(<I>V</I> &#X2264; <I>d</I>&#X2212;1) et réciproquement 
une combinaison linéaire de cette forme est un polynôme de degré &#X2264; 2<I>d</I>&#X2212;1.
Choisir <I>T</I> au hasard revient donc à choisir un couple (<I>U</I>,<I>V</I>) de polynômes
à coefficients dans &#X2124;/<I>p</I>&#X2124; au hasard et
de manière indépendante. D&#X2019;autre part, <I>A</I> et <I>B</I> étant de degré <I>d</I>, on
sait que dans <I>K</I>=&#X2124;/<I>p</I>&#X2124;[<I>Y</I>] (mod <I>D</I>(<I>Y</I>) ) ces polynômes admettent <I>d</I> racines.
Soit donc &#X3B1; [respectivement &#X3B2;] une racine de <I>A</I> [resp. <I>B</I>]
dans <I>K</I>. Alors <I>A</I> divise <I>T</I><SUP><I>p</I><SUP><I>d</I></SUP>&#X2212;1/2</SUP>&#X2212;1
si et seulement si <I>T</I>(&#X3B1; )<SUP><I>p</I><SUP><I>d</I></SUP>&#X2212;1/2</SUP>=1 (et de même pour
<I>B</I> et &#X3B2;) car <I>T</I><SUP><I>p</I><SUP><I>d</I></SUP>&#X2212;1/2</SUP>&#X2212;1 a ses coefficients dans
&#X2124;/<I>p</I>&#X2124; (et non dans <I>K</I>). 
En appliquant (<A HREF="#eq:bezout2">12</A>), <I>A</I> divise <I>T</I><SUP><I>p</I><SUP><I>d</I></SUP>&#X2212;1/2</SUP>&#X2212;1
si et seulement si :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>B</I>(&#X3B1; )</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>d</I></SUP>&#X2212;1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell"><I>V</I>(&#X3B1; )</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>d</I></SUP>&#X2212;1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="dcell">&nbsp;</TD></TR>
</TABLE></TD><TD CLASS="dcell">=1 </TD></TR>
</TABLE><P>
Le premier terme de cette égalité est une constante égale à 1 ou -1, 
le second a une probabilité proche de 0.5 (égale à <I>p</I><SUP><I>d</I></SUP>&#X2212;1/2<I>p</I><SUP><I>d</I></SUP>)
de valoir 1 ou -1 car, comme <I>A</I> est irréductible,
<I>V</I>(&#X3B1;) décrit <I>K</I> lorsque <I>V</I> décrit les 
polynômes de degré &#X2264; <I>d</I>&#X2212;1.
De même, <I>B</I> a une probabilité proche de 0.5 de diviser 
<I>T</I><SUP><I>p</I><SUP><I>d</I></SUP>&#X2212;1/2</SUP>&#X2212;1, et ces 2 probabilités sont indépendantes
puisque <I>U</I> et <I>V</I> le sont, donc la probabilité que soit <I>A</I> soit <I>B</I> divise
divise <I>T</I><SUP><I>p</I><SUP><I>d</I></SUP>&#X2212;1/2</SUP>&#X2212;1 est proche de 0.5.</P><P><B>Algorithme de Cantor-Zassenhaus</B><BR>
Argument: Un polynôme <I>P</I> à coefficients dans &#X2124;/<I>p</I>&#X2124; de degré <I>k</I>
dont tous les facteurs irréductibles sont de degré <I>d</I>.<BR>
Valeur renvoyée: la liste des facteurs irréductibles de <I>P</I>.<BR>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>k</I>=<I>d</I> renvoyer une liste contenant <I>P</I>.
</LI><LI CLASS="li-itemize">Déterminer un polynôme <I>T</I> aléatoire de degré inférieur ou égal
à 2<I>d</I>&#X2212;1 et de coefficient dominant 1. Calculer le pgcd <I>D</I> de <I>P</I>
et de <I>T</I><SUP>(<I>p</I><SUP><I>d</I></SUP>&#X2212;1)/2</SUP>&#X2212;1. Si le degré de <I>T</I> est égal à 0 ou à <I>k</I> 
recommencer cette étape.
</LI><LI CLASS="li-itemize">Appeler récursivement cet algorithme avec <I>T</I> et <I>P</I>/<I>T</I> et
renvoyer la liste réunion des deux listes renvoyées.
</LI></UL><P><B>Exemple</B> :<BR>
Cassons le polynôme de degré 6 obtenu dans l&#X2019;exemple précédent
(modulo 5). Donc <I>P</I>:=(<I>x</I><SUP>6</SUP>+2*<I>x</I><SUP>5</SUP>+<I>x</I><SUP>2</SUP>+<I>x</I>+2) (mod 5 ) et <I>d</I>=3, 2<I>d</I>&#X2212;1=5,
(<I>p</I><SUP><I>d</I></SUP>&#X2212;1)/2=62.
On choisit au hasard un polynôme de degré inférieur ou égal à 5, par exemple
<I>T</I>=<I>x</I><SUP>4</SUP>&#X2212;<I>x</I><SUP>3</SUP>+<I>x</I>+1, puis on calcule <I>T</I><SUP>62</SUP> modulo <I>P</I> ce qui donne
(<I>x</I><SUP>5</SUP>+<I>x</I><SUP>3</SUP>+<I>x</I><SUP>2</SUP>+1) (mod 5 ) puis le pgcd de <I>T</I><SUP>62</SUP>&#X2212;1 et de <I>P</I>
qui vaut <I>x</I><SUP>3</SUP>+<I>x</I>+1 (mod 5 ), on a donc cassé <I>P</I> en deux. 
En prenant <I>T</I>:=<I>x</I><SUP>4</SUP>&#X2212;<I>x</I><SUP>3</SUP>+<I>x</I>+2, on trouve <I>T</I><SUP>62</SUP>=1 (mod <I>P</I> ), donc
ce <I>T</I> n&#X2019;aurait pas permis de casser <I>P</I>.</P><!--TOC subsubsection La méthode de Berlekamp-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc44">8.2.4</A>  La méthode de Berlekamp</H4><!--SEC END --><P>
Cette méthode permet de factoriser un polynôme sans facteurs multiples,
elle peut aussi servir à casser des groupes de facteurs de même degré.
Ici on travaille dans l&#X2019;anneau des polynômes à coefficients dans &#X2124;/<I>p</I>&#X2124;
modulo le polynôme <I>P</I> et on s&#X2019;intéresse au noyau de &#X3D5;&#X2212;<I>Id</I>
(où &#X3D5;: <I>x</I> &#X21A6; <I>x</I><SUP><I>p</I></SUP>). On
suppose que <I>P</I>=&#X3A0;<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>F</I><SUB><I>j</I></SUB> où les <I>F</I><SUB><I>j</I></SUB> sont irréductibles et
premiers entre eux. On va montrer que le noyau de &#X3D5;&#X2212;<I>Id</I> est
composé des polynômes <I>Q</I> tels que <I>Q</I> (mod <I>F</I><SUB><I>j</I></SUB> ) est constant
(dans &#X2124;/<I>p</I>&#X2124;) pour tout <I>j</I>.</P><P>Si <I>Q</I> (mod <I>F</I><SUB><I>j</I></SUB> )=<I>s</I><SUB><I>j</I></SUB> &#X2208; &#X2124;/<I>p</I>&#X2124;, alors <I>Q</I><SUP><I>p</I></SUP> (mod <I>F</I><SUB><I>j</I></SUB> )=<I>s</I><SUB><I>j</I></SUB><SUP><I>p</I></SUP>=<I>s</I><SUB><I>j</I></SUB>, donc
par le théorème des restes chinois, <I>Q</I>=<I>Q</I><SUP><I>p</I></SUP> (mod <I>P</I> ). </P><P>Réciproquement, si
<I>Q</I><SUP><I>p</I></SUP>&#X2212;<I>Q</I>=0 (mod <I>P</I> ), en utilisant la factorisation :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>X</I><SUP><I>p</I></SUP>&#X2212;<I>X</I>= &#X3A0;<SUB><I>j</I> &#X2208; &#X2124;/<I>p</I>&#X2124; </SUB> (<I>X</I>&#X2212;<I>j</I>)</TD></TR>
</TABLE><P>
on en tire <I>P</I> divise <I>Q</I><SUP><I>p</I></SUP>&#X2212;<I>Q</I>=&#X3A0;<SUB><I>j</I> &#X2208; &#X2124;/<I>p</I>&#X2124; </SUB> (<I>Q</I>(<I>X</I>)&#X2212;<I>j</I>),
donc <I>F</I><SUB><I>j</I></SUB> divise l&#X2019;un des facteurs et <I>Q</I>(<I>X</I>) (mod <I>F</I><SUB><I>j</I></SUB> ) &#X2208; &#X2124;/<I>p</I>&#X2124;.
Le noyau de &#X3D5; &#X2212;<I>Id</I>
est donc un espace vectoriel de dimension <I>n</I>, le nombre
de facteurs irréductibles de <I>P</I> et possède donc <I>p</I><SUP><I>n</I></SUP> éléments
(en effet pour tout <I>n</I> uplet de <I>s</I><SUB><I>j</I></SUB>, on peut construire un polynôme
<I>Q</I> du noyau par le théorème des restes chinois en posant <I>Q</I>(mod <I>F</I><SUB><I>j</I></SUB> )=<I>s</I><SUB><I>j</I></SUB>).</P><P>L&#X2019;intérêt du noyau de &#X3D5;&#X2212;<I>Id</I> est qu&#X2019;on peut le calculer sans connaitre
les <I>F</I><SUB><I>j</I></SUB>. Une fois ce calcul fait, voyons comment on peut remonter 
aux <I>F</I><SUB><I>j</I></SUB>. On connait déjà la dimension du noyau donc le nombre de facteurs
irréductibles. De plus, on remarque que le polynome constant est un
élément du noyau qu&#X2019;on appellera <I>T</I><SUB>1</SUB>, on note alors <I>T</I><SUB>2</SUB>,...,<I>T</I><SUB><I>n</I></SUB> les
autres polynômes du noyau. Ensuite, on calcule le pgcd de <I>P</I> avec <I>T</I><SUB>2</SUB>&#X2212;<I>jT</I><SUB>1</SUB>
pour <I>j</I>&#X2208; &#X2124;/<I>p</I>&#X2124;. On sait que <I>T</I><SUB>2</SUB>=<I>s</I><SUB>2,<I>j</I></SUB> (mod <I>F</I><SUB><I>j</I></SUB> ), donc ce pgcd
est égal au produit des facteurs <I>F</I><SUB><I>j</I></SUB> tels que <I>s</I><SUB>2,<I>j</I></SUB>=<I>jT</I><SUB>1</SUB>. L&#X2019;un au moins
des pgcd calculés est non trivial car sinon <I>T</I><SUB>2</SUB>=<I>T</I><SUB>1</SUB> (mod <I>F</I><SUB><I>j</I></SUB> ) pour
tout <I>j</I> donc <I>T</I><SUB>2</SUB>=<I>T</I><SUB>1</SUB>. Si on a de la chance tous les <I>s</I><SUB>2,<I>j</I></SUB> seront
distincts et les pgcd non triviaux de <I>P</I> avec <I>T</I><SUB>2</SUB>&#X2212;<I>jT</I><SUB>1</SUB> donneront les <I>F</I><SUB><I>k</I></SUB>.
Sinon il faudra continuer avec <I>T</I><SUB>3</SUB>&#X2212;<I>jT</I><SUB>1</SUB> etc.</P><P><B>Exemple</B> :<BR>
Revenons sur la factorisation de <I>P</I>:=(<I>x</I><SUP>6</SUP>+2<I>x</I><SUP>5</SUP>+<I>x</I><SUP>2</SUP>+<I>x</I>+2) (mod 5 ).
Commençons par calculer la matrice de &#X3D5; dans la base
{ 1,<I>x</I>,<I>x</I><SUP>2</SUP>,...,<I>x</I><SUP>5</SUP>}. On a évidemment &#X3D5;(1)=1 et
&#X3D5;(<I>x</I>)=<I>x</I><SUP>5</SUP>, puis &#X3D5;(<I>x</I><SUP>2</SUP>)=<I>x</I><SUP>10</SUP>=<I>x</I><SUP>5</SUP>+<I>x</I><SUP>4</SUP>&#X2212;2<I>x</I><SUP>3</SUP>+<I>x</I> (mod <I>P</I> ),
puis en multipliant par <I>x</I><SUP>5</SUP> et en divisant par <I>P</I>,
&#X3D5;(<I>x</I><SUP>3</SUP>)=&#X2212;<I>x</I><SUP>4</SUP>+2<I>x</I><SUP>3</SUP>, de la même manière on obtient 
&#X3D5;(<I>x</I><SUP>4</SUP>)=&#X2212;<I>x</I><SUP>5</SUP>+2<I>x</I><SUP>4</SUP>+<I>x</I><SUP>3</SUP>&#X2212;<I>x</I><SUP>2</SUP>&#X2212;2 et &#X3D5;(<I>x</I><SUP>5</SUP>)=<I>x</I><SUP>3</SUP>+<I>x</I><SUP>2</SUP>&#X2212;<I>x</I>.
La matrice de &#X3D5; est donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I>=</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>&#X2212;2</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>&#X2212;2</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>0</TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
On calcule ensuite le noyau de &#X3D5;&#X2212;<I>Id</I> (comme matrice à coefficients
dans &#X2124;/5&#X2124;), on obtient une
base du noyau en prenant par exemple les vecteurs (&#X2212;1,0,0,0,0,0)
et (0,0,&#X2212;1,&#X2212;1,0,&#X2212;1). Donc le polynôme <I>P</I> possède 2 facteurs dans
&#X2124;/5&#X2124;[<I>X</I>]. Pour déterminer les facteurs, on calcule le pgcd de <I>P</I>
avec le polynôme <I>T</I><SUB>2</SUB>&#X2212;<I>s</I> où <I>T</I><SUB>2</SUB>=&#X2212;<I>x</I><SUP>5</SUP>&#X2212;<I>x</I><SUP>3</SUP>&#X2212;<I>x</I><SUP>2</SUP> correspond au 2ème
vecteur de la base du noyau. On obtient pour <I>s</I>=0 un pcgd non trivial
(<I>x</I><SUP>3</SUP>+<I>x</I>+1), ce qui permet de calculer les 2 facteurs. Si on avait
essayé d&#X2019;autres valeurs de <I>s</I>, pour <I>s</I>=1 on obtient comme pgcd 1, pour
<I>s</I>=2 on trouve le 2ème facteur <I>x</I><SUP>3</SUP>+2<I>x</I><SUP>2</SUP>&#X2212;<I>x</I>+2.</P><!--TOC subsubsection Remontée (Hensel)-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc45">8.2.5</A>  Remontée (Hensel)</H4><!--SEC END --><P>
Il s&#X2019;agit de passer d&#X2019;une factorisation de <I>P</I> dans &#X2124;/<I>p</I>&#X2124;[<I>X</I>] à une
factorisation de <I>P</I> dans &#X2124;/<I>p</I><SUP><I>k</I></SUP> <I>Z</I>[<I>X</I>], la méthode est analogue à celle
de l&#X2019;algorithme EZGCD de calcul de pgcd de polynômes.</P><P>On suppose donc que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>=&#X3A0;<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>j</I></SUB> (mod <I>p</I> ) </TD></TR>
</TABLE><P>
où les <I>P</I><SUB><I>j</I></SUB> sont premiers entre eux deux à deux dans &#X2124;/<I>p</I>&#X2124;.
Il s&#X2019;agit de trouver des polynômes <I>P</I><SUB><I>j</I>,<I>k</I></SUB>=<I>P</I><SUB><I>j</I></SUB> (mod <I>p</I> ) tels que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>=&#X3A0;<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>j</I>,<I>k</I></SUB> (mod <I>p</I><SUP><I>k</I></SUP> ) </TD></TR>
</TABLE><P>
Commençons par le cas <I>k</I>=2. On pose
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB><I>j</I>,2</SUB>=<I>P</I><SUB><I>j</I></SUB>+<I>pQ</I><SUB><I>j</I></SUB>=<I>P</I><SUB><I>j</I></SUB> (mod <I>p</I> ) </TD></TR>
</TABLE><P>
On a alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>P</I></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>&#X3A0;<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>j</I>,2</SUB> (mod <I>p</I><SUP>2</SUP> ) =&#X3A0;<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> (<I>P</I><SUB><I>j</I></SUB>+<I>pQ</I><SUB><I>j</I></SUB>) (mod <I>p</I><SUP>2</SUP> )</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">&#X3A0;<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>j</I></SUB> + <I>p</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> &#X3A0;<SUB><I>k</I>&#X2260; <I>j</I></SUB> <I>P</I><SUB><I>k</I></SUB> (mod <I>p</I><SUP>2</SUP> ) </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> &#X3A0;<SUB><I>k</I>&#X2260; <I>j</I></SUB> <I>P</I><SUB><I>k</I></SUB>= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I>&#X2212;&#X3A0;<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>j</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>p</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (mod <I>p</I> ) </TD></TR>
</TABLE><P>
On est ramené à résoudre une identité de Bézout généralisée.
On montrera dans l&#X2019;appendice le :
</P><DIV CLASS="theorem"><B>Théorème 4</B>  <EM> (Identité de Bézout généralisée)
Soit </EM><EM><I>P</I></EM><SUB><EM>1</EM></SUB><EM>, ..., </EM><EM><I>P</I></EM><SUB><EM><I>n</I></EM></SUB><EM> (</EM><EM><I>n</I>&#X2265; 2</EM><EM>) des polynômes premiers entre eux deux 
à deux modulo </EM><EM><I>p</I></EM><EM>. Alors pour tout polynôme </EM><EM><I>Q</I></EM><EM>, il existe des polynômes 
</EM><EM><I>Q</I></EM><SUB><EM>1</EM></SUB><EM>, ..., </EM><EM><I>Q</I></EM><SUB><EM><I>n</I></EM></SUB><EM> tels que :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><EM><I>n</I></EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><FONT SIZE=6>&#X2211;</FONT></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><EM><I>j</I>=1</EM></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> <I>Q</I></EM><SUB><EM><I>j</I></EM></SUB><EM> &#X3A0;</EM><SUB><EM><I>k</I>&#X2260; <I>j</I></EM></SUB><EM> <I>P</I></EM><SUB><EM><I>k</I></EM></SUB><EM>=<I>Q</I> </EM><EM>(mod </EM><EM><I>p</I></EM><EM> )</EM><EM> </EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>On a donc réussi à remonter l&#X2019;égalité <I>P</I>=&#X3A0; <I>P</I><SUB><I>j</I></SUB> (mod <I>p</I> ) à 
<I>P</I>=&#X3A0; <I>P</I><SUB><I>j</I>,2</SUB> (mod <I>p</I><SUP>2</SUP> ). Le passage de <I>P</I>=&#X3A0; <I>P</I><SUB><I>j</I>,<I>l</I></SUB> (mod <I>p</I><SUP><I>l</I></SUP> )
à <I>P</I>=&#X3A0; <I>P</I><SUB><I>j</I>,<I>l</I>+1</SUB> (mod <I>p</I><SUP><I>l</I>+1</SUP> ) est identique, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB><I>j</I>,<I>l</I>+1</SUB>=<I>P</I><SUB><I>j</I>,<I>l</I></SUB>+<I>p</I><SUP><I>l</I></SUP><I>Q</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
où les <I>Q</I><SUB><I>j</I></SUB> sont les solutions de l&#X2019;identité de Bézout généralisée avec :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Q</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I>&#X2212;&#X3A0;<SUB><I>j</I>=1</SUB><SUP><I>n</I></SUP> <I>P</I><SUB><I>j</I>,<I>l</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>l</I></SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Lorsqu&#X2019;on programme cet algorithme (cf. l&#X2019;appendice), 
on calcule une fois pour toutes les
solutions de l&#X2019;identité de Bézout pour <I>Q</I>=1, et on multiplie par <I>Q</I>.</P><P><B>Algorithme de remontée de Hensel linéaire</B><BR>
Arguments: Un polynôme <I>P</I> à coefficients entiers, la liste <I>L</I>={ <I>P</I><SUB><I>j</I></SUB> } 
de ses facteurs dans &#X2124;/<I>p</I>&#X2124;[<I>X</I>]<BR>
Valeur renvoyée: la liste des facteurs de <I>P</I> dans &#X2124;/<I>p</I><SUP><I>l</I></SUP> &#X2124;[<I>X</I>]<BR>
On calcule la borne de Landau-Mignotte<SUP><A NAME="text6" HREF="#note6">6</A></SUP> 
pour les facteurs de <I>P</I>, on multiplie
par le coefficient dominant de <I>P</I> et on calcule <I>l</I> tel que <I>p</I><SUP><I>l</I></SUP> est
strictement plus grand que deux fois cette quantité. On calcule
aussi les polynômes <I>Q</I><SUB><I>j</I></SUB> de l&#X2019;identité de Bézout généralisée pour <I>Q</I>=1<BR>
Puis on fait une boucle pour <I>k</I> variant de 2 à <I>l</I>:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
On détermine <I>P</I>&#X2212;&#X3A0;<SUB><I>j</I></SUB> <I>P</I><SUB><I>j</I></SUB> (mod <I>p</I><SUP><I>k</I></SUP> ), on divise par <I>p</I><SUP><I>k</I>&#X2212;1</SUP>
et on place le résultat dans <I>Q</I>
</LI><LI CLASS="li-itemize">On multiplie les polynômes <I>Q</I><SUB><I>j</I></SUB> de l&#X2019;identité de Bézout 
généralisée (correspondants au polynôme 1) par <I>Q</I>
et on détermine le reste de la division euclidienne de <I>Q</I> <I>Q</I><SUB><I>j</I></SUB> par <I>P</I><SUB><I>j</I></SUB>,
on multiplie par <I>p</I><SUP><I>k</I>&#X2212;1</SUP> et on ajoute le résultat à <I>P</I><SUB><I>j</I></SUB>.
</LI></UL><P>Il existe une version quadratique de cette méthode. On passe alors de
<I>P</I>=&#X3A0; <I>P</I><SUB><I>j</I>,<I>l</I></SUB> (mod <I>p</I><SUP><I>l</I></SUP> ) à <I>P</I>=&#X3A0; <I>P</I><SUB><I>j</I>,2<I>l</I></SUB> (mod <I>p</I><SUP>2<I>l</I></SUP> ). Pour
cela, il faut trouver les polynômes <I>Q</I><SUB><I>j</I></SUB> solutions de l&#X2019;équation :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> &#X3A0;<SUB><I>k</I>&#X2260; <I>j</I></SUB> <I>P</I><SUB><I>k</I>,<I>l</I></SUB>=<I>Q</I> (mod <I>p</I><SUP><I>l</I></SUP> )</TD></TR>
</TABLE><P>
Pour <I>l</I>=1, c&#X2019;est l&#X2019;identité de Bézout généralisée, mais ce n&#X2019;est plus le
cas pour <I>l</I>&gt;1. En fait, on résout cette égalité en remontant l&#X2019;identité
de Bézout quadratiquement, plus précisément pour trouver les <I>S</I><SUB><I>j</I></SUB>
solutions de
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>S</I><SUB><I>j</I></SUB> &#X3A0;<SUB><I>k</I>&#X2260; <I>j</I></SUB> <I>P</I><SUB><I>k</I>,2<I>l</I></SUB>=<I>Q</I> (mod <I>p</I><SUP>2<I>l</I></SUP> )</TD></TR>
</TABLE><P>
on pose <I>S</I><SUB><I>j</I></SUB>=<I>Q</I><SUB><I>j</I></SUB>+<I>p</I><SUP><I>l</I></SUP> <I>R</I><SUB><I>j</I></SUB>, il s&#X2019;agit donc de trouver les <I>R</I><SUB><I>j</I></SUB> solutions de
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>Q</I><SUB><I>j</I></SUB>+<I>p</I><SUP><I>l</I></SUP> <I>R</I><SUB><I>j</I></SUB>) &#X3A0;<SUB><I>k</I>&#X2260; <I>j</I></SUB> <I>P</I><SUB><I>k</I>,2<I>l</I></SUB>=<I>Q</I> (mod <I>p</I><SUP>2<I>l</I></SUP> )</TD></TR>
</TABLE><P>
soit :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>R</I><SUB><I>j</I></SUB> &#X3A0;<SUB><I>k</I>&#X2260; <I>j</I></SUB> <I>P</I><SUB><I>k</I>,<I>l</I></SUB>
=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>Q</I>&#X2212;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> &#X3A0;<SUB><I>k</I>&#X2260; <I>j</I></SUB> <I>P</I><SUB><I>k</I>,<I>l</I></SUB> </TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>l</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (mod <I>p</I><SUP><I>l</I></SUP> )</TD></TR>
</TABLE><P>
on en déduit les <I>R</I><SUB><I>j</I></SUB>.</P><P><B>Algorithme de remontée de Hensel quadratique</B><BR>
Arguments et valeur renvoyée identiques à l&#X2019;algorithme de remontée de Hensel
linéaire ci-dessus.<BR>
On commence comme dans le cas linéaire par calculer les coefficients
de l&#X2019;identité de Bézout généralisée pour <I>Q</I>=1 et la valeur de <I>l</I> telle
que <I>p</I><SUP>2<SUP><I>l</I></SUP></SUP> soit supérieur à deux fois la borne de Landau des facteurs
de <I>P</I> fois le coefficient dominant de <I>P</I>.<BR>
On fait une boucle sur <I>k</I> variant de 1 à <I>l</I>:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
On calcule <I>P</I>&#X2212;&#X3A0;<SUB><I>j</I></SUB> <I>P</I><SUB><I>j</I></SUB> (mod <I>p</I><SUP>2<SUP><I>k</I></SUP></SUP> ), on divise par <I>p</I><SUP>2<SUP><I>k</I>&#X2212;1</SUP></SUP>
et on place le résultat dans <I>Q</I>
</LI><LI CLASS="li-itemize">On multiplie par <I>Q</I> les polynômes <I>Q</I><SUB><I>j</I></SUB> de l&#X2019;identité de Bézout
généralisée (avec comme second membre le polynôme 1),
on calcule le reste euclidien du résultat par <I>P</I><SUB><I>j</I></SUB> (modulo <I>p</I><SUP>2<SUP><I>k</I>&#X2212;1</SUP></SUP>), 
on multiplie par <I>p</I><SUP>2<SUP><I>k</I>&#X2212;1</SUP></SUP> et on ajoute à <I>P</I><SUB><I>j</I></SUB> (avec les notations
précédentes, on passe ainsi des <I>P</I><SUB><I>j</I>,2<SUP><I>k</I>&#X2212;1</SUP></SUB> aux <I>P</I><SUB><I>j</I>,2<SUP><I>k</I></SUP></SUB>)
</LI><LI CLASS="li-itemize">Si <I>k</I>=<I>l</I> on renvoie la liste des <I>P</I><SUB><I>j</I></SUB>
</LI><LI CLASS="li-itemize">On calcule 1&#X2212;&#X2211;<SUB><I>j</I></SUB> <I>Q</I><SUB><I>j</I></SUB> &#X3A0;<SUB><I>k</I>&#X2260; <I>j</I></SUB> <I>P</I><SUB><I>k</I></SUB> (mod <I>p</I><SUP>2<SUP><I>k</I></SUP></SUP> ), on
divise par <I>p</I><SUP>2<SUP><I>k</I>&#X2212;1</SUP></SUP> et on place le résultat dans <I>Q</I>
</LI><LI CLASS="li-itemize">On multiplie par <I>Q</I> les polynômes <I>Q</I><SUB><I>j</I></SUB> de l&#X2019;identité de Bézout,
généralisée et on calcule le reste euclidien du résultat par 
<I>P</I><SUB><I>j</I></SUB> (modulo <I>p</I><SUP>2<SUP><I>k</I>&#X2212;1</SUP></SUP>), on multiplie par <I>p</I><SUP>2<SUP><I>k</I>&#X2212;1</SUP></SUP> et 
on ajoute à <I>Q</I><SUB><I>j</I></SUB> (ce qui ajuste les polynômes <I>Q</I><SUB><I>j</I></SUB> qui vérifient
maintenant l&#X2019;identité de Bézout modulo <I>p</I><SUP>2<SUP><I>k</I></SUP></SUP>)
</LI></UL><P><B>Remarque</B><BR>
Pendant l&#X2019;étape de remontée de Hensel, une optimisation classique
consiste à tester la divisibilité dans &#X2124; du polynôme <I>P</I> par le 
facteur lifté <I>P</I><SUB><I>j</I></SUB> (<SUP><A NAME="text7" HREF="#note7">7</A></SUP>)
lorsqu&#X2019;il n&#X2019;a pas subi de modification pendant 2 étapes successives
(autrement dit lorsque <I>P</I><SUB><I>j</I></SUB> (mod <I>p</I><SUP><I>l</I></SUP> )=<I>P</I><SUB><I>j</I></SUB> (mod <I>p</I><SUP><I>l</I>+1</SUP> ) (ou
(mod <I>p</I><SUP>2<I>l</I></SUP> ) pour le lift quadratique). Si la division
est exacte, on obtient un facteur irréductible de <I>P</I> dans &#X2124;.
On recalcule alors la borne de Landau de <I>P</I>/<I>P</I><SUB><I>j</I></SUB> pour diminuer
le nombre d&#X2019;itérations à effectuer dans cette étape.</P><P><B>Exemple</B> :<BR>
Reprenons le polynôme <I>P</I>(<I>X</I>)=(<I>X</I><SUP>3</SUP>+<I>X</I>+1)(<I>X</I><SUP>4</SUP>&#X2212;<I>X</I>+1)
et supposons qu&#X2019;on ait choisi de le factoriser modulo 5 puis 
de remonter. On a 3 facteurs
<I>a</I>=<I>x</I>&#X2212;2, <I>b</I>=<I>x</I><SUP>3</SUP>+<I>x</I>+1 et <I>c</I>=<I>x</I><SUP>3</SUP>+2<I>x</I><SUP>2</SUP>&#X2212;<I>x</I>+2. Si on développe <I>P</I>, on trouve 6
coefficients non nuls de valeur absolue 1, 
on peut calculer la borne de Landau-Mignotte correspondante
sur les coefficients d&#X2019;un facteur entier : 2<SUP>5</SUP> (&#X221A;<SPAN style="text-decoration:overline">(</SPAN>6)+1)
soit un peu plus de 110, il suffit donc d&#X2019;effectuer 3 étapes de
remontée linéaire (5<SUP>4</SUP>=625&gt;111/2).
On commence par trouver 3 polynômes <I>A</I>, <I>B</I>, <I>C</I> tels que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>A</I>(<I>x</I><SUP>3</SUP>+<I>x</I>+1)(<I>x</I><SUP>3</SUP>+2<I>x</I><SUP>2</SUP>&#X2212;<I>x</I>+2)+<I>B</I>(<I>x</I>&#X2212;2)(<I>x</I><SUP>3</SUP>+2<I>x</I><SUP>2</SUP>&#X2212;<I>x</I>+2)+</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP>+<I>C</I>(<I>x</I>&#X2212;2)(<I>x</I><SUP>3</SUP>+<I>x</I>+1)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>1 (mod 5 )</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On commence par résoudre <I>D</I>(<I>x</I><SUP>3</SUP>+2<I>x</I><SUP>2</SUP>&#X2212;<I>x</I>+2)+<I>C</I>(<I>x</I>&#X2212;2)(<I>x</I><SUP>3</SUP>+<I>x</I>+1)=1(mod 5 ),
on trouve <I>C</I>=2<I>x</I><SUP>2</SUP>&#X2212;2 et <I>D</I>=&#X2212;2<I>x</I><SUP>3</SUP>&#X2212;2<I>x</I><SUP>2</SUP>+2<I>x</I>+1. Puis on calcule
<I>A</I> et <I>B</I> en résolvant <I>E</I>(<I>x</I><SUP>3</SUP>+<I>x</I>+1)+<I>F</I>(<I>x</I>&#X2212;2)=1 qui donne <I>E</I>=1 et 
<I>F</I>=&#X2212;<I>x</I><SUP>2</SUP>&#X2212;2<I>x</I> qu&#X2019;on multiplie par <I>D</I>, donc <I>A</I>=<I>D</I> et <I>B</I>=2<I>x</I><SUP>5</SUP>+<I>x</I><SUP>4</SUP>+2<I>x</I><SUP>3</SUP>&#X2212;2<I>x</I>.
Ce qui donne l&#X2019;identité de Bézout généralisée.</P><P>Passons aux calculs de remontée. On a <I>abc</I>=<I>x</I><SUP>7</SUP>&#X2212;4<I>x</I><SUP>5</SUP>+5<I>x</I><SUP>4</SUP>+&#X2212;9<I>x</I><SUP>3</SUP>&#X2212;<I>x</I><SUP>2</SUP>&#X2212;4
et <I>P</I>=<I>x</I><SUP>7</SUP>+<I>x</I><SUP>5</SUP>+<I>x</I><SUP>3</SUP>&#X2212;<I>x</I><SUP>2</SUP>+1, donc <I>Q</I>=(<I>P</I>&#X2212;<I>abc</I>)/5=<I>x</I><SUP>5</SUP>&#X2212;<I>x</I><SUP>4</SUP>+2<I>x</I><SUP>3</SUP>+1. On pose
alors 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>a</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>a</I>+5  (<I>QA</I> (mod <I>a</I> ))(mod 25 ), </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>b</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>b</I>+5  (<I>QB</I> (mod <I>b</I> )) (mod 25 ), </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>c</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>c</I>+5  (<I>QC</I> (mod <I>c</I> )) (mod 25 ) </TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB>1</SUB>= <I>a</I>+5 × (&#X2212;2),    <I>b</I><SUB>1</SUB>=<I>b</I>+5 × 0, 
   <I>c</I><SUB>1</SUB>=<I>c</I>+5 × (2<I>x</I><SUP>2</SUP>&#X2212;<I>x</I>) </TD></TR>
</TABLE><P>
En principe, on continue encore 2 itérations de la même manière.
La 2ème itération donne : 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Q</I>=(<I>P</I>&#X2212;<I>a</I><SUB>1</SUB> <I>b</I><SUB>1</SUB> <I>c</I><SUB>1</SUB>)/25= 6<I>x</I><SUP>5</SUP>&#X2212;3<I>x</I><SUP>4</SUP>+7<I>x</I><SUP>3</SUP>+3<I>x</I><SUP>2</SUP>&#X2212;2<I>x</I>+1</TD></TR>
</TABLE><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>a</I><SUB>2</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>a</I><SUB>1</SUB>+25  (<I>QA</I> (mod <I>a</I> )) (mod 125 ), </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>b</I><SUB>2</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>b</I><SUB>1</SUB>+25  (<I>QB</I> (mod <I>b</I> )) (mod 125 ),</TD></TR>
<TR><TD ALIGN=right NOWRAP><I>c</I><SUB>2</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>c</I><SUB>1</SUB>+25  (<I>QC</I> (mod <I>c</I> )) (mod 125 )</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB>2</SUB>=<I>a</I><SUB>1</SUB> +25(&#X2212;1)=<I>x</I>&#X2212;37,  <I>b</I><SUB>2</SUB>=<I>b</I><SUB>1</SUB>=<I>b</I>,  <I>c</I><SUB>2</SUB>=<I>c</I><SUB>1</SUB>+25(<I>x</I><SUP>2</SUP>+1) 
=<I>x</I><SUP>3</SUP>+37<I>x</I><SUP>2</SUP>&#X2212;6<I>x</I>+27 </TD></TR>
</TABLE><P>On peut aussi observer que <I>b</I><SUB>1</SUB>=<I>b</I>, ceci laisse à penser que <I>b</I> est 
un facteur de <I>P</I> dans &#X2124; ce qu&#X2019;on vérifie en effectuant la
division euclidienne de <I>P</I> par <I>b</I>=<I>x</I><SUP>3</SUP>+<I>x</I>+1. Comme elle tombe
juste, on est ramené à factoriser <I>x</I><SUP>4</SUP>&#X2212;<I>x</I>+1 et donc à remonter
la factorisation de <I>ac</I>. La borne de Landau diminue à 8(&#X221A;<SPAN style="text-decoration:overline">3</SPAN>+1)
puisque le degré est 4 et la norme euclidienne du polynôme est &#X221A;<SPAN style="text-decoration:overline">3</SPAN>.
Il suffit alors de remonter dans &#X2124;/125 &#X2124; au lieu de &#X2124;/625 &#X2124;
(on gagne ainsi une itération).</P><!--TOC subsubsection Combinaison de facteurs-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc46">8.2.6</A>  Combinaison de facteurs</H4><!--SEC END --><P>
Lorsqu&#X2019;on a les facteurs de <I>P</I> dans &#X2124;/<I>p</I><SUP><I>k</I></SUP>&#X2124;[<I>X</I>] avec <I>p</I><SUP><I>k</I></SUP> plus grand
que le produit du coefficient dominant de <I>P</I> multiplié par la borne
de Landau-Mignotte sur les coefficients de <I>P</I>, on commence par
tester la divisibilité dans &#X2124;[<I>X</I>] de <I>P</I> par chaque facteur trouvé
multiplié par le coefficient dominant de <I>P</I>. Si la division est
exacte, on a un facteur irréductible, mais si elle n&#X2019;est pas exacte
il peut se produire qu&#X2019;un facteur irréductible de <I>P</I> dans &#X2124;[<I>X</I>] soit un
produit de deux, voir plusieurs, facteurs modulaires. Il faut
donc tester la divisibilité de <I>P</I> dans &#X2124;[<I>X</I>] par toutes les combinaisons 
possibles de produits de facteurs modulaires (toujours multiplié par
le coefficient dominant de <I>P</I>). Cette étape peut être exponentiellement
longue si le nombre de facteurs modulaires est grand et si par
exemple <I>P</I> est irréductible, bien que les cas soient très rares. </P><P><B>Algorithme de recombinaison</B><BR>
Arguments: un polynôme à coefficients entiers, primitif et sans facteur 
multiple <I>P</I> de coefficient dominant <I>p</I><SUB><I>n</I></SUB>,
la liste <I>L</I> des facteurs de <I>P</I> dans &#X2124;/<I>p</I><SUP><I>l</I></SUP> <I>Z</I>[<I>X</I>] pour 
<I>l</I> assez grand et <I>p</I><SUP><I>l</I></SUP><BR>
Valeur de retour: la liste <I>F</I> des facteurs de <I>P</I> dans &#X2124;.<BR>
Initialiser <I>F</I> à vide, initialiser le nombre de facteurs à combine <I>c</I> 
à 1, entamer une boucle infinie :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>c</I> est strictement supérieur au cardinal de <I>L</I> divisé par 2,
ajouter le quotient de <I>P</I> par le produit des facteurs de <I>F</I> à <I>F</I> 
et retourner <I>F</I>
</LI><LI CLASS="li-itemize">Initialiser un vecteur <I>v</I>=(<I>v</I><SUB>1</SUB>,...,<I>v</I><SUB><I>c</I></SUB>) à <I>c</I> composantes à
la valeur (1,...,<I>c</I>)
</LI><LI CLASS="li-itemize">Boucle indéfinie intérieure :
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Faire le produit des facteurs de <I>F</I> d&#X2019;indice <I>v</I>, multiplier
par <I>p</I><SUB><I>n</I></SUB> dans &#X2124;/<I>p</I><SUP><I>l</I></SUP> <I>Z</I>, écrire le facteur en représentation symétrique,
le rendre primitif et tester si c&#X2019;est un facteur de <I>P</I> dans &#X2124;.
</LI><LI CLASS="li-enumerate">Si on a trouvé un facteur, le rajouter à la liste <I>F</I> et supprimer les
indices de <I>v</I> de la liste <I>L</I>, terminer cette boucle intérieure.
</LI><LI CLASS="li-enumerate">Sinon, incrémenter <I>v</I> de la manière suivante:<BR>
On fait une boucle sur un index <I>m</I> initialisé à la taille de <I>v</I>,
diminuant de 1 à chaque itération: on ajoute 1 à l&#X2019;élement de <I>v</I>
d&#X2019;indice <I>m</I>, si l&#X2019;élément obtenu est inférieur ou égal
au cardinal de <I>L</I>+<I>m</I>&#X2212;<I>n</I>, on arrête cette boucle, sinon on passe
à l&#X2019;itération suivante. Si <I>m</I>=0 à la fin de la boucle, <I>v</I>
ne peut pas être incrémenté. 
</LI><LI CLASS="li-enumerate">Si <I>v</I> ne peut être incrémenté, on incrémente <I>c</I> et on termine
la boucle intérieure.
</LI><LI CLASS="li-enumerate">Sinon on fait une boucle à nouveau
sur <I>m</I> en partant de la valeur actuelle incrémentée de 1, et tant
que <I>m</I>&#X2264; <I>n</I> on pose <I>v</I><SUB><I>m</I></SUB>=<I>v</I><SUB><I>m</I>&#X2212;1</SUB>+1. Puis on passe à l&#X2019;itération
suivante de la boucle intérieure.
</LI></OL>
</LI></UL><P>Il existe différentes méthodes
qui améliorent la complexité de cette étape :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
La recherche des degré possibles de facteurs fondée sur
la factorisation en degrés distincts pour différents nombres premiers 
permet d&#X2019;éviter des tests de division si une combinaison de facteurs
est d&#X2019;un degré exclu par la factorisation pour d&#X2019;autres nombres premiers.
</LI><LI CLASS="li-itemize">Le test de divisibilité du coefficient dominant ou du coefficient
constant permet aussi d&#X2019;éviter des divisions complètes de polynômes.
</LI></UL><P>
Mais ces astuces n&#X2019;évitent pas l&#X2019;énumération de toutes les combinaisons
possibles de facteurs et donc la complexité exponentielle. Lorsque
les combinaisons d&#X2019;un petit nombre de facteurs (par exemple 3)
échouent, les systèmes récents utilisent
l&#X2019;algorithme knapsack de Van Hoeij basé sur l&#X2019;algorithme LLL
(recherche de base d&#X2019;un réseau ayant des vecteurs de petite norme) 
qui permet d&#X2019;eliminer complètement cette complexité exponentielle.</P><P><B>Exemple</B> :<BR>
Toujours le même exemple, il nous restait deux
facteurs dans &#X2124;/125 &#X2124;, le facteur <I>x</I><SUP>3</SUP>+<I>x</I>+1 ayant été
détecté comme un facteur de <I>P</I>=<I>x</I><SUP>7</SUP>+<I>x</I><SUP>5</SUP>+<I>x</I><SUP>3</SUP>&#X2212;<I>x</I><SUP>2</SUP>+1 dans &#X2124;.
On teste chacun des facteurs <I>a</I><SUB>2</SUB>=<I>x</I>&#X2212;37 et <I>c</I><SUB>2</SUB>=<I>x</I><SUP>3</SUP>+37<I>x</I><SUP>2</SUP>&#X2212;6*<I>x</I>+27
séparément, sans succès. On les multiplie alors modulo 125,
ce qui donne <I>x</I><SUP>4</SUP>&#X2212;<I>x</I>+1 en représentation symétrique qui est bien
un facteur de <I>P</I> (donc un facteur irréductible).</P><!--TOC subsection Factorisation à plusieurs variables-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc47">8.3</A>  Factorisation à plusieurs variables</H3><!--SEC END --><P>
Comme pour le PGCD en plusieurs variables, on se ramène d&#X2019;abord en
une variable, en général on évalue toutes les variables sauf celle
correspondant au degré partiel le plus faible. On factorise ensuite
en une variable puis on remonte. A chaque étape de remontée, il peut
être à nouveau nécessaire de combiner plusieurs facteurs. Différentes
stratégies existent, comme pour le PGCD : factorisarion heuristique
(avec reconstruction <I>z</I>-adique), remontée variable par variable
ou toutes les variables en même temps comme dans EZGCD.
On va présenter ici plus en détails l&#X2019;algorithme de factorisation heuristique.</P><P>Soit <I>P</I> un polynôme en <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I></SUB> à coefficients entiers avec <I>n</I>&gt;1,
on choisit une des variables par exemple <I>X</I><SUB><I>n</I></SUB>, qu&#X2019;on notera <I>X</I> dans la suite.
On considère <I>P</I> comme un polynôme en <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB> à coefficients dans 
&#X2124;[<I>X</I>]. On suppose que <I>P</I> est primitif (quitte à extraire
son contenu qui est dans &#X2124;[<I>X</I>]). On calcule ensuite
<I>P</I>(<I>z</I>) pour un entier <I>z</I> tel que<SUP><A NAME="text8" HREF="#note8">8</A></SUP> |<I>z</I>| &#X2265; 2|<I>P</I>|+2. On factorise <I>P</I>(<I>z</I>)
dans &#X2124;[<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB>] :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:heu1"></A>
<I>P</I>(<I>z</I>)(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB>)=<I>c</I>(<I>z</I>) &#X3A0;<SUB><I>j</I>=1</SUB><SUP><I>k</I></SUP> <I>p</I><SUB><I>j</I></SUB>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB>)
    (13)</TD></TR>
</TABLE><P>
où <I>c</I> est le contenu du polynôme <I>P</I>(<I>z</I>) (comme polynôme en <I>n</I>&#X2212;1 
variables à coefficients entiers). Il s&#X2019;agit de reconstruire les facteurs
de <I>P</I> à partir des <I>p</I><SUB><I>j</I></SUB> et de <I>c</I>. Deux problèmes se posent alors,
celui de la recombinaison possible de plusieurs facteurs <I>p</I><SUB><I>j</I></SUB> pour
obtenir un facteur irréductible de <I>P</I>, et l&#X2019;existence d&#X2019;un facteur entier du
contenu <I>c</I> à combiner avec un ou plusieurs <I>p</I><SUB><I>j</I></SUB> pour obtenir ce
facteur irréductible. Plus précisément, si <I>P</I><SUB><I>k</I></SUB> est un facteur 
irréductible de <I>P</I>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:heu2"></A>
<I>P</I><SUB><I>k</I></SUB>(<I>z</I>)=<I>d</I>(<I>z</I>) &#X3A0;<SUB>certains  <I>j</I></SUB> <I>p</I><SUB><I>j</I></SUB>,    où  
<I>d</I>(<I>z</I>)  divise  <I>c</I>(<I>z</I>)
    (14)</TD></TR>
</TABLE><P>On a le :
</P><DIV CLASS="theorem"><B>Théorème 5</B>  <EM>
Soit </EM><EM><I>P</I>(<I>X</I></EM><SUB><EM>1</EM></SUB><EM>,...,<I>X</I></EM><SUB><EM><I>n</I>&#X2212;1</EM></SUB><EM>,<I>X</I>)</EM><EM> un polynôme à coefficients 
entiers ayant au moins 2 variables. On suppose que </EM><EM><I>P</I></EM><EM> est primitif
vu comme polynôme en les variables </EM><EM><I>X</I></EM><SUB><EM>1</EM></SUB><EM>,...,<I>X</I></EM><SUB><EM><I>n</I>&#X2212;1</EM></SUB><EM>
à coefficients dans </EM><EM><I>Z</I>[<I>X</I>]</EM><EM>.
Il existe une majoration </EM><EM><I>C</I></EM><EM> du contenu </EM><EM>|<I>c</I>(<I>z</I>)|</EM><EM> de </EM><EM><I>P</I></EM><EM> évalué en </EM><EM><I>X</I>=<I>z</I></EM><EM>
(plus précisément on peut trouver un entier </EM><EM><I>C</I></EM><EM> tel que </EM><EM><I>c</I>(<I>z</I>)</EM><EM> divise
</EM><EM><I>C</I></EM><EM>).<BR>
Il existe un nombre fini de </EM><EM><I>z</I></EM><EM> tels que l&#X2019;un des facteurs irréductibles
</EM><EM><I>P</I></EM><SUB><EM><I>k</I></EM></SUB><EM> de </EM><EM><I>P</I></EM><EM> évalué en </EM><EM><I>X</I>=<I>z</I></EM><EM> soit
réductible (c&#X2019;est-à-dire tels que (</EM><A HREF="#eq:heu2"><EM>14</EM></A><EM>) admette 
plusieurs facteurs </EM><EM><I>p</I></EM><SUB><EM><I>j</I></EM></SUB><EM> distincts)
</EM></DIV><P><B>Preuve</B><BR>
Pour déterminer <I>C</I>, on remarque que les facteurs du contenu de <I>P</I>(<I>z</I>)
sont des facteurs communs des coefficients de <I>P</I> évalués en <I>z</I>
vu comme polynôme en <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB> à coefficients dans &#X2124;[<I>X</I>].
Donc <I>c</I>(<I>z</I>) divise le générateur de l&#X2019;idéal engendré par ces coefficients
(ce générateur est un polynôme de &#X2124;[<I>X</I>] qui est constant car on a supposé
<I>P</I> primitif), on peut aussi dire que deux au moins des coefficients
dans &#X2124;[<I>X</I>] de <I>P</I> sont premiers entre eux, alors <I>c</I>(<I>z</I>) divise le
coefficient de l&#X2019;identité de Bézout de ces 2 coefficients vu
comme polynômes en <I>X</I>.</P><P>Considérons maintenant un facteur irréductible <I>P</I><SUB><I>k</I></SUB> de <I>P</I> de degré <I>d</I>
par rapport à <I>X</I>. Pour <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB> fixés, on factorise <I>P</I><SUB><I>k</I></SUB> sur &#X2102; :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB><I>k</I></SUB>(<I>X</I>)=<I>p</I><SUB><I>k</I></SUB> &#X3A0;<SUB><I>j</I>=1</SUB><SUP><I>d</I></SUP> (<I>X</I>&#X2212;<I>z</I><SUB><I>j</I></SUB>) </TD></TR>
</TABLE><P>
On va maintenant se restreindre à un domaine des <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB> sur
lequel les <I>z</I><SUB><I>j</I></SUB> ont une dépendance analytique par rapport à <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB>.
Pour cela on veut appliquer le théorème des fonctions implicites pour 
déterminer <I>z</I><SUB><I>j</I></SUB> au voisinage d&#X2019;une solution donnée. On calcule donc
la dérivée <I>P</I>&#X2032;<SUB><I>k</I></SUB> de <I>P</I><SUB><I>k</I></SUB> par rapport à <I>X</I>. On sait que <I>P</I> n&#X2019;a pas
de facteurs multiples, donc <I>P</I><SUB><I>k</I></SUB> et <I>P</I><SUB><I>k</I></SUB>&#X2032; sont premiers entre
eux, donc d&#X2019;après l&#X2019;identité de Bézout, il existe un polynôme non nul <I>D</I>
dépendant de <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB> et deux polynômes <I>U</I> et <I>V</I> dépendant
de <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB>,<I>X</I> tels que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>U</I> <I>P</I><SUB><I>k</I></SUB> + <I>V</I> <I>P</I><SUB><I>k</I></SUB>&#X2032; = <I>D</I> </TD></TR>
</TABLE><P>
Si <I>D</I>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB>) ne s&#X2019;annule pas, on va pouvoir appliquer le théorème
des fonctions implicites. On se fixe <I>x</I><SUB>1</SUB>,..,<I>x</I><SUB><I>n</I>&#X2212;1</SUB>,
on calcule dans &#X2102; les racines <I>z</I><SUB><I>j</I></SUB> du polynôme <I>P</I>(<I>x</I><SUB>1</SUB>,..,<I>x</I><SUB><I>n</I>&#X2212;1</SUB>,<I>X</I>)
pour une solution <I>z</I><SUB><I>j</I></SUB> telle que <I>P</I>(<I>x</I><SUB>1</SUB>,..,<I>x</I><SUB><I>n</I>&#X2212;1</SUB>,<I>z</I><SUB><I>j</I></SUB>)=0, 
comme <I>D</I> est non nul, on a <I>P</I>&#X2032;(<I>x</I><SUB>1</SUB>,...,<I>x</I><SUB><I>n</I>&#X2212;1</SUB>,<I>z</I><SUB><I>j</I></SUB>)&#X2260; 0, donc on peut 
écrire au voisinage de (<I>x</I><SUB>1</SUB>,..,<I>x</I><SUB><I>n</I>&#X2212;1</SUB>)
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>z</I><SUB><I>j</I></SUB>=<I>z</I><SUB><I>j</I></SUB>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB>),    <I>P</I>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB>,<I>z</I><SUB><I>j</I></SUB>)=0</TD></TR>
</TABLE><P> 
avec des fonctions <I>z</I><SUB><I>j</I></SUB> analytiques. 
Si <I>D</I> est constant, <I>D</I> ne s&#X2019;annule pas, 
sinon quitte à permuter les variables, on peut supposer que
le degré de <I>D</I> par rapport à <I>X</I><SUB>1</SUB> est non nul.
On peut alors se restreindre à une zone <I>X</I><SUB>1</SUB> &gt;&gt; <I>X</I><SUB>2</SUB> &gt;&gt; .. &gt;&gt; <I>X</I><SUB><I>n</I>&#X2212;1</SUB> &gt;&gt; 1
où <I>D</I> sera non nul ce qui permet de suivre analytiquement les <I>z</I><SUB><I>j</I></SUB>.</P><P>Supposons maintenant qu&#X2019;il existe un nombre infini de <I>z</I> tels <I>P</I><SUB><I>k</I></SUB>(<I>z</I>) 
soit réductible. Alors il existe un ensemble infini <I>Z</I>
de ces valeurs de <I>z</I> pour lesquels l&#X2019;un des facteurs à coefficients
entiers <I>f</I><SUB><I>j</I></SUB> de <I>P</I><SUB><I>k</I></SUB>(<I>z</I>) correspond à un même
sous-ensemble <I>R</I> des racines <I>z</I><SUB><I>j</I></SUB> de <I>P</I><SUB><I>k</I></SUB> et à un même contenu
<I>c</I> (puisqu&#X2019;il y a un nombre fini de combinaisons possibles des
racines en facteur et un nombre fini de diviseurs possibles
du contenu de <I>P</I><SUB><I>k</I></SUB>). Pour <I>z</I> &#X2208; <I>Z</I>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I><SUB><I>j</I></SUB>(<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I></SUB>,<I>z</I>)=<I>c</I> &#X3A0;<SUB><I>l</I> &#X2208; <I>R</I></SUB> (<I>z</I>&#X2212;<I>z</I><SUB><I>j</I></SUB>),    
<I>f</I><SUB><I>j</I></SUB> &#X2208; &#X2124;[<I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB>] </TD></TR>
</TABLE><P>
Soit <I>L</I>(<I>X</I>) le polynôme obtenu par interpolation de Lagrange 
en cardinal(<I>R</I>)+1 points <I>z</I> de <I>Z</I>, égal à <I>f</I><SUB><I>j</I></SUB> en <I>X</I>=<I>z</I>.
Pour des raisons de degré, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>L</I>=<I>c</I> &#X3A0;<SUB><I>l</I> &#X2208; <I>R</I></SUB> (<I>X</I>&#X2212;<I>z</I><SUB><I>j</I></SUB>) </TD></TR>
</TABLE><P>
donc <I>L</I> est un facteur de <I>P</I>.
De plus <I>L</I> est un polynôme en <I>X</I><SUB>1</SUB>,...,<I>X</I><SUB><I>n</I>&#X2212;1</SUB>,<I>X</I> à coefficients
rationnels (par construction). Ceci vient en contradiction avec l&#X2019;hypothèse 
<I>P</I><SUB><I>k</I></SUB> irréductible, car on a construit un facteur de <I>P</I><SUB><I>k</I></SUB> à coefficients
rationnels <I>L</I> de degré strictement inférieur.</P><P><B>Corollaire</B><BR>
Pour <I>z</I> assez grand, la reconstruction <I>z</I>-adique de <I>c</I>(<I>z</I>) <I>p</I><SUB><I>j</I></SUB>(<I>z</I>) est
un polynôme dont la partie primitive est un facteur irréductible de <I>P</I>.</P><P><B>Preuve du corollaire</B><BR>
On prend <I>z</I> assez grand pour que tous les facteurs irréductibles de <I>P</I>
évalués en <I>z</I> aient un seul facteur polynomial (i.e. soient de la forme 
<I>d</I>(<I>z</I>)<I>p</I><SUB><I>j</I></SUB>(<I>z</I>)). Quitte à augmenter <I>z</I>, on peut supposer que 
|<I>z</I>|&gt; 2 <I>C</I> <I>L</I>  où <I>C</I> est la majoration de |<I>c</I>(<I>z</I>)| et <I>L</I> est la borne 
de Landau sur les facteurs de <I>P</I>. Alors la reconstruction <I>z</I>-adique
de <I>c</I>(<I>z</I>)<I>p</I><SUB><I>j</I></SUB>(<I>z</I>) est <I>c</I>(<I>z</I>)/<I>d</I>(<I>z</I>)<I>P</I><SUB><I>j</I></SUB>, donc sa partie primitive est un
facteur irréductible de <I>P</I>.</P><P><B>Algorithme de factorisation heuristique à plusieurs variables</B><BR>
Argument: un polynôme <I>P</I> primitif en au moins 2 variables.<BR>
Valeur renvoyée: les facteurs irréductibles de <I>P</I><BR>
Choisir la variable <I>X</I> par rapport à laquelle <I>P</I> est de plus bas degré puis
factoriser le contenu de <I>P</I> vu comme polynôme à coefficients dans &#X2124;[<I>X</I>].
Initialiser un entier <I>z</I> à 2|<I>P</I>|+2 (où |<I>P</I>| est le plus grand coefficient 
entier de <I>P</I> en valeur absolue) et une liste <I>L</I> à la factorisation de
du contenu de <I>P</I>.<BR>
Boucle indéfinie :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>P</I>=1 renvoyer la liste <I>L</I> des facteurs de <I>P</I>.
</LI><LI CLASS="li-itemize">Tant que pgcd(<I>P</I>(<I>z</I>),<I>P</I>&#X2032;(<I>z</I>))=0 incrémenter <I>z</I> de 1.
</LI><LI CLASS="li-itemize">Factoriser <I>P</I>(<I>z</I>)=<I>c</I>(<I>z</I>)&#X3A0; <I>p</I><SUB><I>j</I></SUB>
</LI><LI CLASS="li-itemize">Pour tous les facteurs <I>p</I><SUB><I>j</I></SUB>, déterminer le polynôme <I>P</I><SUB><I>j</I></SUB> tel que 
<I>c</I>(<I>z</I>)<I>p</I><SUB><I>j</I></SUB>=<I>P</I><SUB><I>j</I></SUB>(<I>z</I>) par remontée
<I>z</I>-adique (avec les coefficients de <I>P</I><SUB><I>j</I></SUB> écrit en représentation
symétrique, de valeur absolue plus petite que |<I>z</I>|/2). Tester si
la partie primitive de <I>P</I><SUB><I>j</I></SUB> divise <I>P</I>. Si oui, rajouter un facteur
irréductible à la liste <I>L</I>, et diviser <I>P</I> par ce facteur.
</LI><LI CLASS="li-itemize">Augmenter <I>z</I>, par exemple remplacer <I>z</I> par la partie entière de
&#X221A;<SPAN style="text-decoration:overline">2</SPAN><I>z</I>.
</LI></UL><!--TOC subsection Preuve de l&#X2019;identité de Bézout généralisée-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc48">8.4</A>  Preuve de l&#X2019;identité de Bézout généralisée</H3><!--SEC END --><P>
Elle se fait par récurrence. Pour <I>n</I>=2, c&#X2019;est l&#X2019;identité de Bézout usuelle. 
Pour passer
du rang <I>n</I>&#X2212;1 au rang <I>n</I>, on isole <I>P</I><SUB><I>n</I></SUB> dans l&#X2019;identité à résoudre :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>&#X2212;1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> (&#X3A0;<SUB>1 &#X2264; <I>k</I> &#X2264; <I>n</I>&#X2212;1,<I>k</I>&#X2260; <I>j</I></SUB> <I>P</I><SUB><I>k</I></SUB>) </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><I>P</I><SUB><I>n</I></SUB> + 
<I>Q</I><SUB><I>n</I></SUB> &#X3A0;<SUB><I>k</I>&#X2264; <I>n</I>&#X2212;1</SUB> <I>P</I><SUB><I>k</I></SUB> =<I>Q</I> (mod <I>p</I> )</TD></TR>
</TABLE><P>
Comme <I>P</I><SUB><I>n</I></SUB> est premier avec &#X3A0;<SUB><I>k</I>&#X2264; <I>n</I>&#X2212;1</SUB> <I>P</I><SUB><I>k</I></SUB>, en appliquant Bézout,
on trouve deux polynômes <I>Q</I><SUB><I>n</I></SUB> et <I>R</I><SUB><I>n</I></SUB> tels que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:Qn"></A>
<I>R</I><SUB><I>n</I></SUB> <I>P</I><SUB><I>n</I></SUB> + <I>Q</I><SUB><I>n</I></SUB> &#X3A0;<SUB><I>k</I>&#X2264; <I>n</I>&#X2212;1</SUB> <I>P</I><SUB><I>k</I></SUB> =<I>Q</I> (mod <I>p</I> ) 
    (15)</TD></TR>
</TABLE><P>
Il reste à résoudre
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>&#X2212;1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> &#X3A0;<SUB>1 &#X2264; <I>k</I> &#X2264; <I>n</I>&#X2212;1,<I>k</I>&#X2260; <I>j</I></SUB> <I>P</I><SUB><I>k</I></SUB>=<I>R</I><SUB><I>n</I></SUB> (mod <I>p</I> )</TD></TR>
</TABLE><P>
ce que l&#X2019;on peut faire par hypothèse de récurrence.</P><!--TOC subsection Algorithme de Bézout généralisé-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc49">8.5</A>  Algorithme de Bézout généralisé</H3><!--SEC END --><P>
Arguments: une liste <I>P</I><SUB>1</SUB>,...,<I>P</I><SUB><I>n</I></SUB> de polynômes premiers entre eux 2 à 2 
et un polynôme <I>Q</I> à coefficients dans &#X2124;/<I>p</I>&#X2124;<BR>
Valeur renvoyée: la liste de polynômes <I>Q</I><SUB>1</SUB>,...,<I>Q</I><SUB><I>n</I></SUB> tels que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Q</I><SUB><I>j</I></SUB> &#X3A0;<SUB><I>k</I>&#X2260; <I>j</I></SUB> <I>P</I><SUB><I>k</I></SUB>=<I>Q</I> (mod <I>p</I> ) </TD></TR>
</TABLE><P>
On peut commencer par calculer le produit de tous les <I>P</I><SUB><I>k</I></SUB> puis faire une 
boucle sur <I>j</I> pour calculer les produits des <I>P</I><SUB><I>k</I></SUB> pour <I>k</I>&#X2260; <I>j</I> en divisant
le produit complet par <I>P</I><SUB><I>j</I></SUB> (on fait ainsi <I>n</I>&#X2212;1 multiplications et
<I>n</I> divisions au lieu de <I>n</I>(<I>n</I>&#X2212;1) multiplications).<BR>
Boucle indéfinie sur <I>n</I> décrémenté de 1 par itération :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>n</I>=2, on rajoute à la liste résultat les polynômes 
<I>Q</I><SUB>1</SUB> et <I>Q</I><SUB>2</SUB> de l&#X2019;algorithme de Bézout usuel et on renvoie la liste
</LI><LI CLASS="li-itemize">Sinon, on calcule les polynômes <I>R</I><SUB><I>n</I></SUB> et <I>Q</I><SUB><I>n</I></SUB> vérifiant (<A HREF="#eq:Qn">15</A>),
on rajoute <I>Q</I><SUB><I>n</I></SUB> en début de liste, on remplace <I>Q</I> par <I>R</I><SUB><I>n</I></SUB>.
</LI></UL><P>
Remarquons que lorsque nous utiliserons cet algorithme, <I>Q</I> sera la différence
entre deux polynômes de même degré (le degré de <I>P</I>) et de même coefficient
dominant 1, on peut donc
remplacer les <I>Q</I><SUB><I>i</I></SUB> par le reste euclidien de <I>Q</I><SUB><I>i</I></SUB> par <I>P</I><SUB><I>i</I></SUB> sans
changer l&#X2019;égalité.</P><!--TOC subsection Pour en savoir plus-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc50">8.6</A>  Pour en savoir plus</H3><!--SEC END --><P>
Pour factoriser des polynômes ayant des coefficients dans des
extensions algébriques, il existe un algorithme assez simple, 
l&#X2019;algorithme de Trager, qui n&#X2019;est pas forcément le plus performant 
(la recherche est encore active dans ce domaine), cf. le livre de 
Henri Cohen pp. 142-144.</P><P>Pour factoriser sur des corps finis, on peut consulter la thèse
de Bernardin disponible sur le web (<CODE>http://www.bernardin.lu</CODE>).</P><P>On peut aussi consulter le code source de Mupad, les routines
de factorisation se trouvent dans le répertoire <CODE>lib/POLYLIB/FACLIB</CODE>
après avoir désarchivé la <CODE>lib.tar</CODE>. Le point d&#X2019;entrée pour factoriser
des polynômes à plusieurs variables sur &#X2124; est le fichier 
<CODE>mfactor.mu</CODE>, on observera que l&#X2019;algorithme utilisé par Mupad est
assez différent de celui qu&#X2019;on a détaillé dans la section précédente.</P><!--TOC subsection Exercices (factorisation des polynômes)-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc51">8.7</A>  Exercices (factorisation des polynômes)</H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Déterminer le nombre de racines de &#X2212;<I>x</I><SUP>7</SUP>+<I>x</I><SUP>4</SUP>+12<I>x</I>&#X2212;5 comprises
entre 0 et 6 (en utilisant les suites de Sturm, on donnera les
détails des calculs).
</LI><LI CLASS="li-enumerate">Écrire un programme calculant la suite de Sturm d&#X2019;un polynôme
supposé squarefree (on peut tester avec <CODE>sqrfree</CODE>), en utilisant
l&#X2019;algorithme d&#X2019;Euclide.
</LI><LI CLASS="li-enumerate">Trouver les facteurs de degré 1 s&#X2019;ils existent de
3<I>x</I><SUP>5</SUP>+25<I>x</I><SUP>4</SUP>+67<I>x</I><SUP>3</SUP>+77<I>x</I><SUP>2</SUP>+55<I>x</I>+13 en remontant ses racines
dans &#X2124;/<I>pZ</I>[<I>X</I>] pour <I>p</I> premier bien choisi.
</LI><LI CLASS="li-enumerate">Factoriser le polynôme <I>x</I><SUP>5</SUP>+<I>x</I>+1 par la méthode 
de Berlekamp.
</LI><LI CLASS="li-enumerate">Calculer avec un logiciel les valeurs numériques des racines
complexes de <I>P</I>(<I>x</I>)=<I>x</I><SUP>5</SUP>+<I>x</I>+1. Trouver les combinaisons de racines
dont la somme est entière (aux arrondis près). En déduire la factorisation
en facteurs irréductibles sur &#X2124; de <I>P</I>.
</LI><LI CLASS="li-enumerate">Factorisation numérique sur &#X2102;. Écrire un programme
qui calcule une racine d&#X2019;un polynôme à coefficients complexes
en utilisant une méthode itérative de type méthode de Newton 
(avec éventuellement un préfacteur lorsqu&#X2019;on débute la recherche).
Les polynômes seront représentés par la liste de leurs coefficients
et l&#X2019;évaluation faite par la méthode de Horner.
Trouver ensuite toutes les racines du polynôme en éliminant la
racine trouvée (toujours avec Horner). Trouver les combinaisons
de racines correspondant à un facteur à coefficients entiers.
</LI><LI CLASS="li-enumerate">Même question pour les facteurs de degré 2 d&#X2019;un polynôme à coefficients
réels sans racines réelles en utilisant la méthode de Bairstow décrite
ci-dessous.<BR>
On cherche un facteur <I>F</I>=<I>x</I><SUP>2</SUP>+<I>sx</I>+<I>p</I> de <I>P</I>, on calcule le quotient et le reste
de la division <I>P</I>=<I>FQ</I>+<I>R</I> par une méthode de type Horner, il s&#X2019;agit de 
rendre <I>R</I> (vu comme un vecteur à 2 composantes) nul. On calcule
donc &#X2202;<SUB><I>s</I>,<I>p</I></SUB> <I>R</I> (en cherchant le quotient et le reste
de <I>xQ</I> et <I>Q</I> par <I>F</I>, pourquoi?) et on pose :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>s</I>,<I>p</I>)<SUB><I>n</I>+1</SUB>=(<I>s</I>,<I>p</I>)<SUB><I>n</I></SUB>&#X2212; &#X3BB; (&#X2202;<SUB><I>s</I>,<I>p</I></SUB> <I>R</I>)<SUP>&#X2212;1</SUP> <I>R</I> (<I>s</I>,<I>p</I>)<SUB><I>n</I></SUB></TD></TR>
</TABLE>
où &#X3BB; est un préfacteur compris entre 0 et 1 et ajusté à 1 
lorsqu&#X2019;on est proche du facteur.
</LI><LI CLASS="li-enumerate">Soit <I>p</I> un entier premier et <I>P</I> un polynôme à
coefficients dans &#X2124;/<I>p</I>&#X2124;. On a la relation
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>gcd</I>(<I>X</I><SUP><I>p</I><SUP><I>k</I></SUP></SUP>&#X2212;<I>X</I>,<I>P</I>) = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"> <I>f</I> | <I>P</I>, deg(<I>f</I>) | <I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>f</I>, 
   <I>f</I>  irréductible </TD></TR>
</TABLE>
En utilisant cette relation, 
déterminer les degrés des facteurs de 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>x</I><SUP>3</SUP>+<I>x</I>+1)(<I>x</I><SUP>4</SUP>+<I>x</I>+1) </TD></TR>
</TABLE>
modulo 5 et 7 (sans utiliser la commande factor). 
Peut-on en déduire que <I>x</I><SUP>3</SUP>+<I>x</I>+1 et
<I>x</I><SUP>4</SUP>+<I>x</I>+1 sont irréductibles sur &#X2124;?
</LI><LI CLASS="li-enumerate">Utiliser les options &#X201C;verbose&#X201D; de votre logiciel de calcul formel
pour factoriser <I>x</I><SUP>202</SUP>+<I>x</I><SUP>101</SUP>+1 et vérifiez que vous avez compris
la méthode utilisée.
</LI><LI CLASS="li-enumerate">Montrer que 2<I>x</I>+<I>x</I><SUP>2</SUP><I>y</I>+<I>x</I><SUP>3</SUP>+2<I>x</I><SUP>4</SUP>+<I>y</I><SUP>3</SUP>+<I>x</I><SUP>5</SUP> est irréductible sur &#X2124;
sans utiliser l&#X2019;instruction factor à 2 variables (on pourra factoriser 
pour quelques valeurs de <I>x</I> ou de <I>y</I>)</LI><LI CLASS="li-enumerate">Que se passe-t-il lorsqu&#X2019;on exécute l&#X2019;algorithme de Yun
dans &#X2124;/<I>n</I>&#X2124;?</LI><LI CLASS="li-enumerate">Déterminer les degrés des facteurs de (<I>x</I><SUP>3</SUP>+<I>x</I>+1)(<I>x</I><SUP>4</SUP>+<I>x</I>+1) modulo 5
et 7 (sans utiliser la commande factor). Peut-on en déduire que <I>x</I><SUP>3</SUP>+<I>x</I>+1 et
<I>x</I><SUP>4</SUP>+<I>x</I>+1 sont irréductibles sur &#X2124;?</LI><LI CLASS="li-enumerate">Utiliser les options &#X201C;verbose&#X201D; de votre logiciel de calcul formel
pour factoriser <I>x</I><SUP>202</SUP>+<I>x</I><SUP>101</SUP>+1 et vérifiez que vous avez compris
la méthode utilisée.
</LI><LI CLASS="li-enumerate">Montrer que 2<I>x</I>+<I>x</I><SUP>2</SUP><I>y</I>+<I>x</I><SUP>3</SUP>+2<I>x</I><SUP>4</SUP>+<I>y</I><SUP>3</SUP>+<I>x</I><SUP>5</SUP> est irréductible sur &#X2124;
sans utiliser directement l&#X2019;instruction factor 
(on pourra factoriser pour quelques
valeurs de <I>x</I> ou de <I>y</I>)</LI></OL><!--TOC section Intégration-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc52">9</A>  Intégration</H2><!--SEC END --><!--TOC subsection Introduction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc53">9.1</A>  Introduction</H3><!--SEC END --><P>
Que peut-on espérer d&#X2019;un système de calcul formel lorsqu&#X2019;il s&#X2019;agit
de calculer une primitive? Tout d&#X2019;abord, on peut espérer qu&#X2019;il
sache résoudre ce que l&#X2019;on donne en exercice à nos étudiants!
Ceci suppose donc de connaitre quelques méthodes classiques, par
exemple: intégration de polynômes (!), polynômes multipliés par exponentielle
ou/et fonctions trigonométriques, de polynômes trigonométriques par
linéarisation, de fractions rationnelles,
de fractions trigonométriques, de fractions de racines carrées de 
polynômes du second ordre, de fonctions s&#X2019;y ramenant par une ou plusieurs
intégrations par parties ou par
changement de fonction (par exemple reconnaissance de formes <I>F</I>(<I>u</I>)<I>u</I>&#X2032; )
ou par changement de variables, etc.</P><P>Mais au-delà de ces méthodes (qui ont l&#X2019;avantage de la rapidité mais
tiennent parfois plus de la
recette de cuisine que de l&#X2019;algorithme...), on peut se demander 
si la primitive d&#X2019;une fonction donnée peut ou non s&#X2019;exprimer en terme 
des fonctions &#X201C;élémentaires&#X201D;. Par exemple, tout le monde &#X201C;sait&#X201D;
que la fonction <I>e</I><SUP><I>x</I><SUP>2</SUP></SUP> n&#X2019;admet pas de primitive &#X201C;simple&#X201D;, encore
faut-il donner un sens mathématique précis à cette affirmation.
Ceci nécessite de donner une définition rigoureuse du terme fonction
élémentaire. On peut alors appliquer un algorithme développé
par Risch (pour les extensions dites transcendantes, obtenue par ajout
des fonctions exponentielle et logarithme) 
qui permet de répondre à la question :
il s&#X2019;agit vu de très loin d&#X2019;une extension de l&#X2019;algorithme d&#X2019;intégration
des fractions rationnelles.</P><P>Cet article se décompose en deux parties principales :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
la section <A HREF="#sec:elem">9.2</A> présente les définitions de fonctions
élémentaires, de tour de variables, et donne deux théorèmes,
le théorème de structure de Risch qui permet d&#X2019;écrire une fonction 
contenant des exponentielles et des logarithmes comme une fonction 
élémentaire par rapport à une tour de variable, et 
le théorème de Liouville qui donne la forme que peut prendre
une primitive d&#X2019;une fonction élémentaire lorsqu&#X2019;elle est aussi élémentaire.
</LI><LI CLASS="li-itemize">la section <A HREF="#sec:risch">9.3</A> décrit l&#X2019;algorithme d&#X2019;intégration de Risch
permettant de décider si une fonction élémentaire donnée possède
ou non une primitive élémentaire et de la calculer dans le premier
cas. Nous ne présentons ici l&#X2019;algorithme de Risch que pour les extensions
transcendantes pures (ln et exp).
</LI></UL><P>
Le lecteur intéressé par le cas des extensions algébriques 
pourra consulter la thèse de Trager. Pour les extensions
plus générales (incluant en particulier les fonctions
tangente, arctangente), la référence est le livre de Bronstein 
donnée en section <A HREF="#sec:rischref">9.4</A>.</P><!--TOC subsection Fonctions élémentaires-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc54">9.2</A>  Fonctions élémentaires</H3><!--SEC END --><P> <A NAME="sec:elem"></A></P><!--TOC subsubsection Extensions transcendantes, tour de variables-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc55">9.2.1</A>  Extensions transcendantes, tour de variables</H4><!--SEC END --><P>
On se donne une expression <I>f</I>(<I>x</I>) dépendant de la variable <I>x</I> que l&#X2019;on 
souhaite intégrer par rapport à <I>x</I>. L&#X2019;algorithme de Risch s&#X2019;applique à
cette expression si on peut l&#X2019;écrire comme une fraction rationnelle à
plusieurs variables algébriquement indépendantes
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>, <I>f</I><SUB>1</SUB>(<I>x</I>), <I>f</I><SUB>2</SUB>(<I>x</I>,<I>f</I><SUB>1</SUB>(<I>x</I>)), ..., 
<I>f</I><SUB><I>n</I></SUB>(<I>x</I>,<I>f</I><SUB>1</SUB>(<I>x</I>),<I>f</I><SUB>2</SUB>(<I>x</I>,<I>f</I><SUB>1</SUB>(<I>x</I>)),...,<I>f</I><SUB><I>n</I>&#X2212;1</SUB>(<I>x</I>,<I>f</I><SUB>1</SUB>(<I>x</I>),...,<I>f</I><SUB><I>n</I>&#X2212;2</SUB>(<I>x</I>))) </TD></TR>
</TABLE><P>
où les <I>f</I><SUB><I>i</I></SUB> sont soit l&#X2019;exponentielle soit le logarithme d&#X2019;une fraction
rationnelle (le corps de base appelé aussi corps de
constantes ici est soit &#X2102;, soit une extension algébrique de &#X211A; ou une
extension algébrique d&#X2019;un corps de fractions rationnelles s&#X2019;il
y a des paramètres). 
On appelle tour de variables
la suite des <I>x</I>,<I>f</I><SUB>1</SUB>,...,<I>f</I><SUB><I>n</I></SUB> (chaque étage est donc une exponentielle
d&#X2019;une fraction rationnelle ou le logarithme d&#X2019;une fraction rationnelle
dépendant des étages précédents) 
et on dira que <I>f</I> est une fonction élémentaire
par rapport à cette tour de variables.</P><P>L&#X2019;intérêt de l&#X2019;écriture d&#X2019;une expression sous forme de tour est 
qu&#X2019;elle est stable par dérivation : 
si on dérive par rapport à <I>x</I>
une fonction élémentaire dépendant d&#X2019;une tour de variables, on obtient encore 
une fonction élémentaire dépendant de la même tour de variables.
Autrement dit, l&#X2019;ensemble des fonctions élémentaires pour une tour 
fixée est un corps différentiel.</P><P><B>Exemples: </B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>e</I><SUP><I>x</I><SUP>2</SUP></SUP> est bien dans ce cas, pour <I>n</I>=1, <I>f</I><SUB>1</SUB>
est l&#X2019;exponentielle de <I>x</I><SUP>2</SUP> qui est algébriquement indépendant
de <I>x</I>. Les fonctions (2<I>x</I><SUP>2</SUP>&#X2212;1)<I>e</I><SUP><I>x</I><SUP>2</SUP></SUP>
ou <I>x</I>/(<I>e</I><SUP><I>x</I><SUP>2</SUP></SUP>&#X2212;1) sont aussi élémentaires par rapport à
la tour de variables {<I>x</I>,<I>e</I><SUP><I>x</I><SUP>2</SUP></SUP> }. 
</LI><LI CLASS="li-itemize"><I>x</I> ln(<I>x</I>) exp(<I>x</I>) est élémentaire par rapport à la tour
{ <I>x</I>, ln(<I>x</I>), exp(<I>x</I>)}, mais aussi par rapport à la tour
{ <I>x</I>, exp(<I>x</I>), ln(<I>x</I>)}.
</LI><LI CLASS="li-itemize"><I>xe</I><SUP><I>x</I> ln(<I>x</I>)</SUP> est élémentaire, en prenant <I>n</I>=2, <I>f</I><SUB>1</SUB>=ln(<I>x</I>)
et <I>f</I><SUB>2</SUB>=<I>e</I><SUP><I>x</I> <I>f</I><SUB>1</SUB></SUP>.
</LI><LI CLASS="li-itemize"><I>x</I><SUP><I>n</I></SUP>=<I>e</I><SUP><I>n</I>ln(<I>x</I>)</SUP>, où <I>n</I> est un paramètre, convient avec
comme tour {<I>x</I>, ln(<I>x</I>), <I>e</I><SUP><I>n</I> ln(<I>x</I>) </SUP>
</LI><LI CLASS="li-itemize"><I>e</I><SUP>ln(<I>x</I>)</SUP> ne convient pas car il n&#X2019;est pas algébriquement
indépendant de <I>x</I>,ln(<I>x</I>) mais on peut le réécrire sous une forme
acceptable puisque <I>e</I><SUP>ln(<I>x</I>)</SUP>=<I>x</I>.
</LI><LI CLASS="li-itemize"><I>e</I><SUP>ln(<I>x</I>)/2</SUP> ne convient pas non plus car son carré est égal à <I>x</I>.
Une réécriture ne suffit pas, cet exemple est bien sûr une extension
algébrique et non transcendante.
</LI></UL><P>Dans la suite, on va s&#X2019;intéresser aux tours de variables dans lesquelles 
on a effectué des simplifications évidentes.
On élimine les ln&#X2218; exp de la manière suivante :
si <I>f</I><SUB><I>k</I></SUB>=ln(<I>g</I><SUB><I>k</I></SUB>), on regarde si <I>g</I><SUB><I>k</I></SUB> vu comme fraction 
en <I>f</I><SUB>1</SUB>,...,<I>f</I><SUB><I>k</I>&#X2212;1</SUB> possède un facteur <I>f</I><SUB><I>j</I></SUB><SUP><I>m</I></SUP> (avec <I>m</I> &#X2208; &#X2124;)
lorsque <I>f</I><SUB><I>j</I></SUB>=exp(<I>g</I><SUB><I>j</I></SUB>) est une exponentielle.
Si c&#X2019;est le cas, on a <I>f</I><SUB><I>k</I></SUB>= <I>m</I> <I>g</I><SUB><I>j</I></SUB> + ln(<I>g</I><SUB><I>k</I></SUB>/<I>g</I><SUB><I>j</I></SUB><SUP><I>m</I></SUP>). On change
alors de tour en remplaçant <I>f</I><SUB><I>k</I></SUB> par f<SUB><I>k</I></SUB>=ln(<I>g</I><SUB><I>k</I></SUB>/<I>g</I><SUB><I>j</I></SUB><SUP><I>m</I></SUP>)=<I>f</I><SUB><I>k</I></SUB>&#X2212;<I>mg</I><SUB><I>j</I></SUB>.
On élimine aussi les exp&#X2218; ln, si
<I>f</I><SUB><I>k</I></SUB>=exp(<I>g</I><SUB><I>k</I></SUB>), pour <I>j</I>&lt;<I>k</I> si <I>f</I><SUB><I>j</I></SUB> est un logarithme,
on regarde si <I>c</I><SUB><I>j</I></SUB>=&#X2202;<SUB><I>f</I><SUB><I>j</I></SUB></SUB><I>g</I><SUB><I>k</I></SUB>|<SUB><I>f</I><SUB><I>j</I></SUB>=0</SUB> est un entier, si
c&#X2019;est le cas on remplace <I>f</I><SUB><I>k</I></SUB> par f<SUB><I>k</I></SUB>=<I>f</I><SUB><I>k</I></SUB>/<I>g</I><SUB><I>k</I></SUB><SUP><I>c</I><SUB><I>j</I></SUB></SUP>.</P><P><B>Exemples: </B>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> ln(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP><I>x</I><SUP>2</SUP></SUP>+1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP><I>x</I><SUP>2</SUP></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">)</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&#X2192;</TD><TD ALIGN=left NOWRAP>&#X2212;<I>x</I><SUP>2</SUP> + ln(<I>e</I><SUP><I>x</I><SUP>2</SUP></SUP>+1) </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>e</I><SUP>3 ln(<I>x</I>)+ln(<I>x</I>)<SUP>2</SUP>+5</SUP></TD><TD ALIGN=center NOWRAP>&#X2192;</TD><TD ALIGN=left NOWRAP><I>x</I><SUP>3</SUP> <I>e</I><SUP>ln(<I>x</I>)<SUP>2</SUP>+5</SUP> </TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsubsection Théorème de structure de Risch-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc56">9.2.2</A>  Théorème de structure de Risch</H4><!--SEC END --><P>
On voit donc qu&#X2019;il est nécessaire de disposer d&#X2019;un algorithme
pour décider si des exponentielles et logarithmes sont
algébriquement indépendants. Cet algorithme est basé sur
un théorème de structure dû à Risch :
</P><DIV CLASS="theorem"><B>Théorème 6</B>  <EM>
Soit </EM><EM><I>f</I>=</EM><EM>ln</EM><EM>(<I>g</I>(<I>x</I>))</EM><EM> le logarithme d&#X2019;une fonction élémentaire
</EM><EM><I>g</I></EM><EM> par rapport à une tour de variables </EM><EM><I>T</I></EM><EM>, alors soit </EM><EM><I>f</I></EM><EM>
est algébriquement indépendant des variables de </EM><EM><I>T</I></EM><EM>, soit </EM><EM><I>f</I></EM><EM> est
élémentaire et plus précisément combinaison linéaire rationnelle
des logarithmes et des arguments des exponentielles de la tour </EM><EM><I>T</I></EM><EM>.</EM><P><EM>Soit </EM><EM><I>f</I>=</EM><EM>exp</EM><EM>(<I>g</I>)</EM><EM> l&#X2019;exponentielle d&#X2019;une fonction élémentaire </EM><EM><I>g</I></EM><EM>
par rapport à une tour de variables </EM><EM><I>T</I></EM><EM>, alors soit </EM><EM><I>f</I></EM><EM>
est algébriquement indépendante des variables de </EM><EM><I>T</I></EM><EM>, soit
il existe </EM><EM><I>n</I></EM><EM> tel que </EM><EM><I>f</I></EM><SUP><EM><I>n</I></EM></SUP><EM> soit élémentaire par rapport à </EM><EM><I>T</I></EM><EM> 
(on peut alors appliquer le cas précédent à </EM><EM><I>ng</I>=</EM><EM>ln</EM><EM>(<I>f</I></EM><SUP><EM><I>n</I></EM></SUP><EM>)</EM><EM>)
</EM></P></DIV><P><B>Démonstration</B> :<BR>
Commençons par le cas de l&#X2019;exponentielle. On considère le polynôme minimal
de <I>f</I>=exp(<I>g</I>) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>n</I></SUB> <I>f</I><SUP><I>n</I></SUP>+...+<I>a</I><SUB>0</SUB>=0,    <I>a</I><SUB><I>n</I></SUB> &#X2260; 0 , <I>a</I><SUB>0</SUB> &#X2260; 0</TD></TR>
</TABLE><P>
où les <I>a</I><SUB><I>i</I></SUB> sont des fractions rationnelles en <I>T</I>. On dérive
et on applique <I>f</I>&#X2032;=<I>g</I>&#X2032;<I>f</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>a</I><SUB><I>n</I></SUB>&#X2032;+<I>n</I> <I>a</I><SUB><I>n</I></SUB> <I>g</I>&#X2032;) <I>f</I><SUP><I>n</I></SUP> +   ... + ( <I>a</I><SUB><I>k</I></SUB>&#X2032; + <I>ka</I><SUB><I>k</I></SUB> <I>g</I>&#X2032;)<I>f</I><SUP><I>k</I></SUP> +... =0</TD></TR>
</TABLE><P>
c&#X2019;est un multiple du polynôme minimal donc il existe une fraction rationnelle
<I>C</I> (par rapport à la tour de variables) telle que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X2200; <I>k</I>,    (<I>a</I><SUB><I>k</I></SUB>&#X2032;+<I>k</I> <I>a</I><SUB><I>k</I></SUB> <I>g</I>&#X2032;) = <I>C</I> <I>a</I><SUB><I>k</I></SUB></TD></TR>
</TABLE><P>
Comme <I>a</I><SUB><I>n</I></SUB>&#X2260; 0, cela entraine <I>a</I><SUB><I>n</I></SUB>&#X2032;/<I>a</I><SUB><I>n</I></SUB>+<I>ng</I>&#X2032;=<I>C</I>. Le coefficient
constant <I>a</I><SUB>0</SUB> est aussi non nul, donc <I>a</I><SUB>0</SUB>&#X2032;/<I>a</I><SUB>0</SUB>=<I>C</I> et 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>n</I> <I>g</I>&#X2032; = <I>a</I><SUB>0</SUB>&#X2032;/<I>a</I><SUB>0</SUB> &#X2212; <I>a</I><SUB><I>n</I></SUB>&#X2032;/<I>a</I><SUB><I>n</I></SUB> &#X21D2; <I>ng</I>=ln(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUB>0</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">) + <I>k</I></TD></TR>
</TABLE><P>
où <I>k</I> est constant, donc <I>f</I><SUP><I>n</I></SUP>=exp(<I>ng</I>)=<I>e</I><SUP><I>k</I></SUP> <I>a</I><SUB>0</SUB>/<I>a</I><SUB><I>n</I></SUB> est élémentaire.</P><P>Passons au cas du logarithme, supposons que <I>f</I>=ln(<I>g</I>) dépende
algébriquement de la tour <I>T</I>, on va commencer par montrer que
<I>f</I> est élémentaire. On écrit :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>n</I></SUB> <I>f</I><SUP><I>n</I></SUP>+...+<I>a</I><SUB>0</SUB>=0</TD></TR>
</TABLE><P>
où les <I>a</I><SUB><I>i</I></SUB> sont des fractions rationnelles en <I>T</I>. On dérive en
appliquant <I>f</I>&#X2032;=<I>g</I>&#X2032;/<I>g</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>n</I></SUB>&#X2032; <I>f</I><SUP><I>n</I></SUP> + (<I>n</I> <I>a</I><SUB><I>n</I></SUB> <I>f</I>&#X2032; + <I>a</I><SUB><I>n</I>&#X2212;1</SUB>&#X2032;)<I>f</I><SUP><I>n</I>&#X2212;1</SUP>  ... + <I>a</I><SUB>1</SUB> <I>f</I>&#X2032;+<I>a</I><SUB>0</SUB> &#X2032;</TD></TR>
</TABLE><P>
Comme <I>f</I>&#X2032; est une fraction rationnelle en <I>T</I>, le polynôme
<I>a</I><SUB><I>n</I></SUB>&#X2032; <I>X</I><SUP><I>n</I></SUP> + (<I>n</I> <I>a</I><SUB><I>n</I></SUB> <I>f</I>&#X2032;+<I>a</I><SUB><I>n</I>&#X2212;1</SUB>&#X2032;) <I>X</I><SUP><I>n</I>&#X2212;1</SUP>+...+ <I>a</I><SUB>1</SUB> <I>f</I>&#X2032;+<I>a</I><SUB>0</SUB>&#X2032; qui annule <I>f</I>
doit être un multiple du polynôme minimal de <I>f</I>, il existe donc
une fraction rationnelle <I>C</I> par rapport à <I>T</I> telle que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I><SUB><I>n</I></SUB>&#X2032; = <I>C</I> <I>a</I><SUB><I>n</I></SUB>    (<I>n</I> <I>a</I><SUB><I>n</I></SUB> <I>f</I>&#X2032;+<I>a</I><SUB><I>n</I>&#X2212;1</SUB>&#X2032;) = <I>C</I> <I>a</I><SUB><I>n</I>&#X2212;1</SUB>    ... </TD></TR>
</TABLE><P>
On en déduit <I>f</I>&#X2032; :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>&#X2032;=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUB><I>n</I></SUB>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>a</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>n</I>&#X2212;1</SUB>&#X2212;<I>a</I><SUB><I>n</I>&#X2212;1</SUB>&#X2032;</TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I> <I>a</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = 
</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;<I>a</I><SUB><I>n</I>&#X2212;1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I> <I>a</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">&#X2032;</TD></TR>
</TABLE><P>
donc il existe une constante <I>c</I> telle que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;<I>a</I><SUB><I>n</I>&#X2212;1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I> <I>a</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">+<I>c</I></TD></TR>
</TABLE><P>
donc <I>f</I> est élémentaire par rapport à la même tour <I>T</I> que <I>g</I>.</P><P>Montrons maintenant qu&#X2019;un logarithme <I>f</I>=ln(<I>g</I>) qui est élémentaire
par rapport à une tour de variable <I>T</I> est combinaison linéaire à
coefficients rationnelles des logarithmes et des arguments
des exponentielles de <I>T</I><SUP><A NAME="text9" HREF="#note9">9</A></SUP>.
Soit <I>X</I> la dernière variable de la tour <I>T</I>.
On factorise maintenant le numérateur et le dénominateur de <I>g</I> en
&#X220F;<SUB><I>j</I></SUB> <I>P</I><SUB><I>j</I></SUB><SUP><I>j</I></SUP> où les <I>P</I><SUB><I>j</I></SUB> sont sans facteurs multiples et 
premiers entre eux 2 à 2 (par rapport à <I>X</I>), il existe
<I>C</I> indépendant de <I>X</I> tel que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:g"></A>
<I>g</I>=<I>C</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> &#X2208; &#X2124;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB><I>j</I></SUB><SUP><I>j</I></SUP> &#X21D2; 
ln(<I>g</I>)=ln(<I>C</I>)+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I> &#X2208; &#X2124;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>j</I> ln(<I>P</I><SUB><I>j</I></SUB>)
    (16)</TD></TR>
</TABLE><P>
Alors <I>f</I>&#X2032;=ln(<I>C</I>)&#X2032;+&#X2211;<SUB><I>j</I></SUB> <I>j</I> <I>P</I><SUB><I>j</I></SUB>&#X2032;/<I>P</I><SUB><I>j</I></SUB> donc &#X220F;<I>P</I><SUB><I>j</I></SUB> <I>f</I>&#X2032; est un 
polynôme en <I>X</I>. 
Soit <I>N</I>/<I>D</I> la fraction irréductible représentant <I>f</I>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>&#X2032;=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>&#X2032; <I>D</I> &#X2212;<I>N</I> <I>D</I>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on vient donc de montrer que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:prodpj"></A>
</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>&#X2032; <I>D</I> &#X2212; <I>N</I> <I>D</I>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
 est un polynôme en <I>X</I>
    (17)</TD></TR>
</TABLE><P>
Soit <I>P</I> un facteur irréductible de <I>D</I> de multiplicité
<I>k</I> tel que <I>D</I>=<I>P</I><SUP><I>k</I></SUP> <I>Q</I> (donc <I>P</I> premier avec <I>Q</I>, mais <I>P</I> est aussi
premier avec <I>N</I> car <I>f</I>=<I>N</I>/<I>D</I> est irréductible). Alors en simplifiant
numérateur et dénominateur par <I>P</I><SUP><I>k</I>&#X2212;1</SUP>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:estpolynome"></A>
</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>&#X2032; <I>P</I> <I>Q</I> &#X2212; <I>N</I> (<I>kP</I>&#X2032;<I>Q</I>+<I>PQ</I>&#X2032;)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"> <I>P</I><SUP><I>k</I>+1</SUP> <I>Q</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
 est un polynôme en <I>X</I>. 
    (18)</TD></TR>
</TABLE><P>
On en déduit, après simplification d&#X2019;au plus un facteur <I>P</I> au dénominateur 
avec l&#X2019;un des <I>P</I><SUB><I>j</I></SUB>, que <I>P</I><SUP><I>k</I></SUP> divise 
<I>N</I>&#X2032; <I>P</I> <I>Q</I> &#X2212; <I>N</I> (<I>kP</I>&#X2032;<I>Q</I>+<I>PQ</I>&#X2032;) donc <I>P</I> divise <I>P</I>&#X2032;. Ceci n&#X2019;est possible
que si <I>P</I>=1 (et donc le dénominateur de <I>f</I> est égal à 1) 
ou si la variable <I>X</I> est une exponentielle et <I>P</I>=<I>X</I>.</P><P>Montrons que ce deuxième cas est en fait exclus:
en effet si <I>P</I>=<I>X</I>=exp(<I>Y</I>) est une exponentielle, on a alors 
<I>D</I>=<I>X</I><SUP><I>k</I></SUP> et <I>Q</I>=1.
Comme <I>P</I>&#X2032;=<I>Y</I>&#X2032;<I>X</I>, (<A HREF="#eq:estpolynome">18</A>) devient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>X</I> (<I>N</I>&#X2032; &#X2212; <I>k</I> <I>N</I> <I>Y</I>&#X2032; )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>X</I><SUP><I>k</I>+1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
 est un polynôme en <I>X</I> </TD></TR>
</TABLE><P>
Comme <I>X</I> ne divise pas <I>N</I>, <I>N</I> possède donc un coefficient constant 
<I>a</I><SUB>0</SUB> non nul. Le coefficient constant de <I>N</I>&#X2032;&#X2212;<I>kNY</I>&#X2032; est <I>a</I><SUB>0</SUB>&#X2032;&#X2212;<I>ka</I><SUB>0</SUB> <I>Y</I>&#X2032;. 
Si ce terme était nul alors <I>a</I><SUB>0</SUB>&#X2032;=<I>ka</I><SUB>0</SUB> <I>Y</I>&#X2032; donc <I>a</I><SUB>0</SUB>=<I>c</I> exp(<I>kY</I>)=<I>cX</I><SUP><I>k</I></SUP> 
or <I>a</I><SUB>0</SUB> ne dépend pas de <I>X</I> donc <I>c</I>=0 donc <I>a</I><SUB>0</SUB>=0, absurde. 
Donc <I>X</I> ne divise pas <I>N</I>&#X2032;&#X2212;<I>kNY</I>&#X2032;.
Comme <I>X</I><SUP><I>k</I>+1</SUP> divise  &#X220F;<I>P</I><SUB><I>j</I></SUB> <I>X</I> (<I>N</I>&#X2032; &#X2212; <I>k</I> <I>N</I> <I>Y</I>&#X2032; ), on en déduit que
<I>X</I><SUP><I>k</I></SUP> divise un des <I>P</I><SUB><I>j</I></SUB>. Donc <I>k</I>=1 et <I>P</I><SUB><I>j</I></SUB>=<I>XQ</I><SUB><I>j</I></SUB>. 
Revenons maintenant à (<A HREF="#eq:g">16</A>), on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>=ln(<I>g</I>) = ln(<I>C</I>)+<I>j</I> ln(<I>XQ</I><SUB><I>j</I></SUB>)+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I> &#X2260; <I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>l</I> ln(<I>P</I><SUB><I>l</I></SUB>) </TD></TR>
</TABLE><P>
on dérive :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>&#X2032;=ln(<I>C</I>)&#X2032;+<I>jY</I>&#X2032;+<I>j</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>Q</I><SUB><I>j</I></SUB>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>Q</I><SUB><I>j</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I> &#X2260; <I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>l</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>l</I></SUB>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>l</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on voit qu&#X2019;il n&#X2019;est plus nécessaire de multiplier <I>f</I>&#X2032; par <I>P</I><SUB><I>j</I></SUB>
pour avoir un polynôme, multiplier par <I>Q</I><SUB><I>j</I></SUB> suffit, plus précisément
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I> &#X2260; <I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB><I>l</I></SUB> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><I>Q</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>&#X2032; <I>D</I> &#X2212; <I>N</I> <I>D</I>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
 est un polynôme en <I>X</I>. 
</TD></TR>
</TABLE><P>
donc <I>X</I><SUP><I>k</I>+1</SUP> divise 
 (&#X220F;<SUB><I>l</I> &#X2260; <I>j</I></SUB><I>P</I><SUB><I>l</I></SUB> ) <I>Q</I><SUB><I>j</I></SUB> <I>X</I> (<I>N</I>&#X2032; &#X2212; <I>k</I> <I>N</I> <I>Y</I>&#X2032; ) 
ce qui est impossible.</P><P>Donc <I>D</I>=1 dans tous les cas et on a <I>f</I>=<I>N</I>. Donc 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>&#X2032;=<I>N</I>&#X2032;=ln(<I>C</I>)&#X2032;+</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>j</I> <I>P</I><SUB><I>j</I></SUB>&#X2032;/<I>P</I><SUB><I>j</I></SUB> 
 est un polynôme par rapport à <I>X</I> </TD></TR>
</TABLE><P>
On en déduit que les <I>P</I><SUB><I>j</I></SUB> ne dépendent pas de <I>X</I> sauf si
<I>X</I> est une exponentielle et <I>P</I><SUB><I>j</I></SUB>=<I>X</I>. 
Dans les deux cas <I>N</I>&#X2032; ne
dépend pas de <I>X</I> donc le polynôme <I>N</I> est de degré 0 ou 1 en <I>X</I>
(si <I>X</I> est une exponentielle, <I>N</I> est forcément de degré 0)
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>X</I>=exp(<I>Y</I>) est une exponentielle (avec <I>Y</I> élémentaire
ne dépendant pas de <I>X</I>), alors <I>f</I>=<I>N</I> est indépendant de <I>X</I>.
On retire <I>jY</I> à <I>f</I> et on divise <I>g</I> par <I>X</I><SUP><I>j</I></SUP> 
(en posant <I>j</I>=0 si aucun des <I>P</I><SUB><I>j</I></SUB> n&#X2019;est égal à <I>X</I>), 
qui devient indépendant de <I>X</I>, on conserve ainsi l&#X2019;égalité <I>f</I>=ln(<I>g</I>)
mais avec une variable de moins dans la tour de variables par
rapport à laquelle <I>f</I> et <I>g</I> sont élémentaires.
</LI><LI CLASS="li-itemize">Si <I>X</I> n&#X2019;est pas une exponentielle, <I>N</I>=<I>cX</I>+<I>d</I> avec <I>c</I>
dans le corps de constantes, et <I>d</I> indépendant de <I>X</I>.
Si <I>X</I>=<I>x</I>, on a <I>g</I>=exp(<I>cx</I>+<I>d</I>) qui n&#X2019;est rationnel que si
<I>c</I>=0. On a alors <I>d</I> donc <I>f</I> et <I>g</I> constants.
Si <I>X</I>=ln(<I>Y</I>) est un logarithme (avec <I>Y</I> élémentaire
ne dépendant pas de <I>X</I>), alors &#X2200; <I>j</I>, <I>P</I><SUB><I>j</I></SUB>=1 donc <I>g</I> est élémentaire
indépendante de <I>X</I>. 
On a alors :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>=<I>N</I>=<I>c</I>ln(<I>Y</I>)+<I>d</I> = ln(<I>g</I>) </TD></TR>
</TABLE>
avec <I>c</I> dans le corps des constantes, <I>d</I> et <I>g</I> élémentaires
indépendants de <I>X</I>. On cherche maintenant la fonction
élémentaire <I>d</I>. Cette fonction n&#X2019;est pas le logarithme d&#X2019;une
fonction élémentaire en général car <I>c</I> n&#X2019;est pas forcément entier,
mais <I>d</I>&#X2032; a les mêmes propriétés que la dérivée du logarithme
d&#X2019;une fonction élémentaire.
On peut donc reprendre le même raisonnement mais avec une variable de moins
dans la tour de variables. Si la tour qu&#X2019;on a choisie est normalisée,
alors <I>Y</I> ne contient au numérateur et au dénominateur aucune puissance
d&#X2019;une exponentielle d&#X2019;une variable de la tour donc le polynôme <I>P</I><SUB><I>j</I></SUB>
du cas précédent ne peut provenir de <I>Y</I> ce qui entraine que <I>j</I>
est bien entier dans le cas précédent (bien que <I>c</I> ne le soit
pas forcément).
</LI></UL><P>Après avoir fait une récurrence sur le nombre de variables de la tour,
on a donc <I>f</I> qui s&#X2019;exprime comme combinaison linéaire à coefficients
entiers des arguments <I>g</I><SUB><I>k</I></SUB> des variables exponentielles <I>f</I><SUB><I>k</I></SUB>=exp(<I>g</I><SUB><I>k</I></SUB>)
de la tour et à coefficients a priori quelconque des variables logarithmes
<I>f</I><SUB><I>l</I></SUB>=ln(<I>g</I><SUB><I>l</I></SUB>) de la tour :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>j</I><SUB><I>k</I></SUB> <I>g</I><SUB><I>k</I></SUB> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>l</I></SUB> ln(<I>g</I><SUB><I>l</I></SUB>) = ln(<I>g</I>) </TD></TR>
</TABLE><P>
Comme <I>g</I> est élémentaire, <I>h</I>=<I>g</I>/&#X220F;<SUB><I>k</I></SUB> exp(<I>g</I><SUB><I>k</I></SUB>)<SUP><I>j</I><SUB><I>k</I></SUB></SUP>
est élémentaire de logarithme &#X2211;<SUB><I>l</I></SUB> <I>x</I><SUB><I>l</I></SUB> ln(<I>g</I><SUB><I>l</I></SUB>) .
Montrons que si les arguments des ln sont des polynômes
sans facteurs multiples, alors
les <I>x</I><SUB><I>l</I></SUB> sont entiers. Rappelons
que les ln(<I>g</I><SUB><I>l</I></SUB>) sont algébriquement indépendants, on peut donc
construire des polynômes irréductibles <I>I</I><SUB><I>l</I></SUB> par rapport aux variables
de la tour tels que <I>I</I><SUB><I>l</I></SUB> divise une fois <I>g</I><SUB><I>l</I></SUB> mais ne divise pas les <I>g</I><SUB><I>k</I></SUB>
précédents. Soit <I>h</I>=&#X220F;<SUB><I>j</I> &#X2208; &#X2124;</SUB> <I>P</I><SUB><I>j</I></SUB><SUP><I>j</I></SUP> la factorisation
sans facteurs multiples de <I>h</I>. On dérive alors ln(<I>h</I>) ce qui donne :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>l</I></SUB> <I>g</I><SUB><I>l</I></SUB>&#X2032;/<I>g</I><SUB><I>l</I></SUB> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>j</I> <I>P</I><SUB><I>j</I></SUB>&#X2032;/<I>P</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
où &#X220F;<SUB><I>j</I></SUB> <I>P</I><SUB><I>j</I></SUB><SUP><I>j</I></SUP> est la décomposition sans facteurs multiples
de <I>h</I>. Comme <I>I</I><SUB><I>l</I></SUB> divise un et un seul des <I>P</I><SUB><I>j</I></SUB> on en déduit
que <I>x</I><SUB><I>l</I></SUB> est égal au <I>j</I> correspondant et est donc entier.
(Remarque: si on n&#X2019;impose pas aux arguments des logarithmes
d&#X2019;être des polynômes sans facteurs carrés, 
on obtiendrait ici des coefficients rationnels).</P><P><B>En pratique</B>:<BR>
On peut effecter l&#X2019;algorithme de la manière suivante : 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
on cherche les variables généralisées de l&#X2019;expression
qui dépendent de <I>x</I>.
</LI><LI CLASS="li-itemize">On ajoute les variables généralisées en commençant par
la moins longue
</LI><LI CLASS="li-itemize">Si c&#X2019;est un logarithme, on extrait les puissances des
exponentielles précédentes dont il dépend.
On cherche des relations entre fonctions ln en les réécrivant
comme combinaison linéaire de ln indépendants. Pour avoir
des ln indépendants, on se ramène d&#X2019;abord à des polynômes
sans facteurs multiples en utilisant la relation ln(<I>a</I>/<I>b</I>)=ln(<I>a</I>)&#X2212;ln(<I>b</I>) 
et en écrivant la factorisation sans facteurs multiples 
de chaque polynôme argument, puis
on extrait le PGCD 2 à 2 des arguments de logarithmes jusqu&#X2019;à
obtenir des arguments de ln premiers entre eux.
</LI><LI CLASS="li-itemize">Si c&#X2019;est une exponentielle, on teste
si son argument est combinaison linéaire à coefficients rationnels :
<UL CLASS="itemize"><LI CLASS="li-itemize">
des arguments des exponentielles précédentes, 
</LI><LI CLASS="li-itemize">des ln des logarithmes précédents,
</LI><LI CLASS="li-itemize">de ln(<I>x</I>) et de <I>i</I>*&#X3C0;.
</LI></UL>
Pour cela on substitue les ln par des indéterminées,
et on dérive une fois par rapport à cette indéterminée, le
résultat doit être un rationnel, pour les variables exponentielles,
il faut réduire au même dénominateur et résoudre le système
linéaire obtenu en identifiant les coefficients du numérateur.
Si l&#X2019;exponentielle est indépendante des précédentes, 
on extrait de l&#X2019;exponentielle à rajouter la partie linéaire de la 
dépendance en les ln précédents si le coefficient correspondant est
entier. Par exemple, on réécrit :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>xe</I><SUP>2 ln(<I>x</I>)+ln(<I>x</I>)<SUP>2</SUP></SUP> = <I>x</I><SUP>3</SUP> <I>e</I><SUP>ln(<I>x</I>)<SUP>2</SUP></SUP> </TD></TR>
</TABLE>
</LI></UL><P><B>Remarque</B><BR>
On n&#X2019;est pas obligé de se limiter aux seules fonctions logarithmes
et exponentielles, l&#X2019;essentiel est de pouvoir tester l&#X2019;indépendance
algébrique des expressions créées. Pour éviter d&#X2019;avoir à introduire
des exponentielles et logarithmes complexes dans une expression
réelle, on peut autoriser
par exemple des extensions en tangente ou en arctangente.</P><!--TOC subsubsection Théorème de Liouville-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc57">9.2.3</A>  Théorème de Liouville</H4><!--SEC END --><P>
On a vu que la dérivée d&#X2019;une fonction élémentaire dépendant 
d&#X2019;une tour de variables est une fonction élémentaire dépendant 
de la même tour de variables.
Réciproquement, supposons qu&#X2019;une fonction élémentaire admette
une primitive qui soit élémentaire, c&#X2019;est-à-dire qu&#X2019;elle doit
être une fraction rationelle par rapport à une tour de variables
mais pas forcément identique à celle de départ. Alors, si une telle
écriture existe, à des termes logarithmiques près, elle
ne peut dépendre que de la même tour de variables, plus précisément
on a le théorème de Liouville :
</P><DIV CLASS="theorem"><B>Théorème 7</B>  <EM>
Soit </EM><EM><I>f</I></EM><EM> une fonction élémentaire par rapport à une tour de variables </EM><EM><I>T</I></EM><EM>
et un corps de constantes </EM><EM><I>K</I></EM><EM> admettant une primitive élémentaire </EM><EM><I>F</I></EM><EM>. Alors 
il existe un nombre fini de constantes </EM><EM><I>c</I></EM><SUB><EM>1</EM></SUB><EM>,...,<I>c</I></EM><SUB><EM><I>n</I></EM></SUB><EM> et de fonctions
élémentaires </EM><EM><I>v</I></EM><SUB><EM>1</EM></SUB><EM>,...,<I>v</I></EM><SUB><EM><I>n</I></EM></SUB><EM> par rapport à </EM><EM><I>T</I></EM><EM> avec comme corps de constantes
une extension algébrique </EM><EM><I>K</I>&#X2032;</EM><EM> de </EM><EM><I>K</I></EM><EM> tel que </EM><EM><I>F</I> &#X2212; &#X2211;</EM><SUB><EM><I>k</I></EM></SUB><EM> <I>c</I></EM><SUB><EM><I>k</I></EM></SUB><EM> </EM><EM>ln</EM><EM>(<I>v</I></EM><SUB><EM><I>k</I></EM></SUB><EM>) </EM><EM>
soit élémentaire par rapport à </EM><EM><I>T</I></EM><EM> et </EM><EM><I>K</I></EM><EM>.
</EM></DIV><P><B>Preuve:</B><SUP><A NAME="text10" HREF="#note10">10</A></SUP><BR>
Soit <I>f</I> élémentaire de tour <I>T</I><SUB>1</SUB> (corps <I>K</I>) et 
<I>F</I> sa primitive supposée élémentaire de tour <I>T</I><SUB>2</SUB> et de corps <I>K</I>&#X2032;
une extension algébrique de <I>K</I>. 
On commence par rajouter après les élements de <I>T</I><SUB>1</SUB> les 
élements nécessaires de <I>T</I><SUB>2</SUB> pour obtenir une tour <I>T</I> par rapport
à laquelle <I>f</I> et <I>F</I> sont élémentaires (plus précisément <I>F</I> sera
élémentaire quitte à autoriser des puissances fractionnaires
des variables exponentielles de <I>T</I><SUB>1</SUB>). Le théorème de structure
de Risch permet de faire cela, en effet on regarde pour chaque
élément de <I>T</I><SUB>2</SUB> s&#X2019;il est algébriquement indépendant des éléments
de <I>T</I><SUB>1</SUB> ou non. S&#X2019;il l&#X2019;est, on le rajoute à la tour <I>T</I>, s&#X2019;il
ne l&#X2019;est pas alors dans le cas d&#X2019;un logarithme il est élémentaire
et dans le cas d&#X2019;une exponentielle, une de ses puissances est
élémentaire. Donc <I>F</I> est bien une fraction rationnelle par rapport
aux éléments logarithmiques de <I>T</I><SUB>1</SUB>, aux racines <I>n</I>-ième
des éléments exponentiels de <I>T</I><SUB>1</SUB> et à des éléments de <I>T</I><SUB>2</SUB>
dans cet ordre (le corps des constantes étant <I>K</I>&#X2032;).</P><P><B>Première étape:</B><BR>
Commençons par les éléments restant de <I>T</I><SUB>2</SUB>. Soit <I>X</I><SUB><I>k</I></SUB> l&#X2019;élément
au sommet de la tour <I>T</I>. La dérivée <I>f</I> de <I>F</I> par rapport à <I>X</I><SUB><I>k</I></SUB>
ne dépend pas de <I>X</I><SUB><I>k</I></SUB>. Donc soit <I>F</I> ne dépend pas de <I>X</I><SUB><I>k</I></SUB> et
on passe à la variable suivante, soit <I>X</I><SUB><I>k</I></SUB>=ln(<I>v</I><SUB><I>k</I></SUB>) est un logarithme
et <I>F</I>=<I>c</I><SUB><I>k</I></SUB> ln(<I>v</I><SUB><I>k</I></SUB>)+<I>d</I><SUB><I>k</I></SUB> avec <I>c</I><SUB><I>k</I></SUB> &#X2208; <I>K</I>&#X2032; et <I>v</I><SUB><I>k</I></SUB> et <I>d</I><SUB><I>k</I></SUB> 
indépendants de <I>X</I><SUB><I>k</I></SUB>. S&#X2019;il
n&#X2019;y a pas d&#X2019;autres éléments restants de <I>T</I><SUB>2</SUB>, on passe à la 2ème étape.
Sinon soit <I>X</I><SUB><I>k</I>&#X2212;1</SUB> la variable suivante 
(juste en-dessous de <I>X</I><SUB><I>k</I></SUB> dans la tour).
En dérivant, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I>&#X2032;= <I>c</I><SUB><I>k</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + <I>d</I><SUB><I>k</I></SUB>&#X2032; = <I>f</I></TD></TR>
</TABLE><P>
Supposons que <I>v</I><SUB><I>k</I></SUB> dépende de <I>X</I><SUB><I>k</I>&#X2212;1</SUB>, on fait alors un raisonnement 
analogue à celui de la preuve du théorème de structure de Risch, en décomposant
<I>v</I><SUB><I>k</I></SUB> en produit/quotient de facteurs sans multiplicités <I>v</I><SUB><I>k</I></SUB>=&#X220F;<I>P</I><SUB><I>j</I></SUB><SUP><I>j</I></SUP>
et en écrivant <I>d</I><SUB><I>k</I></SUB>=<I>N</I>/<I>D</I> on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>P</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I>&#X2032; <I>D</I> &#X2212; <I>N</I> <I>D</I>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
est un polynôme en <I>X</I><SUB><I>k</I>&#X2212;1</SUB>. On en déduit comme précédemment que
<I>D</I>=1, <I>N</I>&#X2032;=<I>d</I><SUB><I>k</I></SUB>&#X2032; est indépendant de <I>X</I><SUB><I>k</I>&#X2212;1</SUB>. Comme on a supposé que
<I>v</I><SUB><I>k</I></SUB> dépend de <I>X</I><SUB><I>k</I>&#X2212;1</SUB>, <I>X</I><SUB><I>k</I>&#X2212;1</SUB>=exp(<I>Y</I><SUB><I>k</I>&#X2212;1</SUB>) est alors une 
exponentielle, <I>N</I>=<I>d</I><SUB><I>k</I></SUB> ne dépend pas de <I>X</I><SUB><I>k</I>&#X2212;1</SUB> et l&#X2019;un des <I>P</I><SUB><I>j</I></SUB>=<I>X</I><SUB><I>k</I>&#X2212;1</SUB>
(sinon tous les <I>P</I><SUB><I>j</I></SUB> seraient constants en <I>X</I><SUB><I>k</I>&#X2212;1</SUB> donc <I>v</I><SUB><I>k</I></SUB> aussi).
On élimine alors la variable <I>X</I><SUB><I>k</I>&#X2212;1</SUB> en écrivant 
ln(<I>v</I><SUB><I>k</I></SUB>)=<I>jY</I><SUB><I>k</I>&#X2212;1</SUB>+ln(<I>w</I><SUB><I>k</I></SUB>), avec <I>Y</I><SUB><I>k</I>&#X2212;1</SUB> et <I>w</I><SUB><I>k</I></SUB> élémentaires et
indépendants de <I>X</I><SUB><I>k</I>&#X2212;1</SUB>.</P><P>Si <I>v</I><SUB><I>k</I></SUB> est indépendant de <I>X</I><SUB><I>k</I>&#X2212;1</SUB>, alors <I>d</I><SUB><I>k</I></SUB>&#X2032; aussi donc
soit <I>d</I><SUB><I>k</I></SUB> est indépendant de <I>X</I><SUB><I>k</I>&#X2212;1</SUB> et on passe à la variable
suivante, soit <I>X</I><SUB><I>k</I>&#X2212;1</SUB> est un logarithme et 
<I>d</I><SUB><I>k</I></SUB>=<I>c</I><SUB><I>k</I>&#X2212;1</SUB>ln(<I>v</I><SUB><I>k</I>&#X2212;1</SUB>)+<I>d</I><SUB><I>k</I>&#X2212;1</SUB>.
En continuant pour toutes les variables restantes de <I>T</I><SUB>2</SUB>, on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I><SUB><I>k</I></SUB> ln<I>v</I><SUB><I>k</I></SUB> +<I>d</I> </TD></TR>
</TABLE><P>
avec <I>d</I> et <I>v</I><SUB><I>k</I></SUB> élémentaires pour <I>T</I><SUB>1</SUB> (avec exponentielles
modifiées en en prenant une racine <I>n</I>-ième) et <I>K</I>&#X2032;.</P><P><B>Deuxième étape</B>
Il s&#X2019;agit de montrer que pour les exponentielles, il n&#X2019;est en fait pas
nécessaire de prendre de racines <I>n</I>-ième. La compréhension
de cette étape demande
un peu de familiarité avec l&#X2019;algorithme de Risch (cf. infra).
On va faire la preuve pour la variable au sommet de la tour <I>T</I><SUB>1</SUB> si
c&#X2019;est une exponentielle. On verra dans le déroulement
de l&#X2019;algorithme de Risch que pour les autres variables, il y a
appel récursif de l&#X2019;algorithme d&#X2019;intégration, donc traiter
la variable au sommet suffira.
Soit donc exp(<I>Y</I>) la variable au sommet de la tour <I>T</I><SUB>1</SUB>, on note
<I>X</I>=exp(<I>Y</I>/<I>n</I>) la racine <I>n</I>-ième de cette variable qui est utilisée
pour exprimer <I>F</I>=&#X2211;<I>c</I><SUB><I>k</I></SUB> ln<I>v</I><SUB><I>k</I></SUB> + <I>N</I>/<I>D</I> comme une fraction
rationnelle en <I>X</I> alors que <I>f</I>=<I>F</I>&#X2032; est une fraction rationnelle en <I>X</I><SUP><I>n</I></SUP>.
On a donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>&#X2211;</FONT><I>c</I><SUB><I>k</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X2032; 
=<I>f</I>=fraction rationnelle en (<I>X</I><SUP><I>n</I></SUP>) </TD></TR>
</TABLE><P>
Notons que le fait que <I>X</I> soit une exponentielle est essentiel, 
car par exemple l&#X2019;intégrale d&#X2019;une fraction rationnelle dépendant de <I>x</I><SUP><I>n</I></SUP> 
comme <I>x</I><SUP>3</SUP> ou 1/(<I>x</I><SUP>3</SUP>&#X2212;1) ne s&#X2019;exprime pas en fonction de <I>x</I><SUP>3</SUP>.
On traite d&#X2019;abord la partie polynomiale généralisée de <I>f</I> en <I>X</I><SUP><I>n</I></SUP>:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>&#X2208; &#X2124;</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>j</I></SUB> (<I>X</I><SUP><I>n</I></SUP>)<SUP><I>j</I></SUP></TD></TR>
</TABLE><P>
Son intégrale est un polynôme généralisé, éventuellement dépendant
de <I>X</I>, soit &#X2211;<SUB><I>j</I>&#X2208; &#X2124;</SUB> <I>A</I><SUB><I>j</I></SUB> <I>X</I><SUP><I>j</I></SUP>. On dérive, et on obtient
pour <I>k</I> non multiple de <I>n</I>, <I>A</I><SUB><I>k</I></SUB> <I>Y</I>/<I>n</I>+<I>A</I><SUB><I>k</I></SUB>&#X2032;=0 dont <I>A</I><SUB><I>k</I></SUB>=0 est
solution. La partie polynôme généralisé ne dépend donc que de <I>X</I><SUP><I>n</I></SUP>.
On effectue aussi les intégrations par parties pour réduire le 
dénominateur de <I>f</I> à un polynôme sans facteurs multiples (réduction
de Hermite), ce qui se fait en introduisant des fractions rationnelles 
en <I>X</I><SUP><I>n</I></SUP> uniquement. Reste la partie logarithmique. On utilise le critère
du résultant, les coefficients des logarithmes sont les racines 
<I>c</I><SUB><I>k</I></SUB> du polynôme en <I>t</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">Res<SUB><I>X</I></SUB> (<I>D</I>,<I>N</I>&#X2212;<I>tD</I>&#X2032;) </TD></TR>
</TABLE><P>
où ces racines doivent être indépendantes de <I>x</I> (puisque <I>F</I> existe)
et les <I>v</I><SUB><I>k</I></SUB> correspondants sont égaux à
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">gcd(<I>D</I>,<I>N</I>&#X2212;<I>c</I><SUB><I>k</I></SUB> <I>D</I>&#X2032;) </TD></TR>
</TABLE><P>
Or comme <I>X</I> est une exponentielle, <I>D</I>&#X2032; est un polynôme en
<I>X</I><SUP><I>n</I></SUP>, de même que <I>D</I> et <I>N</I>, donc <I>v</I><SUB><I>k</I></SUB> est un polynôme
en <I>X</I><SUP><I>n</I></SUP>.</P><P><B>Troisième étape</B>
Il reste enfin à montrer que seuls les <I>c</I><SUB><I>k</I></SUB> et <I>v</I><SUB><I>k</I></SUB> nécessitent
une extension algébrique de <I>K</I>. Ceci est encore une conséquence
de l&#X2019;algorithme de Risch, la construction
de la partie polynomiale (éventuellement généralisée) et de la 
partie fractionnaire ne font en effet intervenir que des coefficients
dans le corps <I>K</I>.</P><!--TOC subsection L&#X2019;algorithme de Risch-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc58">9.3</A>  L&#X2019;algorithme de Risch</H3><!--SEC END --><P> <A NAME="sec:risch"></A>
On suppose dans la suite qu&#X2019;on s&#X2019;est ramené à une fraction rationnelle
par rapport à une tour de variables (où on a effectué les simplifications
évidentes ln&#X2218; exp, ainsi que exp&#X2218; ln, dans le
premier cas en extrayant les facteurs évidents en les variables
précédentes exponentielles, dans le deuxième cas en extrayant la
partie linéaire à coefficient entier en les variables logarithmes
précédentes).
On note <I>X</I> la variable au sommet de la tour et <I>N</I><SUB>0</SUB>/<I>D</I><SUB>0</SUB> l&#X2019;écriture
de la fonction élémentaire comme fraction irréductible avec
<I>N</I><SUB>0</SUB> et <I>D</I><SUB>0</SUB> polynômes en <I>X</I>.</P><P><B>Exemples</B><BR>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell">(2<I>x</I><SUP>2</SUP>+1) <I>e</I><SUP><I>x</I><SUP>2</SUP></SUP></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><I>X</I>=<I>e</I><SUP><I>x</I><SUP>2</SUP></SUP></TD><TD ALIGN=left NOWRAP><I>N</I><SUB>0</SUB>=(2<I>x</I><SUP>2</SUP>+1) <I>X</I>, <I>D</I><SUB>0</SUB>=1 </TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I> ln(<I>x</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+ln(<I>x</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><I>X</I>=ln(<I>x</I>)</TD><TD ALIGN=left NOWRAP><I>N</I><SUB>0</SUB>=<I>xX</I>, <I>D</I><SUB>0</SUB>=<I>x</I>+<I>X</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>La première étape va consister à se ramener à un dénominateur sans facteurs
multiples. Elle est analogue au cas des fractions
rationnelles de <I>x</I> et est basée sur l&#X2019;identité de Bézout entre
<I>P</I> et <I>P</I>&#X2032; vu comme polynômes en la variable du haut de la tour. 
Il apparait toutefois une difficulté pour les
extensions exponentielles, à savoir que <I>X</I>=<I>e</I><SUP><I>f</I></SUP> et <I>X</I>&#X2032;=<I>f</I>&#X2032; <I>X</I>
ne sont pas premiers entre eux comme polynômes en <I>X</I>, on devra
traiter le pôle 0 d&#X2019;une fraction rationnelle en une exponentielle <I>X</I> comme
on traite l&#X2019;intégration d&#X2019;un polynôme en <I>x</I>.
Si <I>P</I> est sans facteurs multiples et premier avec <I>X</I>, alors
<I>P</I>(<I>X</I>) et <I>P</I>(<I>X</I>)&#X2032;=<I>f</I>&#X2032; <I>X</I> <I>P</I>&#X2032;(<I>X</I>) vu comme
polynômes en <I>X</I> n&#X2019;ont pas de facteurs en commun.</P><P>On commence donc, si <I>X</I> est une exponentielle et <I>D</I><SUB>0</SUB> un
multiple de <I>X</I>, par appliquer Bézout pour décomposer la fraction <I>N</I><SUB>0</SUB>/<I>D</I><SUB>0</SUB>
en :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB>0</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">
=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB>1</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I><SUB>1</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>X</I><SUP><I>k</I></SUP> </TD></TR>
</TABLE></TD><TD CLASS="dcell"> ,    gcd(<I>X</I>,<I>D</I><SUB>1</SUB>)=1, <I>D</I><SUB>0</SUB>=<I>X</I><SUP><I>k</I></SUP> <I>D</I><SUB>1</SUB></TD></TR>
</TABLE><P>
On isole aussi la partie polynômiale en effectuant
la division euclidienne de <I>N</I><SUB>0</SUB> par <I>D</I><SUB>0</SUB> (ou de <I>N</I><SUB>1</SUB> par <I>D</I><SUB>1</SUB> si <I>X</I>
est une exponentielle),
on obtient alors une écriture sous la forme :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>j</I></SUB> <I>X</I><SUP><I>j</I></SUP></TD></TR>
</TABLE><P>
où la somme sur <I>j</I> est finie et porte sur des entiers positifs ou nul 
si <I>X</I> n&#X2019;est pas une exponentielle, ou sur des entiers relatifs si <I>X</I>
est une exponentielle.</P><P>On effectue la même écriture sur la partie fractionnaire de <I>F</I>,
et en identifiant les parties polynomiales et éventuellement la partie
polaire en 0 si <I>X</I> est une exponentielle, on peut séparer l&#X2019;intégration
en 2 parties: intégration de la partie polynomiale (généralisée)
et intégration de la partie fractionnaire propre.</P><P><B>Exemples</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 (2<I>x</I><SUP>2</SUP>+1) <I>e</I><SUP><I>x</I><SUP>2</SUP></SUP> = 0+(2<I>x</I><SUP>2</SUP>+1)<I>X</I> est un polynôme,
</LI><LI CLASS="li-itemize"><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I> ln(<I>x</I>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+ln(<I>x</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>xX</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+<I>X</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">=&#X2212;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2</SUP></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I>+<I>X</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">+<I>x</I></TD></TR>
</TABLE>
la partie polynomiale est <I>x</I> (de degré 0 en <I>X</I>), la partie fractionnaire
est &#X2212;<I>x</I><SUP>2</SUP>/(<I>x</I>+<I>X</I>)
</LI><LI CLASS="li-itemize"><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>(<I>e</I><SUP>2<I>x</I></SUP>+1)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP><I>x</I></SUP>(<I>e</I><SUP><I>x</I></SUP>+1)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>x</I>(<I>X</I><SUP>2</SUP>+1)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>X</I>(<I>X</I>+1)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
= &#X2212;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>X</I>+1)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + <I>xX</I><SUP>&#X2212;1</SUP></TD></TR>
</TABLE>
la partie polynôme généralisé est <I>xX</I><SUP>&#X2212;1</SUP>
</LI></UL><!--TOC subsubsection Intégration d&#X2019;une fraction propre-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc59">9.3.1</A>  Intégration d&#X2019;une fraction propre</H4><!--SEC END --><!--TOC subsubsection Réduction sans facteurs multiples-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc60">9.3.2</A>  Réduction sans facteurs multiples</H4><!--SEC END --><P>
On factorise <I>D</I> en &#X220F;<SUB><I>i</I></SUB> <I>P</I><SUB><I>i</I></SUB><SUP><I>i</I></SUP> avec <I>P</I><SUB><I>i</I></SUB> sans facteurs multiples 
(et les <I>P</I><SUB><I>i</I></SUB> premiers entre eux 2 à 2) et on décompose
en éléments simples relativement à cette factorisation (en appliquant
Bézout) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>&gt;0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>i</I></SUB><SUP><I>i</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Pour chaque polynome <I>P</I><SUB><I>i</I></SUB>, on applique Bézout à <I>P</I><SUB><I>i</I></SUB> et <I>P</I>&#X2032;<SUB><I>i</I></SUB> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB><I>i</I></SUB> = <I>A</I><SUB><I>i</I></SUB><I>P</I><SUB><I>i</I></SUB>+<I>B</I><SUB><I>i</I></SUB><I>P</I>&#X2032;<SUB><I>i</I></SUB> &#X21D2; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>i</I></SUB><SUP><I>i</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>A</I><SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>i</I></SUB><SUP><I>i</I>&#X2212;1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB><I>i</I></SUB><I>P</I><SUB><I>i</I></SUB>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>i</I></SUB><SUP><I>i</I></SUP></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on intègre par parties le second terme
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>i</I></SUB><SUP><I>i</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>A</I><SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB><I>i</I></SUB><SUP><I>i</I>&#X2212;1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">
&#X2212; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB><I>i</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>i</I>&#X2212;1)<I>P</I><SUB><I>i</I></SUB><SUP><I>i</I>&#X2212;1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUB><I>i</I></SUB>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>i</I>&#X2212;1)<I>P</I><SUB><I>i</I></SUB><SUP><I>i</I>&#X2212;1</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell">  </TD></TR>
</TABLE><P>
on rassemble les deux intégrales ayant <I>P</I><SUB><I>i</I></SUB><SUP><I>i</I>&#X2212;1</SUP> au dénominateur
et on recommence jusqu&#X2019;à avoir une puissance 1 au dénominateur. Il reste
alors à intégrer une somme de fractions du type <I>N</I>/<I>D</I> avec
<I>D</I> et <I>D</I>&#X2032; premiers entre eux.</P><P><B>Exemple</B><BR>
On reprend le dernier exemple de la section précédente pour
éliminer la puissance 2 au dénominateur:
<I>N</I><SUB>2</SUB>=2<I>x</I> et <I>P</I><SUB>2</SUB>=(<I>X</I>+1) avec <I>X</I>=<I>e</I><SUP><I>x</I></SUP>. On a <I>P</I><SUB>2</SUB>&#X2032;=<I>X</I>, donc <I>A</I><SUB>2</SUB>=2<I>x</I> et
<I>B</I><SUB>2</SUB>=&#X2212;2<I>x</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>X</I>+1)<SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> =</TD><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB>2</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + 
</TD><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;2<I>x</I> <I>P</I><SUB>2</SUB>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB>2</SUB><SUP>2</SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB>2</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB>2</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">
&#X2212; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>P</I><SUB>2</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
il reste donc à intégrer (2<I>x</I>&#X2212;2)/(<I>e</I><SUP><I>x</I></SUP>+1).</P><!--TOC subsubsection La partie logarithmique-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc61">9.3.3</A>  La partie logarithmique</H4><!--SEC END --><P>
Comme on l&#X2019;a vu lors de la preuve du théorème de structure de Risch,
si on dérive une fraction en <I>X</I>, le dénominateur de la dérivée ne
peut se décomposer qu&#X2019;en produit de facteurs de multiplicité supérieure
ou égale à 2. Il en résulte que la fraction à intégrer résiduelle (encore
notée <I>f</I>=<I>N</I>/<I>D</I>) après l&#X2019;étape de réduction ci-dessus ne peut provenir que de la
dérivation de <I>F</I>=&#X2211;<SUB><I>k</I></SUB> <I>c</I><SUB><I>k</I></SUB> ln(<I>v</I><SUB><I>k</I></SUB>) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">=<I>F</I>&#X2032;= (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I><SUB><I>k</I></SUB> ln(<I>v</I><SUB><I>k</I></SUB>))&#X2032;= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I><SUB><I>k</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
En identifiant les décompositions
en éléments simples de <I>F</I>&#X2032; et <I>f</I>, on montre également que 
les <I>v</I><SUB><I>k</I></SUB> divisent <I>D</I>, plus précisément on peut imposer aux <I>v</I><SUB><I>k</I></SUB>
d&#X2019;être premiers entre eux 2 à 2 et dans ce cas <I>D</I>=&#X220F;<I>v</I><SUB><I>k</I></SUB>. 
Donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I><SUB><I>k</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>v</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>v</I><SUB><I>k</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>N</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>D</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
et :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I><SUB><I>k</I></SUB> <I>v</I><SUB><I>k</I></SUB>&#X2032; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>&#X2260; <I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>v</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
Soit <I>t</I> un paramètre, formons le polynôme <I>N</I>&#X2212;<I>tD</I>&#X2032; :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I>&#X2212;<I>tD</I>&#X2032; = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell">(<I>c</I><SUB><I>k</I></SUB> &#X2212;<I>t</I>) <I>v</I><SUB><I>k</I></SUB>&#X2032; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>&#X2260; <I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>v</I><SUB><I>j</I></SUB> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
donc le pgcd en <I>X</I> des polynômes <I>N</I>&#X2212;<I>tD</I>&#X2032; et <I>D</I> est :
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
si <I>t</I> n&#X2019;est égal à aucun des <I>c</I><SUB><I>k</I></SUB>, <I>N</I>&#X2212;<I>tD</I>&#X2032; est premier
avec <I>v</I><SUB><I>k</I></SUB> pour tout <I>k</I> car <I>v</I><SUB><I>k</I></SUB> divise
&#X2211;<SUB><I>l</I> &#X2260; <I>k</I></SUB> (<I>c</I><SUB><I>l</I></SUB> &#X2212;<I>t</I>) <I>v</I><SUB><I>l</I></SUB>&#X2032; &#X220F;<SUB><I>j</I>&#X2260; <I>l</I></SUB> <I>v</I><SUB><I>j</I></SUB>
et <I>v</I><SUB><I>k</I></SUB>&#X2032;&#X220F;<SUB><I>j</I>&#X2260; <I>k</I></SUB> <I>v</I><SUB><I>j</I></SUB>  est premier avec <I>v</I><SUB><I>k</I></SUB>. Donc
le pgcd est 1.
</LI><LI CLASS="li-itemize">si <I>t</I> est égal à l&#X2019;un des <I>c</I><SUB><I>k</I></SUB>, alors le pgcd est le produit
des <I>v</I><SUB><I>k</I></SUB> tels que <I>c</I><SUB><I>k</I></SUB>=<I>t</I> (notons que dans ce cas on peut
rassembler ces <I>v</I><SUB><I>k</I></SUB> à l&#X2019;intérieur d&#X2019;un même logarithme)
</LI></UL><P>
Considérons le polynôme <I>R</I> de la variable <I>t</I> égal au résultant par rapport
à <I>X</I> des polynômes <I>D</I> et <I>N</I>&#X2212;<I>tD</I>&#X2032; (rappelons qu&#X2019;il s&#X2019;agit du
déterminant du système linéaire <I>AD</I>+<I>B</I>(<I>N</I>&#X2212;<I>tD</I>&#X2032;)=1
où les inconnues sont les coefficients des polynômes <I>A</I> et <I>B</I>, 
ce déterminant est nul si et seulement si le système n&#X2019;a pas
de solution donc si et seulement si <I>D</I> et <I>N</I>&#X2212;<I>tD</I>&#X2032; ne sont pas
premiers entre eux), alors ce polynôme en <I>t</I>
s&#X2019;annule si et seulement si <I>t</I>=<I>c</I><SUB><I>k</I></SUB>. 
On cherche les racines <I>c</I><SUB><I>k</I></SUB> en <I>t</I> de ce polynôme,
elles doivent être indépendantes de <I>x</I> si <I>F</I> est élémentaire,
et dans ce cas la primitive <I>F</I> de <I>f</I>=<I>N</I>/<I>D</I> vaut
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>F</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>c</I><SUB><I>k</I></SUB>  racine de  <I>R</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>c</I><SUB><I>k</I></SUB> ln(gcd(<I>N</I>&#X2212;<I>c</I><SUB><I>k</I></SUB> <I>D</I>&#X2032;,<I>D</I>)) </TD></TR>
</TABLE><P><B>Exemples</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I>&#X2212;2</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>e</I><SUP><I>x</I></SUP>+1</TD></TR>
</TABLE></TD><TD CLASS="dcell">,    <I>D</I>=<I>X</I>+1, <I>D</I>&#X2032;=<I>e</I><SUP><I>x</I></SUP>=<I>X</I>,    <I>N</I>&#X2212;<I>tD</I>&#X2032;=2<I>x</I>&#X2212;2&#X2212;<I>tX</I> </TD></TR>
</TABLE>
On calcule <I>R</I>=&#X2212;2*<I>x</I>&#X2212;<I>t</I>+2, l&#X2019;unique racine est <I>t</I>=2&#X2212;2<I>x</I> qui n&#X2019;est
pas constante donc cette fonction n&#X2019;admet pas de primitive élémentaire.
</LI><LI CLASS="li-itemize"><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(2<I>x</I><SUP>2</SUP>&#X2212;<I>x</I>&#X2212;2)<I>X</I>&#X2212;1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>X</I><SUP>2</SUP>+(<I>x</I>+1)<I>X</I>+<I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">,    <I>X</I>=exp(<I>x</I><SUP>2</SUP>+<I>x</I>)</TD></TR>
</TABLE>
On a <I>D</I>&#X2032;=2(2<I>x</I>+1)<I>X</I><SUP>2</SUP>+(1+(2<I>x</I>+1)(<I>x</I>+1))<I>X</I>+1
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I>=&#X2212;(2<I>x</I>&#X2212;1)(<I>x</I>+1)(2<I>x</I>+1)(<I>x</I>&#X2212;1)<SUP>2</SUP>(<I>t</I>+1)(<I>t</I>&#X2212;1) </TD></TR>
</TABLE>
les racines en <I>t</I> sont constantes et égales à 1 et -1, donc <I>c</I><SUB>1</SUB>=1
et <I>v</I><SUB>1</SUB>=gcd(<I>N</I>&#X2212;<I>D</I>&#X2032;,<I>D</I>)=<I>X</I>+1 et <I>c</I><SUB>2</SUB>=&#X2212;1, <I>v</I><SUB>2</SUB>=gcd(<I>N</I>+<I>D</I>&#X2032;,<I>D</I>)=<I>x</I>+<I>X</I>
donc :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">(2<I>x</I><SUP>2</SUP>&#X2212;<I>x</I>&#X2212;2)<I>X</I>&#X2212;1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>X</I><SUP>2</SUP>+(<I>x</I>+1)<I>X</I>+<I>x</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> = ln(<I>X</I>+1)&#X2212;ln(<I>x</I>+<I>X</I>)</TD></TR>
</TABLE>
</LI></UL><P><B>Remarque importante</B><BR>
Pour les extensions exponentielles ou logarithmiques, 
la dérivée de la partie logarithmique
calculée comme ci-dessus contiendra en général 
une partie entière constante par rapport à <I>X</I>, il faut
donc retirer cette partie entière à la partie polynomiale.</P><!--TOC subsubsection La partie polynomiale (généralisée)-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc62">9.3.4</A>  La partie polynomiale (généralisée)</H4><!--SEC END --><P>
On doit résoudre :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>A</I><SUB><I>j</I></SUB> <I>X</I><SUP><I>j</I></SUP>)&#X2032;=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>j</I></SUB> <I>X</I><SUP><I>j</I></SUP> </TD></TR>
</TABLE><P>
avec une somme sur <I>j</I> &#X2208;&#X2124; si <I>X</I> est une exponentielle et
<I>j</I>&#X2208; &#X2115; sinon.</P><P>Si <I>X</I>=<I>x</I>, <I>j</I>&#X2265; 0 et la résolution est immédiate: on prend <I>A</I><SUB>0</SUB>=0 et 
<I>A</I><SUB><I>j</I>+1</SUB>=<I>a</I><SUB><I>j</I></SUB>/(<I>j</I>+1).</P><!--TOC subsubsection Extension logarithmique-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc63">9.3.5</A>  Extension logarithmique</H4><!--SEC END --><P>
Si <I>X</I>=ln(<I>Y</I>) est un logarithme, <I>j</I> &#X2265; 0 et on doit résoudre :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>&#X2265; 0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>A</I><SUB><I>j</I></SUB>&#X2032;+(<I>j</I>+1)<I>A</I><SUB><I>j</I>+1</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>Y</I>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>Y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">) <I>X</I><SUP><I>j</I></SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>j</I></SUB> <I>X</I><SUP><I>j</I></SUP> </TD></TR>
</TABLE><P>
Soit <I>k</I> la plus grande puissance non nulle de <I>f</I> (<I>a</I><SUB><I>j</I></SUB>=0 
si <I>j</I>&gt;<I>k</I> et <I>a</I><SUB><I>k</I></SUB>&#X2260; 0). Pour <I>j</I>&gt;<I>k</I>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUB><I>j</I></SUB>&#X2032;+(<I>j</I>+1)<I>A</I><SUB><I>j</I>+1</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>Y</I>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>Y</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  =0 </TD></TR>
</TABLE><P>
On résout pour des valeurs de <I>j</I> décroissante, pour <I>j</I> suffisamment
grand, on a <I>A</I><SUB><I>j</I>+1</SUB>=0 car la somme sur <I>j</I> est finie, donc <I>A</I><SUB><I>j</I></SUB>
est constant. Si <I>A</I><SUB><I>j</I></SUB> &#X2260; 0, alors au rang <I>j</I>&#X2212;1, on a 
<I>A</I><SUB><I>j</I>&#X2212;1</SUB> &#X2032; = &#X2212;<I>j</I> <I>A</I><SUB><I>j</I></SUB> <I>Y</I>&#X2032;/<I>Y</I>  qui n&#X2019;admet pas de solutions car 
<I>A</I><SUB><I>j</I>&#X2212;1</SUB> ne peut pas dépendre de <I>X</I>=ln(<I>Y</I>). On en déduit que pour
<I>j</I>&gt;<I>k</I>+1, on a <I>A</I><SUB><I>j</I></SUB>=0 et <I>A</I><SUB><I>k</I>+1</SUB> est constant. En fait la
valeur constante de <I>A</I><SUB><I>k</I>+1</SUB> sera déterminée par une condition
de compatibilité en résolvant l&#X2019;équation au rang du dessous.
On continue la résolution de 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUB><I>j</I></SUB>&#X2032;+(<I>j</I>+1)<I>A</I><SUB><I>j</I>+1</SUB> ln(<I>Y</I>)&#X2032;  = <I>a</I><SUB><I>j</I></SUB> </TD></TR>
</TABLE><P>
par valeur décroissante de <I>j</I>, à chaque
rang on va déterminer <I>A</I><SUB><I>j</I></SUB> à une constante près en résolvant
un problème d&#X2019;intégration (par appel récursif de l&#X2019;algorithme
de Risch, mais si <I>j</I> &#X2260; 0 sans autoriser l&#X2019;ajout de nouveaux 
logarithmes sauf ln(<I>Y</I>))
et la valeur de la constante de <I>A</I><SUB><I>j</I>+1</SUB> (on fait varier <I>A</I><SUB><I>j</I>+1</SUB>
de la constante nécessaire pour absorber le terme en ln(<I>Y</I>)
qui apparait lors de l&#X2019;appel récursif de Risch).
Au rang 0, on est ramené à un problème d&#X2019;intégration avec
une variable de moins (la constante
indéterminée dans <I>A</I><SUB>1</SUB> peut par exemple être choisie comme
le coefficient constant de ln(<I>Y</I>) s&#X2019;il en apparait un en intégrant).</P><P><B>Exemple</B><BR>
<I>X</I>=ln(<I>x</I><SUP>2</SUP>+1) et on cherche l&#X2019;intégrale de <I>X</I><SUP>2</SUP>. On a donc <I>A</I><SUB>3</SUB>
est constant,
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUB>2</SUB>&#X2032; + 3 <I>A</I><SUB>3</SUB> ln(<I>x</I><SUP>2</SUP>+1)&#X2032; = 1</TD></TR>
</TABLE><P>
La primitive de 1 est élémentaire et ne fait pas intervenir de ln
donc <I>A</I><SUB>3</SUB>=0 et <I>A</I><SUB>2</SUB>=<I>x</I>+<I>C</I><SUB>2</SUB>. Au rang 1, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUB>1</SUB>&#X2032; + 3 <I>x</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2<I>x</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>x</I><SUP>2</SUP>+1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> + <I>C</I><SUB>2</SUB> ln(<I>x</I><SUP>2</SUP>+1)&#X2032; = 0</TD></TR>
</TABLE><P>
On calcule la primitive de 6<I>x</I><SUP>2</SUP>/(<I>x</I><SUP>2</SUP>+1) qui doit être une fraction
rationnelle à un <I>C</I>ln(<I>x</I><SUP>2</SUP>+1) près, on voit que ce n&#X2019;est pas le cas
donc <I>X</I><SUP>2</SUP> n&#X2019;admet pas de primitive élémentaire.
Remarque: si on avait voulu intégrer <I>X</I> au lieu de <I>X</I><SUP>2</SUP>, la même
méthode montre que la primitive existe, car au rang 0 il n&#X2019;y
a plus de contraintes sur les ln qu&#X2019;on peut rajouter.</P><!--TOC subsubsection Extension exponentielle-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc64">9.3.6</A>  Extension exponentielle</H4><!--SEC END --><P>
Si <I>X</I>=exp(<I>Y</I>) est une exponentielle, on doit résoudre :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>A</I><SUB><I>j</I></SUB>&#X2032;+<I>j</I> <I>Y</I>&#X2032;<I>A</I><SUB><I>j</I></SUB>) <I>X</I><SUP><I>j</I></SUP> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>a</I><SUB><I>j</I></SUB> <I>X</I><SUP><I>j</I></SUP> </TD></TR>
</TABLE><P>
Ceci va se faire degré par degré :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:rischdiffeq"></A>
<I>A</I><SUB><I>j</I></SUB>&#X2032;+<I>j</I> <I>Y</I>&#X2032; <I>A</I><SUB><I>j</I></SUB> = <I>a</I><SUB><I>j</I></SUB>
    (19)</TD></TR>
</TABLE><P>
<B>Exemple</B><BR>
Pour calculer &#X222B;<I>a</I>(<I>x</I>) exp(<I>x</I><SUP>2</SUP>), on a <I>j</I>=1, et on doit résoudre
l&#X2019;équation différentielle :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUB>1</SUB>&#X2032;+2<I>xA</I><SUB>1</SUB>= <I>a</I>(<I>x</I>)</TD></TR>
</TABLE><P>Pour <I>j</I>=0, il suffit de faire un appel récursif à l&#X2019;algorithme de Risch,
mais pour <I>j</I>&#X2260; 0, la situation se complique!
Notons <I>Z</I> la variable située juste en-dessous de <I>X</I> dans la tour
de variables (dans l&#X2019;exemple ci-dessus <I>Z</I>=<I>x</I>), il s&#X2019;agit de résoudre : 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:rischdiffeq2"></A>
<I>y</I>&#X2032;+<I>f</I> <I>y</I>=<I>g</I>
    (20)</TD></TR>
</TABLE><P>
avec <I>f</I>, <I>g</I> élémentaires par rapport à une tour dont le
variable au sommet est <I>Z</I>, on cherche <I>y</I> élémentaire par rapport
à cette tour (ici <I>f</I>=<I>jY</I>&#X2032; est une dérivée mais dans certains
cas nous devrons résoudre par appel récursif des équations
du type ci-dessus où <I>f</I> ne sera pas une dérivée).</P><P><B>Élimination des dénominateurs</B><BR>
Soit <I>P</I> un facteur irréductible du dénominateur de <I>y</I>, notons 
&#X3B1;&lt;0 la valuation de <I>y</I> par rapport à <I>P</I>, 
&#X3B2; celle de <I>f</I>, &#X3B3; celle de <I>g</I>. 
Si <I>P</I> n&#X2019;est pas une exponentielle,
la valuation de <I>y</I>&#X2032; est &#X3B1;&#X2212;1, celle de  <I>f</I> <I>y</I>  est &#X3B1; +&#X3B2; . 
Si &#X3B2; &#X2260; &#X2212;1, 
il n&#X2019;y a pas de simplification possible dans le membre de gauche
donc &#X3B1; + min(&#X3B2;,&#X2212;1) =&#X3B3;. Autrement dit, si 
&#X3B2; &#X2265; 0 alors &#X3B1;=&#X3B3;+1 et si &#X3B2;&lt;&#X2212;1 
alors &#X3B1;=&#X3B3;&#X2212;&#X3B2;.
On observe que &#X3B3;&lt;0 donc
<I>P</I> est un facteur du dénominateur <I>g</I><SUB><I>d</I></SUB> de <I>g</I>. De plus, on va montrer
que la valuation &#X3B1; de <I>P</I> dans <I>y</I> est l&#X2019;opposé de celle
de <I>P</I> dans :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:defD"></A>
<I>D</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">gcd(<I>g</I><SUB><I>d</I></SUB>,&#X2202;<SUB><I>Z</I></SUB> <I>g</I><SUB><I>d</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">gcd(<I>c</I>,&#X2202;<SUB><I>Z</I></SUB> <I>c</I>)</TD></TR>
</TABLE></TD><TD CLASS="dcell">, 
   <I>c</I>=gcd(<I>f</I><SUB><I>d</I></SUB>,<I>g</I><SUB><I>d</I></SUB>)
    (21)</TD></TR>
</TABLE><P>
En effet, si &#X3B2; &#X2265; 0, <I>P</I> ne divise pas <I>f</I><SUB><I>d</I></SUB> donc ne divise
pas <I>c</I>, donc la valuation de <I>P</I> dans <I>D</I> est &#X2212;&#X3B3;&#X2212;1. Si &#X3B2; &lt; &#X2212;1,
alors &#X3B1;=&#X3B3; &#X2212; &#X3B2; &lt;0 entraine &#X2212;&#X3B3; &gt; &#X2212;&#X3B2; donc la
valuation de <I>P</I> dans <I>c</I> est &#X2212;&#X3B2; et la valuation de <I>P</I> dans <I>D</I>
est &#X2212;&#X3B3;&#X2212;1 &#X2212; (&#X2212;&#X3B2;&#X2212;1).</P><P>Si &#X3B2;=&#X2212;1, s&#X2019;il n&#X2019;y a pas de simplifications dans le membre
de gauche pour les termes de plus petite puissance en <I>P</I>, alors 
&#X3B1;=&#X3B3;+1. S&#X2019;il y a simplification,
on décompose en éléments
simples (avec Bézout) puis on ordonne par puissances croissantes
de <I>P</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I>= <I>N</I><SUB>1</SUB> <I>P</I><SUP>&#X3B1;</SUP>+..., <I>f</I>= <I>N</I><SUB>2</SUB> <I>P</I><SUP>&#X2212;1</SUP>+...,</TD></TR>
</TABLE><P>
avec <I>N</I><SUB>1</SUB>,<I>N</I><SUB>2</SUB> de degré plus petit que <I>P</I>, puis on remplace dans 
(<A HREF="#eq:rischdiffeq2">20</A>). On cherche les termes de valuation &#X3B1;&#X2212;1
en <I>P</I> qui doivent se simplifier :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X3B1; <I>N</I><SUB>1</SUB> <I>P</I>&#X2032; <I>P</I><SUP>&#X3B1;&#X2212;1</SUP> + <I>N</I><SUB>2</SUB> <I>P</I><SUP>&#X2212;1</SUP> <I>N</I><SUB>1</SUB> <I>P</I><SUP>&#X3B1;</SUP>=0 </TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB>2</SUB> = &#X2212;&#X3B1; <I>P</I>&#X2032; </TD></TR>
</TABLE><P>
ce qui détermine &#X3B1;.</P><P><B>Récapitulons</B><BR>
Si <I>f</I> est une dérivée, alors &#X3B2;=&#X2212;1 est exclus et on peut
appliquer (<A HREF="#eq:defD">21</A>) pour déterminer <I>D</I>. Si <I>f</I> n&#X2019;est
pas une dérivée, on calcule les facteurs de degré 1 de <I>f</I><SUB><I>d</I></SUB> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I><SUB>1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I><SUB><I>d</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">gcd(<I>f</I><SUB><I>d</I></SUB>,&#X2202;<SUB><I>Z</I></SUB> <I>f</I><SUB><I>d</I></SUB>)</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
on décompose <I>f</I> par Bézout en isolant la partie <I>N</I>/<I>f</I><SUB>1</SUB>
les &#X3B1; possibles sont alors les racines entières (en <I>t</I>)
du résultant en <I>Z</I> de <I>N</I>&#X2212;<I>tf</I><SUB>1</SUB>&#X2032; et <I>f</I><SUB>1</SUB>, ils correspondent aux
facteurs gcd(<I>N</I>&#X2212;&#X3B1; <I>f</I><SUB>1</SUB>&#X2032;,<I>f</I><SUB>1</SUB>) que l&#X2019;on retire de <I>f</I><SUB><I>d</I></SUB> pour
appliquer (<A HREF="#eq:defD">21</A>).</P><P><B>Exemple</B><BR>
Reprenons <I>y</I>&#X2032;+2<I>xy</I>=<I>a</I>(<I>x</I>). Si <I>a</I>(<I>x</I>)=1 (résolution de &#X222B;exp(<I>x</I><SUP>2</SUP>)),
ou plus généralement si <I>a</I>(<I>x</I>) est un polynôme,
alors <I>D</I>=1. Si <I>a</I>(<I>x</I>)=1/<I>x</I><SUP>2</SUP>, on trouve <I>D</I>=<I>x</I> et on pose <I>y</I>=<I>xz</I>,
donc <I>x</I><SUP>2</SUP>(<I>xz</I>&#X2032;+<I>z</I>)+2<I>x</I><SUP>4</SUP><I>z</I>=1 soit <I>x</I><SUP>3</SUP><I>z</I>&#X2032;+(2<I>x</I><SUP>4</SUP>+1)<I>z</I>=1.</P><P>Reste le cas où <I>Z</I> est une exponentielle et <I>P</I>=exp(<I>z</I>). On reprend
le même raisonnement, <I>y</I>&#X2032; a pour valuation &#X2212;&#X3B1;&lt;0, <I>fy</I> a pour
valuation &#X2212;&#X3B2;&#X2212;&#X3B1;, donc si &#X3B2; &gt; 0,
&#X3B1;=&#X3B3; et si &#X3B2;&lt;0, &#X3B1;=&#X3B3;&#X2212;&#X3B2;.
Si &#X3B2;=0, s&#X2019;il n&#X2019;y a pas de simplifications du terme de plus bas
degré, on est ramené au cas précédent. 
Si &#X3B2;=0 et s&#X2019;il y a simplification des termes de plus
bas degré en <I>Z</I>, notons <I>f</I><SUB>0</SUB> le coefficient constant de <I>f</I> 
par rapport à <I>Z</I> et <I>y</I><SUB>&#X3B1;</SUB> le coefficient de <I>Z</I><SUP>&#X3B1;</SUP>
dans <I>y</I>, on a 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUB>&#X3B1;</SUB>&#X2032; + (&#X3B1; <I>z</I>&#X2032; + <I>f</I><SUB>0</SUB>) <I>y</I><SUB>&#X3B1;</SUB>=0 </TD></TR>
</TABLE><P>
donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUB>&#X3B1;</SUB>= exp(&#X2212;&#X3B1; <I>z</I>&#X2212;</TD><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><I>f</I><SUB>0</SUB>)</TD></TR>
</TABLE><P>
Comme <I>y</I><SUB>&#X3B1;</SUB> est élémentaire et indépendant de <I>Z</I>
on en déduit par le théorème de structure de Risch
que &#X2212;&#X3B1; <I>z</I> &#X2212;&#X222B;<I>f</I><SUB>0</SUB> est combinaison linéaire à coefficients
rationnels des logarithmes et des arguments des exponentielles de la tour,
de plus le coefficient de <I>z</I> doit être nul pour que <I>y</I><SUB>&#X3B1;</SUB> soit
indépendant de <I>Z</I>, ce qui impose la valeur de &#X3B1; (après avoir
résolu récursivement le problème d&#X2019;intégration pour <I>f</I><SUB>0</SUB>)</P><P><B>Majoration du degré du numérateur de </B><B><I>y</I></B><BR>
En multipliant <I>y</I> par <I>D</I> <I>Z</I><SUP>&#X2212;&#X3B1;</SUP>, puis en réduisant au
même dénominateur,
on se ramène alors à une équation différentielle à coefficients
polynomiaux par rapport à la variable <I>Z</I> dont l&#X2019;inconnue est un polynôme 
<I>N</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:rischdepol"></A>
<I>R</I> <I>N</I>&#X2032; + <I>S</I> <I>N</I> = <I>T</I>
    (22)</TD></TR>
</TABLE><P>
On va chercher une majoration sur le degré possible de <I>N</I> puis
utiliser l&#X2019;identité de Bézout pour simplifier
cette équation. </P><P>On écrit maintenant <I>N</I>=&#X2211;<SUB><I>k</I>=0</SUB><SUP><I>n</I></SUP> <I>N</I><SUB><I>k</I></SUB> <I>Z</I><SUP><I>k</I></SUP> et on remplace, 
il y a à nouveau trois cas selon le type de <I>Z</I>.</P><P><B>Si </B><B><I>Z</I>=<I>x</I></B><B>: cas exponentielle rationnelle</B><BR>
Donc <I>Z</I>&#X2032;=1, le degré de <I>RN</I>&#X2032; est <I>r</I>+<I>n</I>&#X2212;1 (si <I>N</I> est non constant
c&#X2019;est-à-dire si <I>T</I> n&#X2019;est pas un multiple de <I>S</I>), le degré de
<I>SN</I> est <I>s</I>+<I>n</I>. Si <I>r</I>&#X2212;1&#X2260; <I>s</I>, on en déduit que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>n</I>=<I>t</I>&#X2212;max(<I>r</I>&#X2212;1,<I>s</I>)</TD></TR>
</TABLE><P>
Si <I>r</I>&#X2212;1=<I>s</I>, on peut avoir
une simplification du terme de plus haut degré <I>s</I>+<I>n</I> (sinon
on est dans le cas précédent) si <I>n</I> <I>R</I><SUB><I>r</I></SUB> =<I>S</I><SUB><I>s</I></SUB> 
d&#X2019;où on déduit le degré <I>n</I> de <I>N</I>.</P><P>Par exemple, pour <I>y</I>&#X2032;+2<I>xy</I>=<I>T</I> ou pour <I>x</I><SUP>3</SUP><I>z</I>&#X2032;+(2<I>x</I><SUP>4</SUP>+1)<I>z</I>=1 on a <I>r</I>=<I>s</I>&#X2212;1 donc
<I>n</I>+<I>s</I>=<I>t</I>, donc pas de solution dans le deuxième cas, dans le premier cas
il ne peut y avoir de solutions que si <I>t</I> &#X2265; <I>s</I>, en particulier
il n&#X2019;y a pas de solution pour <I>t</I>=1, on a donc démontré que &#X222B;exp(<I>x</I><SUP>2</SUP>)
n&#X2019;admet pas de primitive élémentaire.</P><P><B>Si </B><B><I>Z</I>=</B><B>exp</B><B>(<I>z</I>)</B><B>: cas exponentielle d&#X2019;exponentielle</B><BR>
Ici les <I>N</I><SUB><I>k</I></SUB> peuvent ne pas être constants, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I>&#X2032;=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>N</I><SUB><I>k</I></SUB>&#X2032;+<I>kN</I><SUB><I>k</I></SUB> <I>z</I>&#X2032;) <I>Z</I><SUP><I>k</I></SUP></TD></TR>
</TABLE><P>
Comme on l&#X2019;a déjà observé, <I>N</I><SUB><I>n</I></SUB>&#X2032;+<I>n</I> <I>N</I><SUB><I>n</I></SUB> <I>z</I>&#X2032;&#X2260; 0, donc le
degré de <I>N</I>&#X2032; est égal au degré de <I>N</I>. On a donc trois cas :
</P><UL CLASS="itemize"><LI CLASS="li-itemize"> 
si <I>r</I>&#X2260; <I>s</I>, alors <I>n</I>=<I>t</I>&#X2212;max(<I>r</I>,<I>s</I>)
</LI><LI CLASS="li-itemize">si <I>r</I>=<I>s</I> et les termes de plus haut degré du membre de gauche ne
se simplifient pas, alors, <I>n</I>=<I>t</I>&#X2212;<I>r</I>=<I>t</I>&#X2212;<I>s</I>.
</LI><LI CLASS="li-itemize">si <I>r</I>=<I>s</I> et s&#X2019;il y a simplification, alors :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I><SUB><I>r</I></SUB>(<I>N</I><SUB><I>n</I></SUB>&#X2032;+<I>nN</I><SUB><I>n</I></SUB><I>z</I>&#X2032;)+<I>S</I><SUB><I>s</I></SUB><I>N</I><SUB><I>n</I></SUB>=0 </TD></TR>
</TABLE>
donc :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB><I>n</I></SUB>&#X2032; + (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>S</I><SUB><I>s</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>R</I><SUB><I>r</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">+<I>nz</I>&#X2032;)<I>N</I><SUB><I>n</I></SUB> = 0</TD></TR>
</TABLE>
et :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB><I>n</I></SUB> = <I>C</I> exp(&#X2212;<I>nz</I>&#X2212;</TD><TD CLASS="dcell"><FONT SIZE=6>&#X222B;</FONT></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>S</I><SUB><I>s</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>R</I><SUB><I>r</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">) </TD></TR>
</TABLE>
On appelle alors l&#X2019;algorithme de Risch avec une variable de moins (<I>S</I><SUB><I>s</I></SUB>
et <I>R</I><SUB><I>r</I></SUB> ne dépendent plus de <I>Z</I>) pour calculer <I>I</I>=&#X222B;<I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB>. 
Il s&#X2019;agit alors de trouver <I>n</I> tel que l&#X2019;exponentielle précédente
soit élémentaire et indépendante de la variable <I>Z</I>. Le théorème
de structure de Risch implique que &#X2212;<I>nz</I>&#X2212;&#X222B;<I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB> est combinaison 
linéaire à coefficients rationnels des logarithmes et des arguments 
des exponentielles de autres variables de la tour (jusqu&#X2019;à <I>z</I> non compris).
Ceci permet de déterminer <I>n</I> de manière unique (c&#X2019;est le coefficient
rationnel de &#X222B;<I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB> en <I>z</I>).
</LI></UL><P><B>Si </B><B><I>Z</I>=</B><B>ln</B><B>(<I>z</I>)</B><B>: exponentielle de logarithme</B><BR>
Ici aussi, les <I>N</I><SUB><I>k</I></SUB> peuvent ne pas être constants, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I>&#X2032;=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>N</I><SUB><I>k</I></SUB>&#X2032;<I>Z</I><SUP><I>k</I></SUP>+<I>kN</I><SUB><I>k</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>z</I>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>z</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>Z</I><SUP><I>k</I>&#X2212;1</SUP>)</TD></TR>
</TABLE><P>
Si <I>N</I><SUB><I>n</I></SUB> n&#X2019;est pas constant, le terme de plus haut degré de 
<I>RN</I>&#X2032; est <I>N</I><SUB><I>n</I></SUB>&#X2032; <I>R</I><SUB><I>r</I></SUB> <I>Z</I><SUP><I>n</I>+<I>r</I></SUP>, si <I>N</I><SUB><I>n</I></SUB> est constant, 
le terme de plus haut degré de <I>RN</I>&#X2032; est <I>R</I><SUB><I>r</I></SUB>(<I>nN</I><SUB><I>n</I></SUB><I>z</I>&#X2032;/<I>z</I>+<I>N</I><SUB><I>n</I>&#X2212;1</SUB>&#X2032;) <I>Z</I><SUP><I>r</I>&#X2212;1</SUP> 
qui est non nul (sinon <I>z</I>&#X2032;/<I>z</I>=<I>CN</I><SUB><I>n</I>&#X2212;1</SUB>&#X2032; et <I>z</I>=exp(<I>CN</I><SUB><I>n</I>&#X2212;1</SUB>) serait 
une exponentielle).
Le terme de plus haut degré de <I>SN</I> est <I>N</I><SUB><I>n</I></SUB> <I>S</I><SUB><I>s</I></SUB> <I>Z</I><SUP><I>n</I>+<I>s</I></SUP>.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Si <I>r</I>&lt;<I>s</I> ou si <I>r</I>=<I>s</I> sans simplifications,
alors <I>n</I>=<I>t</I>&#X2212;<I>s</I>.
</LI><LI CLASS="li-itemize">Si <I>r</I>&gt;<I>s</I>+1 ou si <I>r</I>=<I>s</I>+1 sans simplifications,
alors deg(<I>N</I>&#X2032;)=<I>t</I>&#X2212;<I>r</I> donc <I>n</I>=<I>t</I>&#X2212;<I>r</I> ou <I>n</I>=<I>t</I>&#X2212;<I>r</I>+1.
</LI><LI CLASS="li-itemize">Si <I>r</I>=<I>s</I>+1, et s&#X2019;il y a simplifications, alors <I>N</I><SUB><I>n</I></SUB> est constant et :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I><SUB><I>r</I></SUB>(<I>nN</I><SUB><I>n</I></SUB><I>z</I>&#X2032;/<I>z</I>+<I>N</I><SUB><I>n</I>&#X2212;1</SUB>&#X2032;)+ <I>S</I><SUB><I>s</I></SUB> <I>N</I><SUB><I>n</I></SUB> = 0 </TD></TR>
</TABLE>
alors <I>N</I><SUB><I>n</I>&#X2212;1</SUB>=<I>C</I> (&#X2212;&#X222B;<I>N</I><SUB><I>n</I></SUB> <I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB> &#X2212;<I>n</I> <I>N</I><SUB><I>n</I></SUB> ln(<I>z</I>))
doit être élémentaire et indépendante de <I>Z</I> donc &#X222B;<I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB>
est élémentaire, on détermine <I>n</I> en éliminant le coefficient de 
<I>Z</I>=ln(<I>z</I>) provenant de &#X222B;<I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB>.
</LI><LI CLASS="li-itemize">Si <I>r</I>=<I>s</I>, et s&#X2019;il y a simplification des termes 
de plus haut degré du membre de gauche, 
alors <I>N</I><SUB><I>n</I></SUB>&#X2032; <I>R</I><SUB><I>r</I></SUB>+<I>N</I><SUB><I>n</I></SUB> <I>S</I><SUB><I>s</I></SUB>=0 donc <I>N</I><SUB><I>n</I></SUB>=exp(&#X2212;&#X222B;<I>S</I><SUB><I>s</I></SUB>/<I>R</I><SUB><I>r</I></SUB>)
est élémentaire et indépendante de <I>Z</I>. On peut donc changer
d&#X2019;inconnue <I>N</I>=<I>N</I><SUB><I>n</I></SUB> <I>M</I> sans changer le fait que <I>M</I> est un polynôme de
même degré que <I>N</I>. On se ramène alors à une équation du même type
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>RM</I>&#X2032;+(<I>S</I>&#X2212;<I>R</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>S</I><SUB><I>s</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>R</I><SUB><I>r</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">)<I>M</I>= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>T</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>N</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE>
mais avec <I>s</I> diminué de 1 au moins.
</LI></UL><P><B>Réduction (algorithme SPDE de Rothstein)</B><BR>
On observe d&#X2019;abord que si <I>R</I> et <I>S</I> ont un facteur
en commun, alors ce facteur divise <I>T</I> car <I>N</I>&#X2032; et <I>N</I> sont des polynômes
en <I>Z</I>. On peut donc quitte à simplifier par gcd(<I>R</I>,<I>S</I>) se ramener
au cas où <I>R</I> et <I>S</I> sont premiers entre eux, il existe donc deux
polynômes <I>U</I> et <I>V</I> tels que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:rischdebezout"></A>
<I>RU</I>+<I>SV</I>=<I>T</I>,    deg(<I>V</I>)&lt; deg(<I>R</I>)
    (23)</TD></TR>
</TABLE><P>
En soustrayant (<A HREF="#eq:rischdebezout">23</A>) de (<A HREF="#eq:rischdepol">22</A>), 
on montre que <I>R</I> divise <I>N</I>&#X2212;<I>V</I>. Soit <I>H</I>=(<I>N</I>&#X2212;<I>V</I>)/<I>R</I>. Alors <I>N</I>=<I>RH</I>+<I>V</I> donc
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I> (<I>RH</I>&#X2032;+<I>R</I>&#X2032;<I>H</I>+<I>V</I>&#X2032;)+<I>SRH</I>+<I>SV</I>= <I>T</I>=<I>RU</I>+<I>SV</I></TD></TR>
</TABLE><P>
donc après simplification par <I>SV</I> et division par <I>R</I>, 
<I>H</I> vérifie l&#X2019;équation :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>R</I> <I>H</I>&#X2032; + (<I>S</I>+<I>R</I>&#X2032;) <I>H</I> = <I>U</I> &#X2212; <I>V</I>&#X2032;</TD></TR>
</TABLE><P>
C&#X2019;est une équation du même type mais avec deg(<I>H</I>)=deg(<I>N</I>)-deg(<I>R</I>)
ou <I>H</I>=0 (si <I>N</I>=<I>V</I>).
Donc si deg(<I>R</I>)&gt;0, au bout d&#X2019;un nombre fini d&#X2019;étapes on doit 
tomber sur un second membre nul ou des simplifications de <I>R</I> avec <I>S</I>+<I>R</I>&#X2032;
telles que <I>R</I> simplifié soit constant en <I>Z</I>.</P><P><B>Résolution</B><BR>
Si <I>R</I> est constant par rapport à <I>Z</I>, 
on simplifie par <I>R</I> et on doit résoudre 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I>&#X2032;+<I>SN</I>=<I>T</I> </TD></TR>
</TABLE><P>
Si <I>S</I>=0, c&#X2019;est un problème d&#X2019;intégration. Supposons donc que
<I>S</I>&#X2260; 0. Si <I>S</I> est non constant par rapport à <I>Z</I> ou si
<I>Z</I>=<I>x</I>, le degré de <I>N</I>&#X2032; est strictement inférieur 
au degré de <I>SN</I>, on peut donc facilement résoudre.
Reste le cas où <I>S</I>=<I>b</I> est constant non nul par rapport à <I>Z</I> et <I>Z</I> est
une exponentielle ou un logarithme.</P><P><B>Si </B><B><I>Z</I>=</B><B>exp</B><B>(<I>z</I>)</B><BR>
On a alors doit alors résoudre 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB><I>k</I></SUB>&#X2032;+ <I>k</I> <I>N</I><SUB><I>k</I></SUB> <I>z</I>&#X2032; + <I>b</I> <I>N</I><SUB><I>k</I></SUB>=<I>T</I><SUB><I>k</I></SUB> </TD></TR>
</TABLE><P>
c&#X2019;est une équation différentielle de Risch mais avec une variable de 
moins.</P><P><B>Si </B><B><I>Z</I>=</B><B>ln</B><B>(<I>z</I>)</B><BR>
On doit alors résoudre 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>N</I><SUB><I>k</I></SUB>&#X2032;+ (<I>k</I>+1) <I>N</I><SUB><I>k</I>+1</SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>z</I>&#X2032;</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>z</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> + <I>b</I> <I>N</I><SUB><I>k</I></SUB> =<I>T</I><SUB><I>k</I></SUB> </TD></TR>
</TABLE><P>
c&#X2019;est aussi une équation différentielle de Risch avec une
variable de moins.</P><P><B>Exemple</B><BR>
Voyons comment on intègre <I>x</I><SUP><I>n</I></SUP> avec <I>n</I> un paramètre par l&#X2019;algorithme
de Risch (cela illustre les possibilités couvertes par l&#X2019;algorithme
mais aussi l&#X2019;efficacité des méthodes traditionnelles d&#X2019;intégration
lorsqu&#X2019;elles s&#X2019;appliquent).
On écrit d&#X2019;abord <I>x</I><SUP><I>n</I></SUP>=<I>e</I><SUP><I>n</I> ln(<I>x</I>)</SUP>, donc la tour de variables
est { <I>x</I>, <I>Z</I>=ln(<I>x</I>), <I>X</I>=<I>e</I><SUP><I>n</I> ln(<I>x</I>)</SUP>}, il s&#X2019;agit donc d&#X2019;intégrer
<I>X</I> qui est un polynôme généralisé. On cherche donc <I>A</I><SUB>1</SUB> solution
de l&#X2019;équation différentielle de Risch 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUB>1</SUB>&#X2032;+ <I>n</I> /<I>x</I> <I>A</I><SUB>1</SUB>=1 </TD></TR>
</TABLE><P>
Par rapport à <I>Z</I>=ln(<I>x</I>) la fonction <I>f</I>=<I>n</I>/<I>x</I> est un polynôme, donc on
applique le dernier cas ci-dessus, <I>A</I><SUB>1</SUB> est aussi indépendant de ln(<I>x</I>)
et on se ramène à résoudre la même équation mais avec comme variable
principale <I>x</I> et non <I>Z</I>. Cette fois, il y a un dénominateur <I>x</I> en <I>f</I>.
Si <I>A</I><SUB>1</SUB> possède un dénominateur, il faut qu&#X2019;il y ait annulation
du terme de plus bas degré en <I>x</I> car le second membre n&#X2019;a pas de
dénominateur, on obtient <I>n</I>+&#X3B1;=0 qui n&#X2019;a pas de solution, donc
<I>A</I><SUB>1</SUB> est un polynôme en <I>x</I> et l&#X2019;équation se réécrit en :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>xA</I><SUB>1</SUB>&#X2032;+<I>nA</I><SUB>1</SUB>=<I>x</I></TD></TR>
</TABLE><P>
On majore alors le degré en <I>x</I> de <I>A</I><SUB>1</SUB> par 1, car il ne peut pas y avoir
d&#X2019;annulation de terme de plus grand degré. Ensuite, on peut appliquer
l&#X2019;algorithme SPDE de Rothstein pour réduire le degré, ou ici conclure
à la main, <I>x</I> divise <I>nA</I><SUB>1</SUB> donc <I>A</I><SUB>1</SUB>=<I>Cx</I> qu&#X2019;on remplace et <I>C</I>=1/(<I>n</I>+1).
Finalement, <I>A</I><SUB>1</SUB>=<I>x</I>/(<I>n</I>+1) et &#X222B;<I>x</I><SUP><I>n</I></SUP>=<I>x</I>/(<I>n</I>+1)  <I>x</I><SUP><I>n</I></SUP>.</P><!--TOC subsection Quelques références-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc65">9.4</A>  Quelques références</H3><!--SEC END --><P> <A NAME="sec:rischref"></A>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
M. Bronstein:<BR>
Symbolic Integration I, Transcendental functions, Springer</LI><LI CLASS="li-itemize">M. Bronstein:<BR>
Integration tutorial,<BR>
<CODE>http://www-sop.inria.fr/cafe/Manuel.Bronstein/publications/mb_papers.html</CODE></LI><LI CLASS="li-itemize">J.H. Davenport, Y. Siret, E. Tournier:<BR>
Calcul formel: Systèmes et algorithmes 
de manipulations algébriques</LI><LI CLASS="li-itemize">R. Risch:<BR>
les références des articles originaux de Risch sont dans
le &#X201C;Integration tutorial&#X201D; de Bronstein.</LI><LI CLASS="li-itemize">B. Trager:<BR>
PHD thesis MIT, 1984</LI><LI CLASS="li-itemize">On peut lire en clair le code source de l&#X2019;implémentation en MuPAD
(sous Unix, désarchiver le fichier <TT>lib.tar</TT> du répertoire
<TT>/usr/local/MuPAD/share/lib</TT> et regarder dans le sous-répertoire
<TT>lib/INTLIB</TT>)</LI></UL><!--TOC section Algèbre linéaire-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc66">10</A>  Algèbre linéaire</H2><!--SEC END --><P>
On présente ici des algorithmes autour de la résolution exacte
de systèmes (réduction des matrices sous forme échelonnée) 
et la recherche de valeurs propres et de vecteurs propres 
(diagonalisation et jordanisation des matrices).</P><!--TOC subsection Résolution de systèmes, calcul de déterminant.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc67">10.1</A>  Résolution de systèmes, calcul de déterminant.</H3><!--SEC END --><!--TOC subsubsection La méthode du pivot de Gauß.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc68">10.1.1</A>  La méthode du pivot de Gauß.</H4><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
Le pivot : on détermine à partir d&#X2019;une ligne <I>i</I> 
la ligne <I>j</I> où apparait le premier coefficient non nul <I>p</I> dans
la colonne à réduire. On échange les lignes
<I>i</I> et <I>j</I>. Puis pour <I>j</I>&gt;<I>i</I> (réduction sous-diagonale)
ou <I>j</I>&#X2260; <I>i</I> (réduction complète), on effectue l&#X2019;opération
<I>L</I><SUB><I>j</I></SUB> &#X2190; <I>L</I><SUB><I>j</I></SUB> &#X2212; <I>p</I><SUB><I>j</I></SUB>/<I>p</I><I>L</I><SUB><I>i</I></SUB>.<BR>
Inconvénient : avec des données exactes de taille non bornée, 
la complexité des coefficients augmente plus vite qu&#X2019;en choisissant 
le pivot le plus simple possible, (remarque, lorsque les données 
sont approchées, on n&#X2019;utilise pas non plus cette méthode
pour des raisons de stabilité numérique).
Le domaine d&#X2019;utilisation naturel concerne donc les coefficients
dans un corps fini (par exemple &#X2124;/<I>n</I>&#X2124;).
</LI><LI CLASS="li-itemize">Le pivot partiel. On choisit le meilleur coefficient non nul de la
colonne, où meilleur dépend du type de coefficient : avec des données
exactes, on choisirait le coefficient de taille la plus petite possible,
avec des données approximatives, on choisit
le coefficient de plus grande norme dans la colonne.
Le domaine d&#X2019;utilisation naturel concerne les coefficients
approchés. Pour les coefficients exacts, on remplacerait la
réduction par <I>L</I><SUB><I>j</I></SUB> &#X2190; <I>pL</I><SUB><I>j</I></SUB> &#X2212;<I>p</I><SUB><I>j</I></SUB> <I>L</I><SUB><I>i</I></SUB> pour ne pas effectuer
de division. Mais avec cette méthode, la taille des coefficients
augmente de manière exponentielle. On peut améliorer
la taille des coefficients intermédiaires en divisant chaque
ligne par le PGCD de ses coefficients, mais comme pour le
calcul du PGCD par l&#X2019;algorithme du sous-résultant, il existe
une méthode plus efficace présentée ci-dessous.
</LI><LI CLASS="li-itemize">La méthode de Bareiss : on initialise un coefficient <I>b</I> à 1.
On remplace l&#X2019;étape de réduction ci-dessus
par <I>L</I><SUB><I>j</I></SUB> &#X2190; (<I>pL</I><SUB><I>j</I></SUB> &#X2212;<I>p</I><SUB><I>j</I></SUB> <I>L</I><SUB><I>i</I></SUB>)/<I>b</I>.
À la fin de l&#X2019;étape de réduction, on met le coefficient <I>b</I>
à la valeur du pivot <I>p</I>. L&#X2019;intérêt de la méthode est que la division
se fait sans introduire de fraction (la preuve pour les deux premières
étapes se fait facilement à la main ou avec
un système de calcul formel (cf. infra), pour le cas général, on vérifie
que le déterminant de la matrice de départ
est égal au dernier coefficient sur la diagonale obtenu par
cette méthode de réduction, ce dernier est donc entier, le
même raisonnement fait sur des sous-matrices dont on prend les
<I>k</I> premières lignes et colonnes et une autre ligne et une autre
colonne montre que tous les coefficients des matrices intermédiaires
sont entiers).
On peut utiliser cette méthode aussi bien pour la réduction
sous-diagonale que pour la réduction complète (les lignes
intervenant dans la combinaison linéaire subissent des 
modifications identiques dans les deux cas).
</LI></UL><P>
Montrons avec MuPAD ou xcas en mode mupad (commande <CODE>maple_mode(2)</CODE>)
qu&#X2019;en effet, on n&#X2019;introduit pas de dénominateur dans la méthode
de Bareiss. Sans
restreindre la généralité, il suffit de le montrer avec une
matrice 3x3 à coefficients symboliques génériques. 
</P><PRE CLASS="verbatim">pivot:=proc (M,n,m,r) // n ligne du pivot, m colonne, r ligne a modifier
      local col,i,a,b; 
       begin
         col:=ncols(M);
         a:=M[n,m];
         b:=M[r,m];
         for i from 1 to col do
           // print(i,a,b,n,m,r);
           M[r,i]:=a*M[r,i]-b*M[n,i];
         end_for;
         return(M);
       end_proc; /* End of pivot */
A:=matrix(3,3,[[a,b,c],[d,e,f],[g,h,j]]);
A:=pivot(A,1,1,2); A:=pivot(A,1,1,3); /* reduction 1ere colonne */
A:=pivot(A,2,2,3); A:=pivot(A,2,2,1); /* reduction 2eme colonne */
factor(A[3,3]);
</PRE><P>Ce qui met bien en évidence le facteur <I>a</I> dans <I>A</I><SUB>3,3</SUB>.</P><!--TOC subsubsection Le déterminant.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc69">10.1.2</A>  Le déterminant.</H4><!--SEC END --><P>
On peut bien sûr appliquer les méthodes ci-dessus en tenant compte
des pivots utilisés et du produit des coefficients diagonaux. Dans le cas de 
la méthode de Bareiss, si on effectue la réduction sous-diagonale
uniquement, il n&#X2019;est pas nécessaire de garder une trace des pivots
et de calculer le produit des coefficients diagonaux,
montrons que la valeur du déterminant est égal au 
dernier coefficient diagonal : en effet si <I>R</I> désigne la matrice réduite et
que l&#X2019;on pose <I>R</I><SUB>0,0</SUB>=1, alors la réduction par la méthode de
Bareiss de la colonne <I>i</I> a pour effet de multiplier le déterminant 
de la matrice initiale <I>M</I> par (<I>R</I><SUB><I>i</I>,<I>i</I></SUB>/(<I>R</I><SUB><I>i</I>&#X2212;1,<I>i</I>&#X2212;1</SUB>)<SUP><I>n</I>&#X2212;<I>i</I></SUP>. Donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> det(<I>R</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">det(<I>M</I>)  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>&#X2212;1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell">
(<I>R</I><SUB><I>i</I>,<I>i</I></SUB>/(<I>R</I><SUB><I>i</I>&#X2212;1,<I>i</I>&#X2212;1</SUB>)<SUP><I>n</I>&#X2212;<I>i</I></SUP> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>R</I><SUB><I>i</I>,<I>i</I></SUB></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">det(<I>M</I>)  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>&#X2212;1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>R</I><SUB><I>i</I>,<I>i</I></SUB>  </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><I>R</I><SUB><I>n</I>,<I>n</I></SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>det(<I>M</I>)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>Pour les matrices à coefficients entiers, on peut aussi utiliser une
méthode modulaire : on calcule une borne à priori sur le déterminant
et on calcule le déterminant modulo suffisamment de petits nombres
premiers pour le reconstruire par les restes chinois. L&#X2019;avantage
de cet algorithme est qu&#X2019;il est facile à paralléliser.</P><P>On utilise souvent la borne d&#X2019;Hadamard sur le déterminant :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|det(<I>M</I>)| &#X2264; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1&#X2264; <I>i</I> &#X2264; <I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell"><TABLE CELLSPACING=0 CELLPADDING=0><TR><TD ALIGN="right"><DIV CLASS="vbar" STYLE="height:2em;"></DIV></TD></TR>
<TR><TD><FONT SIZE=7>&#X221A;</FONT></TD></TR>
</TABLE></TD><TD CLASS="dcell"><TABLE border=0 cellspacing=1 cellpadding=0><TR><TD CLASS="hbar"></TD></TR>
<TR><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">1&#X2264; <I>j</I> &#X2264; <I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> |<I>m</I><SUB><I>i</I>,<I>j</I></SUB>|<SUP>2</SUP></TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Preuve de la borne : on majore le déterminant par le produit des
normes des vecteurs colonnes de <I>M</I>.</P><P><B>Remarque</B> :<BR>
Si on veut juste prouver l&#X2019;inversibilité d&#X2019;une matrice à coefficients
entiers, il suffit
de trouver un nombre premier <I>p</I> tel que le déterminant de cette matrice modulo
<I>p</I> soit non nul.</P><P><B>Développement par rapport à une ligne ou une colonne</B><BR>
On a tendance à oublier ce type de méthode car le développement
complet du déterminant (faisant intervenir une somme sur toutes les
permutations du groupe symétrique)
nécessite d&#X2019;effectuer <I>n</I>! produits
de <I>n</I> coefficients et <I>n</I>! additions ce qui est gigantesque. Or on peut
"factoriser" une partie des calculs et se ramener à <I>n</I>.2<SUP><I>n</I></SUP> opérations
élémentaires au lieu de <I>n</I>.<I>n</I>!. Remarquons aussi que le nombre
d&#X2019;opérations élémentaires n&#X2019;a guère de sens si on ne tient pas
compte de la complexité des expressions, l&#X2019;avantage principal
de la méthode de développement étant d&#X2019;éviter d&#X2019;effectuer
des divisions.</P><P><B>Calcul du déterminant par développement de Laplace</B><BR>
On calcule d&#X2019;abord tous les mineurs 2x2 des colonnes 1 et 2
que l&#X2019;on place dans une table de mineurs,
puis on calcule les mineurs 3x3 des colonnes 1 à 3 en développant
par rapport à la colonne 3 et en utilisant les mineurs précédents,
puis les mineurs 4x4 avec les mineurs 3x3, etc.. 
On évite ainsi de recalculer plusieurs fois les mêmes mineurs.
Cf. par exemple l&#X2019;implémentation en C++ dans giac/xcas
(<CODE>www-fourier.ujf-grenoble.fr/~parisse/giac.html</CODE>)
qui utilise le type générique <CODE>map&lt;&gt;</CODE> de la librairie standard C++ (STL)
pour stocker les tables de mineurs (fonction 
<CODE>det_minor</CODE> du fichier <TT>vecteur.cc</TT>).<BR>
Nombre d&#X2019;opérations élémentaires : il y a (<SUB>2</SUB><SUP><I>n</I></SUP>) mineurs d&#X2019;ordre 2
à calculer nécessitant chacun 2 multiplications (et 1 addition),
puis (<SUB>3</SUB><SUP><I>n</I></SUP>) mineurs d&#X2019;ordre 3 nécessitant 3 multiplications et
2 additions, etc. donc le nombre de multiplications est de
2(<SUB>2</SUB><SUP><I>n</I></SUP>)+3(<SUB>3</SUB><SUP><I>n</I></SUP>)+...+<I>n</I>(<SUB><I>n</I></SUB><SUP><I>n</I></SUP>), celui d&#X2019;additions est
(<SUB>2</SUB><SUP><I>n</I></SUP>)+2(<SUB>3</SUB><SUP><I>n</I></SUP>)+...+(<I>n</I>&#X2212;1)(<SUB><I>n</I></SUB><SUP><I>n</I></SUP>) soit un nombre d&#X2019;opérations
élémentaires majoré par <I>n</I>.2<SUP><I>n</I></SUP>.</P><P>On observe "expérimentalement" que cet algorithme est intéressant
lorsque le nombre de
paramètres dans le déterminant est grand et que la matrice est
plutôt creuse (majorité de coefficients nuls). Il existe des
heuristiques de permutation des lignes ou des colonnes visant
à optimiser la position des zéros (par exemple, les auteurs de GiNaC
(<CODE>www.ginac.de</CODE>) suite à des expérimentations
privilégient la simplification des petits mineurs en mettant les colonnes 
contenant le maximum de zéros à gauche selon la description faite
ici). </P><P>Pour se convaincre de l&#X2019;intérêt de cet algorithme, on peut effectuer
le test O1 de Lewis-Wester<BR>
<CODE>http://www.bway.net/~lewis/calatex.html</CODE><BR>
il s&#X2019;agit de calculer un déterminant de taille 15 avec 18 paramètres.</P><!--TOC subsubsection Systèmes linéaires-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc70">10.1.3</A>  Systèmes linéaires</H4><!--SEC END --><P>
On peut appliquer la méthode du pivot de Gauß ou les règles
de Cramer. Pour les systèmes à coefficients entiers non singuliers, 
on peut aussi utiliser une méthode <I>p</I>-adique asymptotiquement
plus efficace. On calcule d&#X2019;abord une borne sur les
coefficients des fractions solutions de l&#X2019;équation <I>Ax</I>=<I>b</I>
en utilisant les règles de Cramer et la borne d&#X2019;Hadamard.
On calcule ensuite <I>C</I>, l&#X2019;inverse de <I>A</I> modulo <I>p</I> (en changeant de <I>p</I> si
<I>A</I> n&#X2019;est pas inversible modulo <I>p</I>), puis, si
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>x</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>i</I></SUB> <I>p</I><SUP><I>i</I></SUP>,    <I>A</I>(</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>&lt;<I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>x</I><SUB><I>i</I></SUB> <I>p</I><SUP><I>i</I></SUP>)=<I>b</I> (mod <I>p</I><SUP><I>k</I></SUP> ) </TD></TR>
</TABLE><P>
on ajoute <I>x</I><SUB><I>k</I></SUB> <I>p</I><SUP><I>k</I></SUP>  et on obtient l&#X2019;équation :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Ax</I><SUB><I>k</I></SUB> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>b</I>&#X2212;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I> &lt;<I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">  <I>x</I><SUB><I>i</I></SUB> <I>p</I><SUP><I>i</I></SUP></TD></TR>
</TABLE></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>p</I><SUP><I>k</I></SUP></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (mod <I>p</I> ) </TD></TR>
</TABLE><P>
qui détermine <I>x</I><SUB><I>k</I></SUB>.
On s&#X2019;arrête lorsque <I>k</I> est suffisamment grand pour pouvoir reconstruire
les fractions à l&#X2019;aide de l&#X2019;identité de Bézout (cf. l&#X2019;appendice),
ce qui est le cas si <I>p</I><SUP><I>k</I></SUP> est
supérieur à 4 fois la borne de Hadamard de <I>A</I> au carré.
Pour éviter de recalculer plusieurs fois <I>b</I>&#X2212;&#X2211;<SUB><I>i</I> &lt;<I>k</I></SUB> <I>x</I><SUB><I>i</I></SUB> <I>p</I><SUP><I>i</I></SUP>,
on utilise la récurrence suivante
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>y</I><SUB>0</SUB>=<I>b</I>,    <I>x</I><SUB><I>k</I></SUB>=<I>Cy</I><SUB><I>k</I></SUB> (mod <I>p</I> ),    <I>y</I><SUB><I>k</I>+1</SUB> =
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUB><I>k</I></SUB>&#X2212;<I>Ax</I><SUB><I>k</I></SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>p</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Pour une matrice de taille <I>n</I>, il faut <I>O</I>(<I>n</I><SUP>3</SUP>) opérations
pour calculer <I>C</I>, puis <I>kn</I><SUP>2</SUP> ln(<I>n</I>) opérations 
pour calculer <I>x</I><SUB><I>k</I></SUB> (le terme (<I>n</I>) 
vient de la taille des coefficients
de <I>y</I><SUB><I>k</I></SUB> dans le produit <I>Cy</I><SUB><I>k</I></SUB>),
donc pour pouvoir reconstruire <I>x</I>, il faut prendre <I>k</I> de l&#X2019;ordre
de <I>n</I>ln(<I>n</I>), ce qui nécessite finalement <I>O</I>(<I>n</I><SUP>3</SUP>ln(<I>n</I>)<SUP>2</SUP>) opérations.</P><P><B>Application au calcul de déterminant de matrices 
à coefficient entiers</B><BR>
Cette méthode <I>p</I>-adique peut servir à accélérer le calcul du
déterminant d&#X2019;une matrice à coefficients entiers de grande taille.
En effet, le PPCM <I>f</I> des dénominateurs des composantes de <I>x</I> est
un diviseur du déterminant, et si <I>b</I> est choisi avec des
coefficients aléatoires, on a une forte probabilité d&#X2019;obtenir
le dernier facteur invariant de la matrice <I>A</I>. Comme le déterminant
de <I>A</I> a une très faible probabilité de contenir un gros facteur
carré, ce dernier facteur invariant est très proche du
déterminant. Ce dernier est pour une matrice <I>A</I> aléatoire
lui-même à un facteur de l&#X2019;ordre de (2/&#X3C0;)<SUP><I>n</I></SUP> proche
de la borne de Hadamard. Il suffit donc de très peu de nombres
premiers pour déterminer det(<I>A</I>)/<I>f</I> par le théorème
des restes chinois. En pratique pour des <I>n</I> de l&#X2019;ordre de 100
à 1000, cet algorithme est plus rapide que le calcul uniquement
par les restes chinois. Pour des <I>n</I> plus grands, il faut se
rabattre sur des algorithmes probabilistes avec arrêt prématuré
pour être plus rapide (on s&#X2019;arrête lorsque le déterminant
n&#X2019;évolue plus par reconstruction par les restes chinois 
pour plusieurs nombres premiers successifs), 
et également utiliser des méthodes
d&#X2019;inversion ou de réduction de type Strassen.</P><!--TOC subsubsection Base du noyau-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc71">10.1.4</A>  Base du noyau</H4><!--SEC END --><P>
On commence bien sûr par réduire la matrice (réduction complète
en-dehors de la diagonale), et on divise chaque ligne par son
premier coefficient non nul (appelé pivot). On insère alors
des lignes de 0 pour que les pivots (non nuls) se trouvent
sur la diagonale. Puis en fin de matrice, on ajoute ou on supprime des 
lignes de 0 pour avoir une matrice carrée de dimension le nombre de colonnes
de la matrice de départ.
On parcourt alors la matrice en diagonale. Si
le <I>i</I>-ième coefficient est non nul, on passe au suivant. 
S&#X2019;il est nul, alors tous
les coefficients d&#X2019;indice supérieur ou égal à <I>i</I> du <I>i</I>-ième
vecteur colonne <I>v</I><SUB><I>i</I></SUB> sont nuls (mais pas forcément pour les indices
inférieurs à <I>i</I>). Si on remplace le <I>i</I>-ième coefficient de <I>v</I><SUB><I>i</I></SUB>
par -1, il est facile de se convaincre que c&#X2019;est un vecteur du noyau,
on le rajoute donc à la base du noyau. On voit facilement
que tous les vecteurs de ce type forment une famille libre de
la bonne taille, c&#X2019;est donc bien une base du noyau.</P><!--TOC subsection Réduction des endomorphismes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc72">10.2</A>  Réduction des endomorphismes</H3><!--SEC END --><!--TOC subsubsection Le polynôme minimal-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc73">10.2.1</A>  Le polynôme minimal</H4><!--SEC END --><P>
On prend un vecteur <I>v</I> au hasard et on calcule la relation linéaire
de degré minimal entre <I>v</I>, <I>Av</I>, ..., <I>A</I><SUP><I>n</I></SUP><I>v</I> en cherchant
le premier vecteur <I>w</I> du noyau de la matrice obtenue en écrivant
les vecteurs <I>v</I>, <I>Av</I>, etc. en colonne dans cet ordre. Les
coordonnées de <I>w</I> donnent alors par ordre de degré croissant
un polynôme <I>P</I> de degré minimal tel que <I>P</I>(<I>A</I>)<I>v</I>=0 donc
<I>P</I> divise le polynôme minimal <I>M</I>. Donc si <I>P</I> est de
degré <I>n</I>, <I>P</I>=<I>M</I>. Sinon, il faut vérifier que le polynôme obtenu 
annule la matrice <I>A</I>. On peut aussi calculer en parallèle le polynôme <I>P</I>
précédent pour quelques vecteurs aléatoires et prendre le PPCM des
polynômes obtenus.</P><P><B>Exemple 1</B><BR>
Polynôme minimal de (</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>4</TD></TR>
</TABLE><P>) . On prend <I>v</I>=(1,0), la matrice à réduire est
alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>&#X2212;11 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>10</TD><TD ALIGN=center NOWRAP>38</TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">&#X2192; 
</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>&#X2212;6 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>5</TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
Le noyau est engendré par (&#X2212;6,5,&#X2212;1) donc <I>P</I>=&#X2212;<I>x</I><SUP>2</SUP>+5<I>x</I>&#X2212;6.</P><P><B>Exemple 2</B><BR>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 3</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>&#X2212;2 </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
en prenant <I>v</I>=(1,0,0) on obtient la matrice :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>3</TD><TD ALIGN=center NOWRAP>5</TD><TD ALIGN=center NOWRAP>7 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>&#X2212;2</TD><TD ALIGN=center NOWRAP>&#X2212;3 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>3</TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">&#X2192;
</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>&#X2212;2 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>3 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
le permier vecteur du noyau est (&#X2212;1,2,&#X2212;1) d&#X2019;où un polynôme divisant
le polynôme minimal &#X2212;<I>x</I><SUP>2</SUP>+2<I>x</I>&#X2212;1.</P><!--TOC subsubsection Le polynôme caractéristique-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc74">10.2.2</A>  Le polynôme caractéristique</H4><!--SEC END --><P>
Pour une matrice générique, le polynôme caractéristique est égal
au polynôme minimal, il est donc intéressant de chercher si le polynôme
annulateur de <I>A</I> sur un vecteur aléatoire est de degré <I>n</I>, 
car le temps de calcul du polynôme caractéristique est alors en <I>O</I>(<I>n</I><SUP>3</SUP>). 
Si cette méthode probabiliste échoue, on se
rabat sur une des méthode déterministe ci-dessous:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
on utilise la formule det(&#X3BB; <I>I</I> &#X2212;<I>A</I>) déterminé par
une des méthodes de calcul de déterminant ci-dessus. Cela
nécessite <I>O</I>(<I>n</I><SUP>3</SUP>) opérations mais avec des coefficients 
polynômes en &#X3BB;.
</LI><LI CLASS="li-itemize">on fait une interpolation de Lagrange en donnant <I>n</I>+1 valeurs
distinctes à &#X3BB;. Ce qui nécessite <I>O</I>(<I>n</I><SUP>4</SUP>) opérations mais avec
des coefficients indépendants de &#X3BB;, de plus cette méthode 
est facile à programmer de manière parallèle.
</LI><LI CLASS="li-itemize">si la matrice est à coefficients entiers
on peut utiliser la méthode de Hessenberg (voir ci-dessous), on calcule
une borne à priori sur les coefficients du polynôme caractéristique
(cf. Cohen p.58-59) :
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|<I>P</I><SUB><I>k</I></SUB>| &#X2264; </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>n</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>n</I>&#X2212;<I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">
(<I>n</I>&#X2212;<I>k</I>)<SUP>(<I>n</I>&#X2212;<I>k</I>)/2</SUP> |<I>M</I>|<SUP><I>n</I>&#X2212;<I>k</I></SUP>  ,</TD></TR>
</TABLE>
on calcule le polynôme caractéristique modulo suffisamment
de petits entiers puis on remonte par les restes chinois.
</LI></UL><!--TOC subsubsection La méthode de Hessenberg-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc75">10.2.3</A>  La méthode de Hessenberg</H4><!--SEC END --><P>
Pour les matrices à coefficients de taille bornée (modulaires par exemple)
on préfère la méthode de Hessenberg qui est plus
efficace, car elle nécessite de l&#X2019;ordre de <I>n</I><SUP>3</SUP> opérations sur
les coefficients.</P><P>On se raméne d&#X2019;abord à une matrice triangulaire supérieure à
une diagonale près qui est semblable à la
matrice de départ puis on
applique une formule de récurrence pour calculer les coefficients
du polynôme caractéristique.</P><P><B>Algorithme de réduction de Hessenberg:</B><BR>
Dans une colonne <I>m</I> donnée de la matrice <I>H</I>, 
on cherche à partir de la ligne
<I>m</I>+1 un coefficient non nul. S&#X2019;il n&#X2019;y en a pas on passe à la colonne
suivante. S&#X2019;il y en a un en ligne <I>i</I>, on échange les lignes <I>m</I>+1
et <I>i</I> et les colonnes <I>m</I>+1 et <I>i</I>. Ensuite pour tout <I>i</I>&#X2265; <I>m</I>+2,
soit <I>u</I>=<I>H</I><SUB><I>i</I>,<I>m</I></SUB>/<I>H</I><SUB><I>m</I>+1,<I>m</I></SUB>, on remplace alors la ligne <I>L</I><SUB><I>i</I></SUB> de <I>H</I>
par <I>L</I><SUB><I>i</I></SUB>&#X2212;<I>uL</I><SUB><I>m</I>+1</SUB> et la colonne <I>C</I><SUB><I>m</I>+1</SUB> par <I>C</I><SUB><I>m</I>+1</SUB>+<I>uC</I><SUB><I>i</I></SUB>
ce qui revient &#X201C;à remplacer le vecteur <I>e</I><SUB><I>m</I>+1</SUB> de la base
par le vecteur <I>e</I><SUB><I>m</I>+1</SUB>+<I>ue</I><SUB><I>i</I></SUB>&#X201D; ou plus précisément
à multiplier à gauche par (</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X2212;<I>u</I></TD><TD ALIGN=center NOWRAP>1</TD></TR>
</TABLE><P>) et à droite par la matrice inverse
(</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>u</I></TD><TD ALIGN=center NOWRAP>1</TD></TR>
</TABLE><P>) (en utilisant les lignes et colonnes
<I>m</I>+1 et <I>i</I> au lieu de 1 et 2 pour ces matrices). 
Ceci a pour effet d&#X2019;annuler le coefficient <I>H</I><SUB><I>i</I>,<I>m</I></SUB>
dans la nouvelle matrice.</P><P>On obtient ainsi en <I>O</I>(<I>n</I><SUP>3</SUP>) opérations
une matrice <I>H</I>&#X2032; semblable à <I>H</I> de la forme :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>1,1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>1,2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>1,<I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>1,<I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>1,<I>n</I></SUB></TD></TR>
<TR><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>2,1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>2,2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>2,<I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>2,<I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>2,<I>n</I></SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>3,2</SUB></TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>3,<I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>3,<I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>3,<I>n</I></SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>4,<I>n</I>&#X2212;2</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>4,<I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB>4,<I>n</I></SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>&#X22EE; </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB><I>n</I>,<I>n</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP><I>H</I>&#X2032;<SUB><I>n</I>,<I>n</I></SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
On calcule alors le polynôme caractéristique de <I>H</I>&#X2032; par une récurrence
qui s&#X2019;obtient en développant le déterminant par rapport à la dernière
colonne :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>h</I><SUB><I>n</I></SUB>(&#X3BB;) = det(&#X3BB; <I>I</I><SUB><I>n</I></SUB>&#X2212;<I>H</I>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>(&#X3BB;&#X2212;<I>H</I>&#X2032;<SUB><I>n</I>,<I>n</I></SUB>) <I>h</I><SUB><I>n</I>&#X2212;1</SUB>(&#X3BB;) &#X2212;(&#X2212;<I>H</I>&#X2032;<SUB><I>n</I>&#X2212;1,<I>n</I></SUB>) (&#X2212;<I>H</I>&#X2032;<SUB><I>n</I>,<I>n</I>&#X2212;1</SUB>) 
<I>h</I><SUB><I>n</I>&#X2212;2</SUB>(&#X3BB;) + </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>    + (&#X2212;<I>H</I>&#X2032;<SUB><I>n</I>&#X2212;2,<I>n</I></SUB>) (&#X2212;<I>H</I>&#X2032;<SUB><I>n</I>,<I>n</I>&#X2212;1</SUB>) (&#X2212;<I>H</I>&#X2032;<SUB><I>n</I>&#X2212;1,<I>n</I>&#X2212;2</SUB>) <I>h</I><SUB><I>n</I>&#X2212;3</SUB>(&#X3BB;) &#X2212; ...</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
où les <I>h</I><SUB><I>i</I></SUB> s&#X2019;entendent en gardant les <I>i</I> premières lignes/colonnes de <I>H</I>&#X2032;.
On peut écrire cette formule pour <I>m</I>&#X2264; <I>n</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>h</I><SUB><I>m</I></SUB>(&#X3BB;)= (&#X3BB; &#X2212; <I>H</I>&#X2032;<SUB><I>m</I>,<I>m</I></SUB>) <I>h</I><SUB><I>m</I>&#X2212;1</SUB>(&#X3BB;)
&#X2212;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>m</I>&#X2212;1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>H</I>&#X2032;<SUB><I>m</I>&#X2212;<I>i</I>,<I>m</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>i</I>&#X2212;1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>H</I>&#X2032;<SUB><I>m</I>&#X2212;<I>j</I>+1,<I>m</I>&#X2212;<I>j</I></SUB> <I>h</I><SUB><I>i</I>&#X2212;1</SUB>(&#X3BB;)</TD></TR>
</TABLE><P>
Pour effectuer cette récurrence de manière efficace, on conserve
les <I>h</I><SUB><I>m</I></SUB>(&#X3BB;) dans un tableau de polynômes et on utilise une 
variable produit contenant successivement les &#X220F;<I>H</I>&#X2032;<SUB><I>m</I>&#X2212;<I>j</I>+1,<I>m</I>&#X2212;<I>j</I></SUB>.</P><!--TOC subsubsection La méthode de Leverrier-Faddeev-Souriau-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc76">10.2.4</A>  La méthode de Leverrier-Faddeev-Souriau</H4><!--SEC END --><P>
Cette méthode permet le calcul simultané des coefficients 
<I>p</I><SUB><I>i</I></SUB>  (<I>i</I>=0..<I>n</I>) du polynôme caractéristique 
<I>P</I>(&#X3BB;)=det(&#X3BB; <I>I</I>&#X2212;<I>A</I>) et des coefficients matriciels
<I>B</I><SUB><I>i</I></SUB>  (<I>i</I>=0..<I>n</I>&#X2212;1) du polynôme en &#X3BB; donnant la matrice adjointe
(ou comatrice) <I>B</I>(&#X3BB;) de &#X3BB; <I>I</I> &#X2212;<I>A</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:Bp"></A>
(&#X3BB; <I>I</I> &#X2212;<I>A</I>)<I>B</I>(&#X3BB;)=(&#X3BB; <I>I</I> &#X2212;<I>A</I>) </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>&#X2264; <I>n</I>&#X2212;1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>B</I><SUB><I>k</I></SUB> &#X3BB;<SUP><I>k</I></SUP>
= (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>&#X2264; <I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>p</I><SUB><I>k</I></SUB> &#X3BB;<SUP><I>k</I></SUP>)<I>I</I> =<I>P</I>(&#X3BB;)<I>I</I>
    (24)</TD></TR>
</TABLE><P>
Remarquons que cette équation donne une démonstration assez simple
de Cayley-Hamilton puisque le reste de la division euclidienne
du polynôme <I>P</I>(&#X3BB;)<I>I</I> par &#X3BB; <I>I</I> &#X2212;<I>A</I>  est <I>P</I>(<I>A</I>).</P><P>Pour déterminer simultanément les <I>p</I><SUB><I>k</I></SUB> et <I>B</I><SUB><I>k</I></SUB>,
on a les relations de récurrence :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">
<A NAME="eq:Bp1"></A> <I>B</I><SUB><I>n</I>&#X2212;1</SUB>=<I>p</I><SUB><I>n</I></SUB> <I>I</I>=<I>I</I>,    <I>B</I><SUB><I>k</I></SUB>&#X2212;<I>AB</I><SUB><I>k</I>+1</SUB>=<I>p</I><SUB><I>k</I>+1</SUB> <I>I</I>
    (25)</TD></TR>
</TABLE><P>
Il nous manque une relation entre les <I>p</I><SUB><I>k</I></SUB> et <I>B</I><SUB><I>k</I></SUB> pour pouvoir
faire le calcul par valeurs décroissantes de <I>k</I>, on va montrer le :
</P><DIV CLASS="theorem"><B>Théorème 8</B>  <EM>
La dérivée du polynôme caractéristique </EM><EM><I>P</I>&#X2032;(&#X3BB;)</EM><EM>,
est égale à la trace de la matrice adjointe 
de </EM><EM>&#X3BB; <I>I</I>&#X2212;<I>A</I></EM><EM>
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM>tr</EM><EM>(<I>B</I>)=<I>P</I>&#X2032;(&#X3BB;) </EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>
Le théorème nous donne tr(<I>B</I><SUB><I>k</I></SUB>) = (<I>k</I>+1)<I>p</I><SUB><I>k</I>+1</SUB> .
Si on prend la trace de (<A HREF="#eq:Bp1">25</A>), on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">tr(<I>B</I><SUB><I>n</I>&#X2212;1</SUB>)=<I>n</I> <I>p</I><SUB><I>n</I></SUB>,    (<I>k</I>+1)<I>p</I><SUB><I>k</I>+1</SUB> &#X2212;tr(<I>AB</I><SUB><I>k</I>+1</SUB>)
=<I>np</I><SUB><I>k</I>+1</SUB> </TD></TR>
</TABLE><P>
donc on calcule <I>p</I><SUB><I>k</I>+1</SUB> en fonction de <I>B</I><SUB><I>k</I>+1</SUB> puis <I>B</I><SUB><I>k</I></SUB> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>p</I><SUB><I>k</I>+1</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">tr(<I>AB</I><SUB><I>k</I>+1</SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>+1&#X2212;<I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">, 
   <I>B</I><SUB><I>k</I></SUB>=<I>AB</I><SUB><I>k</I>+1</SUB>+<I>p</I><SUB><I>k</I>+1</SUB> <I>I</I> </TD></TR>
</TABLE><P>
<B>Démonstration du théorème:</B><BR>
Soient <I>V</I><SUB>1</SUB>(&#X3BB;),...<I>V</I><SUB><I>n</I></SUB>(&#X3BB;) les vecteurs colonnes 
de &#X3BB; <I>I</I>&#X2212;<I>A</I> et <I>b</I><SUB><I>i</I>,<I>j</I></SUB>(&#X3BB;) les coefficients de <I>B</I>, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>P</I>&#X2032;(&#X3BB;<SUB>0</SUB>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>det(<I>V</I><SUB>1</SUB>(&#X3BB;),<I>V</I><SUB>2</SUB>(&#X3BB;),...,<I>V</I><SUB><I>n</I></SUB>(&#X3BB;) )&#X2032;
<SUB>|&#X3BB;=&#X3BB;<SUB>0</SUB></SUB></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>det(<I>V</I>&#X2032;<SUB>1</SUB>(&#X3BB;<SUB>0</SUB>),<I>V</I><SUB>2</SUB>(&#X3BB;<SUB>0</SUB>),...,<I>V</I><SUB><I>n</I></SUB>(&#X3BB;<SUB>0</SUB>) )+
det(<I>V</I><SUB>1</SUB>(&#X3BB;<SUB>0</SUB>),<I>V</I>&#X2032;<SUB>2</SUB>(&#X3BB;<SUB>0</SUB>),...,<I>V</I><SUB><I>n</I></SUB>(&#X3BB;<SUB>0</SUB>) )+ </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>+...+det(<I>V</I><SUB>1</SUB>(&#X3BB;<SUB>0</SUB>),<I>V</I><SUB>2</SUB>(&#X3BB;<SUB>0</SUB>),...,<I>V</I>&#X2032;<SUB><I>n</I></SUB>(&#X3BB;<SUB>0</SUB>) )</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Il suffit alors de remarquer que
<I>V</I>&#X2032;<SUB><I>i</I></SUB>(&#X3BB;<SUB>0</SUB>) est le <I>i</I>-ième vecteur de la base canonique donc :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">det(<I>V</I><SUB>1</SUB>(&#X3BB;<SUB>0</SUB>),<I>V</I><SUB>2</SUB>(&#X3BB;<SUB>0</SUB>),...,<I>V</I>&#X2032;<SUB><I>i</I></SUB>(&#X3BB;<SUB>0</SUB>),...,<I>V</I><SUB><I>n</I></SUB>(&#X3BB;<SUB>0</SUB>) )
=<I>b</I><SUB><I>i</I>,<I>i</I></SUB>(&#X3BB;<SUB>0</SUB>) </TD></TR>
</TABLE><P>
Finalement :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>&#X2032;(&#X3BB;<SUB>0</SUB>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>i</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>b</I><SUB><I>i</I>,<I>i</I></SUB>(&#X3BB;<SUB>0</SUB>)=tr (<I>B</I>(&#X3BB;<SUB>0</SUB>)) </TD></TR>
</TABLE><P><B>Remarque</B> :<BR>
En réindexant les coefficients de <I>P</I> et <I>B</I> de la manière suivante :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>P</I>(&#X3BB;)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>&#X3BB;<SUP><I>n</I></SUP>+<I>p</I><SUB>1</SUB>&#X3BB;<SUP><I>n</I>&#X2212;1</SUP>+<I>p</I><SUB>2</SUB>&#X3BB;<SUP><I>n</I>&#X2212;2</SUP>...+<I>p</I><SUB><I>n</I></SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>B</I>(&#X3BB;)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>&#X3BB;<SUP><I>n</I>&#X2212;1</SUP><I>I</I>+&#X3BB;<SUP><I>n</I>&#X2212;2</SUP><I>B</I><SUB>1</SUB>+...+<I>B</I><SUB><I>n</I>&#X2212;1</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
on a montré que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X23A7;<BR>
&#X23AA;<BR>
&#X23AA;<BR>
&#X23AA;<BR>
&#X23AA;<BR>
&#X23A8;<BR>
&#X23AA;<BR>
&#X23AA;<BR>
&#X23AA;<BR>
&#X23AA;<BR>
&#X23A9;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>A</I><SUB>1</SUB>=<I>A</I>,</TD><TD ALIGN=center NOWRAP><I>p</I><SUB>1</SUB>=&#X2212;tr(<I>A</I>),</TD><TD ALIGN=center NOWRAP><I>B</I><SUB>1</SUB>=<I>A</I><SUB>1</SUB>+<I>p</I><SUB>1</SUB><I>I</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I><SUB>2</SUB>=<I>AB</I><SUB>1</SUB>,</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>p</I><SUB>2</SUB>=&#X2212;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell">tr(<I>A</I><SUB>2</SUB>),</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><I>B</I><SUB>2</SUB>=<I>A</I><SUB>2</SUB>+<I>p</I><SUB>2</SUB><I>I</I> </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>&#X22EE; </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>A</I><SUB><I>k</I></SUB>=<I>AB</I><SUB><I>k</I>&#X2212;1</SUB>,</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><I>p</I><SUB><I>k</I></SUB>=&#X2212;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">tr(<I>A</I><SUB><I>k</I></SUB>),</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><I>B</I><SUB><I>k</I></SUB>=<I>A</I><SUB><I>k</I></SUB>+<I>p</I><SUB><I>k</I></SUB><I>I</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD></TR>
</TABLE><P>
On peut alors vérifier que <I>B</I><SUB><I>n</I></SUB>=<I>A</I><SUB><I>n</I></SUB>+<I>p</I><SUB><I>n</I></SUB><I>I</I>=0.
D&#X2019;où ce petit programme à utiliser avec xcas en mode mupad 
(<CODE>maple_mode(2);</CODE>), ou avec MuPAD, ou à adapter
avec un autre système :
</P><PRE CLASS="verbatim">iequalj:=(j,k)-&gt;if j=k then return(1); else return(0); end_if;
faddeev:=proc(A) // renvoie la liste des matrices B et le polynome P
local Aj,AAj,Id,coef,n,pcara,lmat;
begin
 n:=ncols(A);
 Id:=matrix(n,n,iequalj);     // matrice identite
 Aj:=Id;
 lmat:=[];                    // B initialise a liste vide
 pcara:=[1];                  // coefficient de plus grand degre de P
 for j from 1 to n do
  lmat:=append(lmat,Aj);      // rajoute Aj a la liste de matrices
  AAj:=Aj*A;
  coef:=-trace(AAj)/j;        // mupad linalg::tr
  pcara:=append(pcara,coef);  // rajoute coef au polynome caracteristique
  Aj:=AAj+coef*Id;
 end_for;
 lmat,pcara;                  // resultat
end_proc;
</PRE><!--TOC subsubsection Les vecteurs propres simples.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc77">10.2.5</A>  Les vecteurs propres simples.</H4><!--SEC END --><P>
On suppose ici qu&#X2019;on peut factoriser le polynôme caractéristique
(ou calculer dans une extension algébrique d&#X2019;un corps).
Lorsqu&#X2019;on a une valeur propre simple &#X3BB;<SUB>0</SUB>, en écrivant
la relation (<I>A</I>&#X2212;&#X3BB;<SUB>0</SUB> <I>I</I>)<I>B</I>(&#X3BB;<SUB>0</SUB>)=<I>P</I>(&#X3BB;<SUB>0</SUB>)<I>I</I>=0,
on voit que les vecteurs colonnes de la matrice <I>B</I>(&#X3BB;<SUB>0</SUB>)
sont vecteurs propres.
Remarquer que <I>B</I>(&#X3BB;<SUB>0</SUB>) &#X2260; 0 sinon on pourrait factoriser
&#X3BB;&#X2212;&#X3BB;<SUB>0</SUB> dans <I>B</I>(&#X3BB;) et apres simplifications on aurait :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>A</I>&#X2212;&#X3BB;<SUB>0</SUB> <I>I</I>)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">&#X3BB;&#X2212;&#X3BB;<SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">(&#X3BB;<SUB>0</SUB>)=
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>P</I></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">&#X3BB;&#X2212;&#X3BB;<SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell">(&#X3BB;<SUB>0</SUB>)<I>I</I> </TD></TR>
</TABLE><P>
or le 2ème membre est inversible en &#X3BB;<SUB>0</SUB> ce qui n&#X2019;est pas le
cas du premier.
Pour avoir une base des vecteurs propres associés à &#X3BB;<SUB>0</SUB>, on
calcule <I>B</I>(&#X3BB;<SUB>0</SUB>)  par la méthode de Horner appliquée au
polynôme <I>B</I>(&#X3BB;) en &#X3BB;=&#X3BB;<SUB>0</SUB>, et on réduit en
colonnes la matrice obtenue.</P><!--TOC subsubsection La forme normale de Jordan-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc78">10.2.6</A>  La forme normale de Jordan</H4><!--SEC END --><P> <A NAME="sec:jordan"></A>
Pour les valeurs propres de multiplicité plus grande que 1, on souhaiterait 
généraliser la méthode ci-dessus pour obtenir une base
de l&#X2019;espace caractéristique, sous forme de cycles de Jordan.
Soit &#X3BB; <SUB><I>i</I></SUB>, <I>n</I><SUB><I>i</I></SUB> les valeurs propres comptées avec leur 
multiplicité. On fait un développement de Taylor en
&#X3BB; <SUB><I>i</I></SUB>:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>&#X2212;<I>P</I>(&#X3BB; )<I>I</I></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(<I>A</I>&#X2212;&#X3BB; <I>I</I>)</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell">
<I>B</I>(&#X3BB;<SUB><I>i</I></SUB> )+ <I>B</I>&#X2032;(&#X3BB; <SUB><I>i</I></SUB>)(&#X3BB; &#X2212;&#X3BB; <SUB><I>i</I></SUB>)
+ ... +  </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I>&#X2212;1)</SUP>(&#X3BB;<SUB><I>i</I></SUB> )</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>&#X2212;1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
(&#X3BB; &#X2212;&#X3BB; <SUB><I>i</I></SUB>)<SUP><I>n</I>&#X2212;1</SUP> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">&#X2212;(&#X3BB; &#X2212;&#X3BB; <SUB><I>i</I></SUB>)<SUP><I>n</I><SUB><I>i</I></SUB></SUP>
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>&#X2260; <I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> (&#X3BB; &#X2212;&#X3BB; <SUB><I>j</I></SUB>)<SUP><I>n</I><SUB><I>j</I></SUB></SUP> <I>I</I> </TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Comme <I>A</I>&#X2212;&#X3BB; <I>I</I>=<I>A</I>&#X2212;&#X3BB; <SUB><I>i</I></SUB> <I>I</I> &#X2212; (&#X3BB; &#X2212;&#X3BB; <SUB><I>i</I></SUB>)<I>I</I>, on obtient
pour les <I>n</I><SUB><I>i</I></SUB> premières puissances de &#X3BB; &#X2212;&#X3BB; <SUB><I>i</I></SUB>:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">


     

</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><A NAME="eq:jordan1"> </A>
(<I>A</I>&#X2212;&#X3BB; <SUB><I>i</I></SUB> <I>I</I>) <I>B</I>(&#X3BB; <SUB><I>i</I></SUB>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>0</TD><TD ALIGN=right NOWRAP>    (26)</TD></TR>
<TR><TD ALIGN=right NOWRAP>(<I>A</I>&#X2212;&#X3BB; <SUB><I>i</I></SUB> <I>I</I>) <I>B</I>&#X2032;(&#X3BB; <SUB><I>i</I></SUB>)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>B</I>(&#X3BB;<SUB><I>i</I></SUB> )</TD><TD ALIGN=right NOWRAP>    (27)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP> ...</TD><TD ALIGN=left NOWRAP> </TD><TD ALIGN=right NOWRAP>    (28)</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(<I>A</I>&#X2212;&#X3BB; <SUB><I>i</I></SUB> <I>I</I>) </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>&#X2212;1)</SUP>(&#X3BB; <SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I><SUB><I>i</I></SUB>&#X2212;1)!</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> 
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>&#X2212;2)</SUP>(&#X3BB; <SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I><SUB><I>i</I></SUB>&#X2212;2)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <A NAME="eq:jordan3"> </A> </TD></TR>
</TABLE></TD><TD ALIGN=right NOWRAP>    (29)</TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">(<I>A</I>&#X2212;&#X3BB; <SUB><I>i</I></SUB> <I>I</I>)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>)</SUP>(&#X3BB;<SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I><SUB><I>i</I></SUB>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> &#X2212;  
</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>&#X2212;1)</SUP>(&#X3BB;<SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I><SUB><I>i</I></SUB>&#X2212;1)!</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">&#X2212;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>&#X2260; <I>i</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">(&#X3BB; <SUB><I>i</I></SUB>&#X2212;&#X3BB; <SUB><I>j</I></SUB>)<SUP><I>n</I><SUB><I>j</I></SUB></SUP> <I>I</I> <A NAME="eq:jordan4"> </A>
</TD></TR>
</TABLE></TD><TD ALIGN=right NOWRAP>    (30)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Le calcul des matrices <I>B</I><SUP>(<I>n</I>)</SUP>(&#X3BB; <SUB><I>i</I></SUB>)/<I>n</I>! pour <I>n</I>&lt;<I>n</I><SUB><I>i</I></SUB> se fait en
appliquant <I>n</I><SUB><I>i</I></SUB> fois l&#X2019;algorithme de Horner (avec reste).</P><DIV CLASS="theorem"><B>Théorème 9</B>  <EM> </EM><A NAME="th:jordan"></A><EM>
L&#X2019;espace caractéristique de </EM><EM>&#X3BB; </EM><SUB><EM><I>i</I></EM></SUB><EM> est égal à
l&#X2019;image de </EM><EM><I>B</I></EM><SUP><EM>(<I>n</I></EM><SUB><EM><I>i</I></EM></SUB><EM>&#X2212;1)</EM></SUP><EM>(&#X3BB; </EM><SUB><EM><I>i</I></EM></SUB><EM>)/(<I>n</I></EM><SUB><EM><I>i</I></EM></SUB><EM>&#X2212;1)!</EM><EM>.
</EM></DIV><P>
<B>Preuve :</B><BR>
On montre d&#X2019;abord que Im<I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>&#X2212;1)</SUP>(&#X3BB; <SUB><I>i</I></SUB>)/(<I>n</I><SUB><I>i</I></SUB>&#X2212;1)! est inclus
dans l&#X2019;espace caractéristique correspondant à &#X3BB;<SUB><I>i</I></SUB> en
appliquant l&#X2019;équation (<A HREF="#eq:jordan3">29</A>) et les équations précédentes.
Réciproquement on veut prouver que tout vecteur caractéristique <I>v</I> est dans 
l&#X2019;image de <I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>&#X2212;1)</SUP>(&#X3BB; <SUB><I>i</I></SUB>)/(<I>n</I><SUB><I>i</I></SUB>&#X2212;1)!. Prouvons le par récurrence
sur le plus petit entier <I>m</I> tel que
(<I>A</I>&#X2212;&#X3BB; <SUB><I>i</I></SUB>)<SUP><I>m</I></SUP><I>v</I>=0. Le cas <I>m</I>=0 est clair puisque <I>v</I>=0.
Supposons le cas <I>m</I> vrai, prouvons le cas <I>m</I>+1. On applique l&#X2019;équation
(<A HREF="#eq:jordan4">30</A>) à <I>v</I>, il suffit alors de prouver que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>w</I>=(<I>A</I>&#X2212;&#X3BB; <SUB><I>i</I></SUB>)</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>)</SUP>(&#X3BB;<SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I><SUB><I>i</I></SUB>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>v</I></TD></TR>
</TABLE><P>
appartient à l&#X2019;image de
<I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>&#X2212;1)</SUP>(&#X3BB; <SUB><I>i</I></SUB>)/(<I>n</I><SUB><I>i</I></SUB>&#X2212;1)!.
Comme <I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>)</SUP>(&#X3BB;<SUB><I>i</I></SUB>)
commute avec <I>A</I> (car c&#X2019;est un polynôme en <I>A</I> ou en appliquant
le fait que <I>B</I>(&#X3BB;) inverse de <I>A</I>&#X2212;&#X3BB; <I>I</I>):
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>A</I>&#X2212;&#X3BB; <SUB><I>i</I></SUB>)<SUP><I>m</I></SUP> <I>w</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>)</SUP>(&#X3BB;<SUB><I>i</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>n</I><SUB><I>i</I></SUB>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
(<I>A</I>&#X2212;&#X3BB; <SUB><I>i</I></SUB>)<SUP><I>m</I>+1</SUP><I>v</I>=0 </TD></TR>
</TABLE><P>
et on applique l&#X2019;hypothèse de récurrence à <I>w</I>.</P><P>Pour calculer les cycles de Jordan, nous allons effectuer une
réduction par le pivot de Gauß simultanément sur les colonnes
des matrices <I>B</I><SUP>(<I>k</I>)</SUP>(&#X3BB; <SUB><I>i</I></SUB>)/<I>k</I>! où <I>k</I>&lt;<I>n</I><SUB><I>i</I></SUB>. 
La simultanéité a pour but de conserver les
relations (<A HREF="#eq:jordan1">26</A>) à (<A HREF="#eq:jordan3">29</A>) pour les matrices
réduites. Pour visualiser l&#X2019;algorithme, on se représente les
matrices les unes au-dessus des autres, colonnes alignées.
On commence par réduire la matrice <I>B</I>(&#X3BB; <SUB><I>i</I></SUB>) jusqu&#X2019;à ce
que l&#X2019;on obtienne une matrice réduite <B>en recopiant</B> les opérations
élémentaires de colonnes faites sur <I>B</I>(&#X3BB; <SUB><I>i</I></SUB>) sur toutes les matrices
<I>B</I><SUP>(<I>k</I>)</SUP>(&#X3BB; <SUB><I>i</I></SUB>)/<I>k</I>!. On va continuer avec la liste des matrices
réduites issues de <I>B</I>&#X2032;(&#X3BB; <SUB><I>i</I></SUB>), ..., 
<I>B</I><SUP>(<I>n</I><SUB><I>i</I></SUB>&#X2212;1)</SUP>(&#X3BB; <SUB><I>i</I></SUB>)/(<I>n</I><SUB><I>i</I></SUB>&#X2212;1)!, 
mais en déplacant les colonnes non nulles de <I>B</I>(&#X3BB; <SUB><I>i</I></SUB>) 
d&#X2019;une matrice vers le bas
(pour une colonne non nulle de la matrice réduite <I>B</I>(&#X3BB; )
les colonnes correspondantes de <I>B</I><SUP>(<I>k</I>)</SUP>(&#X3BB; <SUB><I>i</I></SUB>) réduite 
sont remplacées par les colonnes correspondantes de <I>B</I><SUP>(<I>k</I>&#X2212;1)</SUP>(&#X3BB; <SUB><I>i</I></SUB>)
réduite pour <I>k</I> décroissant de <I>n</I><SUB><I>i</I></SUB>&#X2212;1 vers 1).
À chaque étape, on obtient une famille (éventuellement vide)
de cycles de Jordan, ce sont les vecteurs colonnes correspondants 
aux colonnes non nulles de la matrice réduite du haut de la colonne.
On élimine bien sûr les colonnes correspondant aux fins de cycles
déjà trouvés.</P><P>Par exemple, si <I>B</I>(&#X3BB; <SUB><I>i</I></SUB>)&#X2260; 0, son rang est 1 et on a
une colonne non nulle, et un cycle de Jordan de longueur
<I>n</I><SUB><I>i</I></SUB> fait des <I>n</I><SUB><I>i</I></SUB> vecteurs colonnes des matrices
<I>B</I><SUP>(<I>k</I>)</SUP>(&#X3BB; <SUB><I>i</I></SUB>)/<I>k</I>! réduites. 
Plus généralement, on obtiendra plus qu&#X2019;un cycle de Jordan
(et dans ce cas <I>B</I>(&#X3BB; <SUB><I>i</I></SUB>)= 0).</P><!--TOC subsubsection Exemple 1-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc79">10.2.7</A>  Exemple 1</H4><!--SEC END --><P> <A NAME="sec:ex1"></A></P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 3</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>2 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
&#X3BB; =2 est valeur propre de multiplicité 2, on obtient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>B</I>(&#X3BB; )= &#X3BB; <SUP>2</SUP> <I>I</I> + &#X3BB; </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> &#X2212;2</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>&#X2212;5</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>&#X2212;3 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">
+ </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X2212;3</TD><TD ALIGN=center NOWRAP>5</TD><TD ALIGN=center NOWRAP>&#X2212;1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X2212;2</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>2 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
on applique l&#X2019;algorithme de Horner :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>B</I>(2)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 1</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">,</TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><I>B</I>&#X2032;(2)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 2</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Comme <I>B</I>(2)&#X2260; 0, on pourrait arrêter les calculs en utilisant
une colonne non nulle et le cycle de Jordan associé
(2,2,1)&#X2192; (1,1,0) &#X2192; (0,0,0) . Expliquons tout
de même l&#X2019;algorithme général sur cet exemple. La réduction
de <I>B</I>(2) s&#X2019;obtient en effectuant les manipulations de colonnes
<I>C</I><SUB>2</SUB>+<I>C</I><SUB>1</SUB> &#X2192; <I>C</I><SUB>2</SUB> et <I>C</I><SUB>3</SUB>&#X2212;<I>C</I><SUB>1</SUB> &#X2192; <I>C</I><SUB>3</SUB>. 
On effectue les mêmes opérations sur <I>B</I>&#X2032;(2) 
et on obtient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">, </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 2</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
L&#X2019;étape suivante consiste à déplacer vers le bas d&#X2019;une matrice les
colonnes non nulles de la matrice du haut, on obtient :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
qui se réduit en :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
on chercherait alors dans les colonnes 2 et 3 de nouveaux cycles (puisque
la colonne 1 a déja été utilisée pour fournir un cycle).</P><!--TOC subsubsection Exemple 2-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc80">10.2.8</A>  Exemple 2</H4><!--SEC END --><P> <A NAME="sec:ex2"></A>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 3</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>&#X2212;2 </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
&#X3BB; =1 est valeur propre de multiplicité 3.
On trouve :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>B</I>(1)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">, </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><I>B</I>&#X2032;(1)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>&#X2212;2 </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">, </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"> <I>B</I>&#X2032;&#X2032;(1)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Le processus de réduction commence avec <I>B</I>&#X2032;(1) en haut de la liste
de matrices, on effectue les opérations élémentaires de
colonne <I>C</I><SUB>2</SUB>&#X2212;<I>C</I><SUB>1</SUB>&#X2192; <I>C</I><SUB>2</SUB>
et <I>C</I><SUB>3</SUB>+<I>C</I><SUB>1</SUB> &#X2192; <I>C</I><SUB>3</SUB> et on obtient:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">, </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=right NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
La première colonne donne le premier cycle de Jordan
(1,0,0) &#X2192; (2,&#X2212;1,1).
On déplace les premières colonnes d&#X2019;une matrice vers le bas :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
qu&#X2019;on réduit par les opérations 2<I>C</I><SUB>2</SUB> +<I>C</I><SUB>1</SUB> &#X2192; <I>C</I><SUB>2</SUB> et
2<I>C</I><SUB>3</SUB>&#X2212;<I>C</I><SUB>1</SUB>&#X2192; <I>C</I><SUB>3</SUB> en :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
Puis on effectue <I>C</I><SUB>3</SUB>&#X2212;<I>C</I><SUB>2</SUB> &#X2192; <I>C</I><SUB>3</SUB> et la deuxième colonne
nous donne le deuxième cycle de Jordan, réduit ici à un
seul vecteur propre (0,1,1).</P><!--TOC subsubsection Le polynôme minimal par Faddeev-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc81">10.2.9</A>  Le polynôme minimal par Faddeev</H4><!--SEC END --><P>
On vérifie aisément que le degré du facteur 
(&#X3BB;&#X2212;&#X3BB;<SUB><I>i</I></SUB>) dans le polynôme minimal de <I>A</I> est égal
à <I>n</I><SUB><I>i</I></SUB>&#X2212;<I>k</I> où <I>k</I> est le plus grand entier tel que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X2200; <I>j</I>&lt;<I>k</I>,    <I>B</I><SUP>(<I>j</I>)</SUP>(&#X3BB;<SUB><I>i</I></SUB>)=0 </TD></TR>
</TABLE><!--TOC subsubsection Formes normales rationnelles-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc82">10.2.10</A>  Formes normales rationnelles</H4><!--SEC END --><P>
On se place ici dans une problématique différente : trouver une matrice
semblable la plus simple possible sans avoir à introduire d&#X2019;extension
algébrique pour factoriser le polynôme caractéristique.
Quitte à &#X201C;compléter&#X201D; plus tard la factorisation et la jordanisation à
partir de la forme simplifiée. Il existe diverses formes associées
à une matrice et plusieurs algorithmes permettant de les relier entre elles,
forme de Smith, de Frobenius, forme normale de Jordan rationnelle.</P><P>On va présenter une méthode directe de calcul d&#X2019;une forme normale
contenant le maximum de zéros (dont la forme dite normale de Jordan
rationnelle peut se déduire) en utilisant le même algorithme que pour 
la forme
normale de Jordan. Soit <I>Q</I>(&#X3BB;)=<I>q</I><SUB>0</SUB>+...+<I>q</I><SUB><I>d</I></SUB> &#X3BB;<SUP><I>d</I></SUP> 
un facteur irréductible
de degré <I>d</I> et de multiplicité <I>q</I> 
du polynôme caractéristique <I>P</I>. Il
s&#X2019;agit de construire un sous-espace de dimension <I>dq</I> formé de &#X201C;cycles
de Jordan rationnels&#X201D;.
On part toujours de la relation 
(&#X3BB; <I>I</I> &#X2212;<I>A</I>) &#X2211;<SUB><I>k</I>&#X2264; <I>n</I>&#X2212;1</SUB> <I>B</I><SUB><I>k</I></SUB> &#X3BB;<SUP><I>k</I></SUP>=<I>P</I>(&#X3BB;)<I>I</I>.
On observe que <I>Q</I>(&#X3BB;)<I>I</I>&#X2212;<I>Q</I>(<I>A</I>) est divisible par (&#X3BB; <I>I</I> &#X2212;<I>A</I>) 
donc il existe une matrice <I>M</I>(&#X3BB;) telle que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(<I>Q</I>(&#X3BB;) <I>I</I> &#X2212;<I>Q</I>(<I>A</I>)) (</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I>&#X2264; <I>n</I>&#X2212;1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>B</I><SUB><I>k</I></SUB> &#X3BB;<SUP><I>k</I></SUP>)
=<I>Q</I>(&#X3BB;)<SUP><I>q</I></SUP> <I>M</I>(&#X3BB;) </TD></TR>
</TABLE><P>
On observe aussi que <I>Q</I> a pour coefficient dominant 1 puisqu&#X2019;il divise
<I>P</I>, on peut donc effectuer des divisions euclidiennes de polynômes
donc de polynômes à coefficients matriciels par <I>Q</I> sans avoir
à diviser des coefficients. Ce qui nous
permet de décomposer <I>B</I>(&#X3BB;)=&#X2211;<SUB><I>k</I>&#X2264; <I>n</I>&#X2212;1</SUB> <I>B</I><SUB><I>k</I></SUB> &#X3BB;<SUP><I>k</I></SUP> en 
puissances croissantes de <I>Q</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>B</I>(&#X3BB;)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>k</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>C</I><SUB><I>k</I></SUB>(&#X3BB;) <I>Q</I>(&#X3BB;)<SUP><I>k</I></SUP>,    deg(<I>C</I><SUB><I>k</I></SUB>)&lt;<I>q</I> </TD></TR>
</TABLE><P>
On remplace et on écrit que les coefficients des puissances inférieures
à <I>q</I> de <I>Q</I> sont nulles (la <I>k</I>-ième étant non nulle
car <I>M</I>(&#X3BB;) n&#X2019;est pas divisible par <I>Q</I> pour les mêmes raisons
que pour la forme normale de Jordan). On a donc les relations :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Q</I>(<I>A</I>)<I>C</I><SUB>0</SUB> = 0,    <I>C</I><SUB><I>k</I></SUB> = <I>Q</I>(<I>A</I>) <I>C</I><SUB><I>k</I>+1</SUB> </TD></TR>
</TABLE><P>
ce qui donne une colonne de matrice 
<I>C</I><SUB><I>q</I>&#X2212;1</SUB> &#X2192; <I>C</I><SUB><I>q</I>&#X2212;2</SUB> ... &#X2192; <I>C</I><SUB>0</SUB> &#X2192; 0
qui sont images l&#X2019;une de l&#X2019;autre en appliquant <I>Q</I>(<I>A</I>). On peut alors
faire l&#X2019;algorithme de réduction simultanée sur les colonnes des <I>C</I><SUB><I>j</I></SUB>. 
On observe
ensuite que le nombre de cycles de Jordan de <I>Q</I>(<I>A</I>) de longueur donnée 
est un multiple de <I>d</I>, en effet il suffit de multiplier
un cycle par <I>A</I>, ..., <I>A</I><SUP><I>d</I>&#X2212;1</SUP> pour créer un autre cycle, de plus ces
cycles forment des familles libres car on a supposé <I>Q</I> irréductible.
On peut donc choisir pour un cycle de longueur <I>k</I> des bases de la forme
(<I>v</I><SUB><I>k</I>&#X2212;1</SUB>,<I>Av</I><SUB><I>k</I>&#X2212;1</SUB>...,<I>A</I><SUP><I>d</I>&#X2212;1</SUP><I>v</I><SUB><I>k</I>&#X2212;1</SUB>) &#X2192; ... 
&#X2192; (<I>v</I><SUB>0</SUB>,<I>Av</I><SUB>0</SUB>...,<I>A</I><SUP><I>d</I>&#X2212;1</SUP><I>v</I><SUB>0</SUB>) &#X2192; (0,...,0) 
où la flèche &#X2192; désigne l&#X2019;image par <I>Q</I>(<I>A</I>).
Si on écrit la matrice de <I>A</I> dans la base 
<I>v</I><SUB>0</SUB>,<I>Av</I><SUB>0</SUB>...,<I>A</I><SUP><I>d</I>&#X2212;1</SUP><I>v</I><SUB>0</SUB>,...,<I>v</I><SUB><I>k</I>&#X2212;1</SUB>,<I>Av</I><SUB><I>k</I>&#X2212;1</SUB>...,<I>A</I><SUP><I>d</I>&#X2212;1</SUP><I>v</I><SUB><I>k</I>&#X2212;1</SUB>
on obtient un &#X201C;quasi-bloc de Jordan rationnel&#X201D; de taille <I>kd</I> 
multiple de <I>d</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>&#X2212;<I>q</I><SUB>0</SUB></TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>&#X2212;<I>q</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>&#X2212;<I>q</I><SUB>2</SUB></TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>...</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>&#X2212;<I>q</I><SUB><I>d</I>&#X2212;1</SUB></TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>&#X2212;<I>q</I><SUB>0</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>&#X2212;<I>q</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP>... </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP> </TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>&#X22EE;</TD><TD ALIGN=center NOWRAP>...</TD></TR>
</TABLE></TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P><B>Exemple</B><BR>
Soit la matrice
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;2</TD><TD ALIGN=center NOWRAP>4</TD><TD ALIGN=center NOWRAP>&#X2212;2</TD><TD ALIGN=center NOWRAP>5</TD><TD ALIGN=center NOWRAP>&#X2212;4 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">5</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;7</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;5</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;5</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">5</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>&#X2212;3 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">9</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;7</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>3</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;7</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE></TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>&#X2212;2</TD><TD ALIGN=center NOWRAP>3</TD><TD ALIGN=center NOWRAP>&#X2212;1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;3</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&#X2212;1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">3</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD><TD ALIGN=center NOWRAP><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">1</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
</TABLE></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
Son polynôme caractéristique est (<I>x</I>&#X2212;2)<SUP>2</SUP>(<I>x</I><SUP>2</SUP>&#X2212;2)<SUP>2</SUP> et on va déterminer
la partie bloc de Jordan rationnel correspondant au facteur irréductible
sur les entiers <I>Q</I>(<I>x</I>)=(<I>x</I><SUP>2</SUP>&#X2212;2) de multiplicité <I>q</I>=2. 
On calcule <I>B</I>(<I>x</I>) et l&#X2019;écriture de <I>B</I> comme
somme de puissances de <I>Q</I> (ici avec <CODE>xcas</CODE> en mode <CODE>xcas</CODE>) :
</P><PRE CLASS="verbatim">A:=[[1,-2,4,-2,5,-4],[0,1,5/2,(-7)/2,2,(-5)/2],[1,(-5)/2,2,1/(-2),5/2,-3],
    [0,-1,9/2,(-7)/2,3,(-7)/2],[0,0,2,-2,3,-1],[1,(-3)/2,1/(-2),1,3/2,1/2]];
P:=det(A-x*idn(6));
B:=normal(P*inv(A-x*idn(6))); // preferer un appel a faddeev bien sur!
ecriture(B,Q,q):={
  local j,k,l,n,C,D,E;
  C:=B;
  D:=B;
  E:=NULL;
  n:=coldim(B);
  for (j:=0;j&lt;q;j++){ 
    for (k:=0;k&lt;n;k++){
      for (l:=0;l&lt;n;l++){
        D[k,l]:=rem(C[k,l],Q,x);
        C[k,l]:=quo(C[k,l],Q,x);
      }
    }
    E:=E,D;
  }
  return E;
};
E:=ecriture(B,x^2-2,2);
QA:=A*A-2*idn(6);
</PRE><P>On vérifie bien que <CODE>normal(QA*E(0))</CODE> et
<CODE>normal(QA*E(1))-E(0))</CODE> sont nuls. On sait qu&#X2019;on a un bloc de
taille 2 de cycles de Jordan de longueur 2, donc il n&#X2019;est pas nécessaire
de faire des réductions ici, il suffit de prendre une colonne non nulle
de <I>E</I>(0), par exemple la première colonne en <I>x</I>=0
et la colonne correspondante de <I>E</I>(1) et leurs images par <I>A</I>, ici
cela donne (4,24,12,32,8,&#X2212;4) correspondant à (0,4,&#X2212;4,8,4,&#X2212;4),
on calcule les images par <I>A</I>, la matrice de l&#X2019;endomorphisme
restreint à ce sous-espace est alors le bloc de taille 4 :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>2 </TD></TR>
<TR><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>Cette forme normale minimise le nombre de coefficients non nuls,
mais présente un inconvénient, la partie nilpotente ne commute pas
avec la partie bloc-diagonale, contrairement à la forme normale
rationnelle de Jordan qui contient des blocs identités au-dessus
de la diagonale de blocs.
Pour créer la forme normale rationnelle de Jordan, on doit donc remplacer
les blocs ( </P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>...</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
<TR><TD ALIGN=center NOWRAP>... </TD></TR>
</TABLE><P> )
par des matrices identités. Supposons constitués les <I>j</I> premiers blocs de
taille <I>d</I> numérotés de 0 à <I>j</I>&#X2212;1 avec comme base de vecteurs
(<I>v</I><SUB>0,0</SUB>,...,<I>v</I><SUB>0,<I>d</I>&#X2212;1</SUB>,...,<I>v</I><SUB><I>j</I>&#X2212;1,<I>d</I>&#X2212;1</SUB>). 
Il s&#X2019;agit de trouver un vecteur <I>v</I><SUB><I>j</I>,0</SUB> pour commencer le bloc
suivant. On définit alors <I>v</I><SUB><I>j</I>,<I>l</I></SUB> en fonction de <I>v</I><SUB><I>j</I>,<I>l</I>&#X2212;1</SUB>
en appliquant la relation <I>Av</I><SUB><I>j</I>,<I>l</I>&#X2212;1</SUB>=<I>v</I><SUB><I>j</I>,<I>l</I></SUB>+<I>v</I><SUB><I>j</I>&#X2212;1,<I>l</I>&#X2212;1</SUB>.
Il faut donc chercher <I>v</I><SUB><I>j</I>,0</SUB> tel que 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:jordanrat1"></A>
<I>Av</I><SUB><I>j</I>,<I>d</I>&#X2212;1</SUB>=&#X2212;<I>q</I><SUB>0</SUB> <I>v</I><SUB><I>j</I>,0</SUB>&#X2212;...&#X2212;<I>q</I><SUB><I>d</I>&#X2212;1</SUB> <I>v</I><SUB><I>j</I>,<I>d</I>&#X2212;1</SUB>+<I>v</I><SUB><I>j</I>&#X2212;1,<I>d</I>&#X2212;1</SUB> 
    (31)</TD></TR>
</TABLE><P>
En utilisant les relations de récurrence précédentes, on voit que
cela revient à fixer <I>Q</I>(<I>A</I>)<I>v</I><SUB><I>j</I>,0</SUB> en fonction des <I>v</I><SUB><I>j</I>&#X2032;,<I>l</I></SUB> avec
<I>j</I>&#X2032;&lt;<I>j</I> (<I>l</I> quelconque). Ce qui est toujours possible en utilisant
la colonne de matrices <I>C</I><SUB><I>j</I>&#X2032;</SUB> qui s&#X2019;obtiennent en
fonction des <I>C</I><SUB><I>j</I>&#X2032;+1</SUB> en appliquant <I>Q</I>(<I>A</I>).</P><P>Plus précisément, calculons les <I>v</I><SUB><I>j</I>,<I>l</I></SUB> en fonction de <I>v</I><SUB><I>j</I>,0</SUB>
et des <I>v</I><SUB><I>j</I>&#X2032;,<I>l</I>&#X2032;</SUB> (<I>j</I>&#X2032;&lt;<I>j</I>). On utilise les coefficients binomiaux 
( <SUB><I>m</I></SUB><SUP><I>l</I></SUP>) calculés par la règle du triangle de Pascal et
on montre par récurrence que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:jordanrat3"></A>
<I>v</I><SUB><I>j</I>,<I>l</I></SUB> = <I>A</I><SUP><I>l</I></SUP> <I>v</I><SUB><I>j</I>,0</SUB> &#X2212; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">inf(<I>l</I>,<I>j</I>)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>l</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X23A0;</TD><TD CLASS="dcell"><I>v</I><SUB><I>j</I>&#X2212;<I>m</I>,<I>l</I>&#X2212;<I>m</I></SUB>
    (32)</TD></TR>
</TABLE><P>
On remplace dans (<A HREF="#eq:jordanrat1">31</A>) d&#X2019;où :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I><SUP><I>d</I></SUP> <I>v</I><SUB><I>j</I>,0</SUB> &#X2212; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">inf(<I>d</I>,<I>j</I>)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>d</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X23A0;</TD><TD CLASS="dcell"><I>v</I><SUB><I>j</I>&#X2212;<I>m</I>,<I>l</I>&#X2212;<I>m</I></SUB>
+ </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
<I>q</I><SUB><I>l</I></SUB> (<I>A</I><SUP><I>l</I></SUP> <I>v</I><SUB><I>j</I>,0</SUB> &#X2212; </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">inf(<I>l</I>,<I>j</I>)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>l</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X23A0;</TD><TD CLASS="dcell">
<I>v</I><SUB><I>j</I>&#X2212;<I>m</I>,<I>l</I>&#X2212;<I>m</I></SUB> )=0
</TD></TR>
</TABLE><P>
finalement :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:jordanrat"></A>
<I>Q</I>(<I>A</I>) <I>v</I><SUB><I>j</I>,0</SUB>= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>d</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> 
<I>q</I><SUB><I>l</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">inf(<I>l</I>,<I>j</I>)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>l</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X23A0;</TD><TD CLASS="dcell"><I>v</I><SUB><I>j</I>&#X2212;<I>m</I>,<I>l</I>&#X2212;<I>m</I></SUB> 
    (33)</TD></TR>
</TABLE><P><B>Application à l&#X2019;exemple :</B><BR>
Ici <I>v</I><SUB>0,0</SUB>=(4,24,12,32,8,&#X2212;4) et <I>v</I><SUB>0,1</SUB>=<I>Av</I><SUB><I>j</I>,0</SUB> dont une préimage
par <I>Q</I>(<I>A</I>) est <I>w</I><SUB>1,0</SUB>=(0,4,&#X2212;4,8,4,&#X2212;4) et <I>w</I><SUB>1,1</SUB>=<I>Aw</I><SUB>1,0</SUB>.
On applique (<A HREF="#eq:jordanrat">33</A>), comme <I>q</I><SUB>1</SUB>=0 et <I>q</I><SUB>2</SUB>=1
on doit avoir :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Q</I>(<I>A</I>) <I>v</I><SUB>1,0</SUB> = </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">2</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>l</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell">
<I>q</I><SUB><I>l</I></SUB> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">inf(<I>l</I>,1)</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>m</I>=1</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="left"><I>l</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="left">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="left"><I>m</I></TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X23A0;</TD><TD CLASS="dcell"><I>v</I><SUB>1&#X2212;<I>m</I>,<I>l</I>&#X2212;<I>m</I></SUB> 
=2<I>v</I><SUB>0,1</SUB> </TD></TR>
</TABLE><P>
donc  :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> <I>v</I><SUB>1,0</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=center NOWRAP>2<I>A</I>(0,4,&#X2212;4,8,4,&#X2212;4)</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=center NOWRAP>(&#X2212;8,&#X2212;32,0,&#X2212;48,&#X2212;16,16) </TD></TR>
<TR><TD ALIGN=center NOWRAP> <I>v</I><SUB>1,1</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=center NOWRAP><I>Av</I><SUB>1,0</SUB>&#X2212;<I>v</I><SUB>0,0</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=center NOWRAP>(4,40,&#X2212;4,64,24,&#X2212;20) </TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On vérifie bien que <I>Av</I><SUB>1,1</SUB>=2<I>v</I><SUB>1,0</SUB>+<I>v</I><SUB>0,1</SUB>.</P><!--TOC subsubsection Fonctions analytiques-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc83">10.2.11</A>  Fonctions analytiques</H4><!--SEC END --><P>
Soit <I>f</I> une fonction analytique et <I>M</I> une matrice. Pour calculer
<I>f</I>(<I>M</I>), on calcule la forme normale de Jordan de 
<I>M</I>=<I>P</I>(<I>D</I>+<I>N</I>)<I>P</I><SUP>&#X2212;1</SUP> où <I>D</I>=diag(<I>d</I><SUB>1</SUB>,...,<I>d</I><SUB><I>m</I></SUB>) est diagonale et <I>N</I> nilpotente
d&#X2019;ordre <I>n</I>. On calcule
aussi le développement de Taylor formel de <I>f</I> en <I>x</I> à l&#X2019;ordre
<I>n</I>&#X2212;1, on a alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>(<I>N</I>)=<I>P</I> </TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I>&#X2212;1</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X2211;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">diag(<I>f</I><SUP>(<I>j</I>)</SUP>(<I>d</I><SUB>1</SUB>),...,
<I>f</I><SUP>(<I>j</I>)</SUP>(<I>d</I><SUB><I>m</I></SUB>))</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>N</I><SUP><I>j</I></SUP> </TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell"><I>P</I><SUP>&#X2212;1</SUP></TD></TR>
</TABLE><!--TOC subsection Quelques autres algorithmes utiles-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc84">10.3</A>  Quelques autres algorithmes utiles</H3><!--SEC END --><P>
Pour calculer le produit de matrices, on peut utiliser
l&#X2019;algorithme de Strassen, on présente ici la variante
de Winograd. Soit à calculer :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>a</I><SUB>1,1</SUB></TD><TD ALIGN=center NOWRAP><I>a</I><SUB>1,2</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>a</I><SUB>2,1</SUB></TD><TD ALIGN=center NOWRAP><I>a</I><SUB>2,2</SUB> </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">
</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>b</I><SUB>1,1</SUB></TD><TD ALIGN=center NOWRAP><I>b</I><SUB>1,2</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>b</I><SUB>2,1</SUB></TD><TD ALIGN=center NOWRAP><I>b</I><SUB>2,2</SUB> </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">
=</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP><I>c</I><SUB>1,1</SUB></TD><TD ALIGN=center NOWRAP><I>c</I><SUB>1,2</SUB> </TD></TR>
<TR><TD ALIGN=center NOWRAP><I>c</I><SUB>2,1</SUB></TD><TD ALIGN=center NOWRAP><I>c</I><SUB>2,2</SUB> </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE><P>
On calcule :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I>s</I><SUB>1</SUB>=<I>a</I><SUB>2,1</SUB>+<I>a</I><SUB>2,2</SUB>,    <I>s</I><SUB>2</SUB>=<I>s</I><SUB>1</SUB>&#X2212;<I>a</I><SUB>1,1</SUB>,    
<I>s</I><SUB>3</SUB>=<I>a</I><SUB>1,1</SUB>&#X2212; <I>a</I><SUB>2,1</SUB>,    <I>s</I><SUB>4</SUB>=<I>a</I><SUB>1,2</SUB>&#X2212;<I>s</I><SUB>2</SUB></TD></TR>
<TR><TD ALIGN=right NOWRAP><I>t</I><SUB>1</SUB>=<I>b</I><SUB>1,2</SUB>&#X2212;<I>b</I><SUB>1,1</SUB>,    <I>t</I><SUB>2</SUB>=<I>b</I><SUB>2,2</SUB>&#X2212;<I>t</I><SUB>1</SUB>,
   <I>t</I><SUB>3</SUB>=<I>b</I><SUB>2,2</SUB>&#X2212;<I>b</I><SUB>1,2</SUB>,    <I>t</I><SUB>4</SUB>=<I>b</I><SUB>2,1</SUB>&#X2212;<I>t</I><SUB>2</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
puis :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> <I>p</I><SUB>1</SUB>=<I>a</I><SUB>1,1</SUB> <I>b</I><SUB>1,1</SUB>,   
<I>p</I><SUB>2</SUB>=<I>a</I><SUB>1,2</SUB><I>b</I><SUB>2,1</SUB>,   
<I>p</I><SUB>3</SUB>=<I>s</I><SUB>1</SUB> <I>t</I><SUB>1</SUB>,    <I>p</I><SUB>4</SUB>=<I>s</I><SUB>2</SUB> <I>t</I><SUB>2</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>p</I><SUB>5</SUB>=<I>s</I><SUB>3</SUB> <I>t</I><SUB>3</SUB>,    <I>p</I><SUB>6</SUB>=<I>s</I><SUB>4</SUB> <I>b</I><SUB>2,2</SUB>,
   <I>p</I><SUB>7</SUB>=<I>a</I><SUB>2,2</SUB> <I>t</I><SUB>4</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP><I>u</I><SUB>1</SUB>= <I>p</I><SUB>1</SUB>+<I>p</I><SUB>2</SUB>    <I>u</I><SUB>2</SUB>=<I>p</I><SUB>1</SUB>+<I>p</I><SUB>4</SUB>,
   <I>u</I><SUB>3</SUB>=<I>u</I><SUB>2</SUB>+<I>p</I><SUB>5</SUB>,    <I>u</I><SUB>4</SUB>=<I>u</I><SUB>3</SUB>+<I>p</I><SUB>7</SUB></TD></TR>
<TR><TD ALIGN=right NOWRAP><I>u</I><SUB>5</SUB>=<I>u</I><SUB>3</SUB>+<I>p</I><SUB>3</SUB>,   
<I>u</I><SUB>6</SUB>=<I>u</I><SUB>2</SUB>+<I>p</I><SUB>3</SUB>,    <I>u</I><SUB>7</SUB>=<I>u</I><SUB>6</SUB>+<I>p</I><SUB>6</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Alors <I>c</I><SUB>1,1</SUB>=<I>u</I><SUB>1</SUB>, <I>c</I><SUB>1,2</SUB>=<I>u</I><SUB>7</SUB>, <I>c</I><SUB>2,1</SUB>=<I>u</I><SUB>4</SUB>, <I>c</I><SUB>2,2</SUB>=<I>u</I><SUB>5</SUB>.<BR>
Cet algorithme utilise 7 multiplications et 15 additions
ce qui économise 1 multiplication et permet en appliquant
récursivement cet algorithme pour des matrices blocs
de réduire la complexité d&#X2019;un produit de grandes matrices
normalement en <I>O</I>(<I>n</I><SUP>3</SUP>) à <I>O</I>(<I>n</I><SUP>ln(7)</SUP>) (la preuve
est analogue à celle de la multiplication des polynômes
par l&#X2019;algorithme de Karatsuba).</P><P>La plupart des algorithmes d&#X2019;algèbre linéaire &#X201C;numérique&#X201D;
ont une utilité en calcul exact : par exemple la factorisation
<I>LU</I> (avec les variations décrites dans la section réduction
de Gauß), la factorisation <I>QR</I> (et donc la méthode de Gram-Schmidt,
ici pour des raisons d&#X2019;efficacité on orthogonalise d&#X2019;abord la
base de départ et on la normalise à la fin seulement),
Cholesky,.... On peut aussi facilement programmer la recherche de la
décomposition <SUP><I>t</I></SUP><I>P</I> <I>D</I> <I>P</I> d&#X2019;une matrice symétrique et en
déduire la signature d&#X2019;une forme quadratique.
Citons enfin l&#X2019;algorithme <I>LLL</I> (cf. Cohen) qui est utile
dans de nombreux domaines (il permet de trouver des vecteurs assez
courts dans un réseau, ce ne sont pas les plus courts, mais
en contrepartie on les trouve très vite).</P><!--TOC subsection Quelques références-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc85">10.4</A>  Quelques références</H3><!--SEC END --><P> <A NAME="sec:ref"></A></P><UL CLASS="itemize"><LI CLASS="li-itemize">
Comme toujours on renvoie à l&#X2019;excellent livre de Henri Cohen:
A Course in Computational Algebraic Number Theory</LI><LI CLASS="li-itemize">Gantmacher: Théorie des matrices</LI><LI CLASS="li-itemize">Pour une implémentation des algorithmes de forme normale
de Smith ou de Frobenius, cf. le source de MuPAD ou<BR>
<CODE>http://www.mapleapps.com/maplelinks/share/normform.html</CODE></LI><LI CLASS="li-itemize">Ferrard, Lemberg: Mathématiques Concrètes, Illustrées par la TI 92 
et la TI 89<BR>
Présente aussi des algorithmes plus numériques, et le lien avec
la diagonalisation numérique de matrices. </LI><LI CLASS="li-itemize">Press et al.: Numerical recipies in Fortran/C/Pascal.<BR>
Pour des algorithmes numériques (sur les matrices et autres).</LI></UL><!--TOC subsection Bézout et les <I>p</I>-adiques.-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc86">10.5</A>  Bézout et les <I>p</I>-adiques.</H3><!--SEC END --><P>
Soit <I>n</I> et <I>a</I>/<I>b</I> une fraction irréductible d&#X2019;entiers tels que 
<I>b</I> est premier avec <I>n</I> et |<I>a</I>| &lt; &#X221A;<SPAN style="text-decoration:overline"><I>n</I></SPAN>/2 et  0 &#X2264; <I>b</I> &#X2264; &#X221A;<SPAN style="text-decoration:overline"><I>n</I></SPAN>/2.
Il s&#X2019;agit de reconstruire <I>a</I> et <I>b</I> connaissant 
<I>x</I>=<I>a</I> × (<I>b</I><SUP>&#X2212;1</SUP>) (mod <I>n</I> ) avec <I>x</I>&#X2208; [0,<I>n</I>[.</P><P><B>Unicité</B><BR>
S&#X2019;il existe une solution (<I>a</I>,<I>b</I>) vérifiant |<I>a</I>| &lt; &#X221A;<SPAN style="text-decoration:overline"><I>n</I></SPAN>/2 et 
 0 &#X2264; <I>b</I> &#X2264; &#X221A;<SPAN style="text-decoration:overline"><I>n</I></SPAN>/2, soit (<I>a</I>&#X2032;,<I>b</I>&#X2032;) une solution
de <I>x</I>=<I>a</I> × (<I>b</I><SUP>&#X2212;1</SUP>) (mod <I>n</I> ) et 
vérifiant |<I>a</I>&#X2032;| &lt; &#X221A;<SPAN style="text-decoration:overline"><I>n</I></SPAN> et  0 &#X2264; <I>b</I>&#X2032; &#X2264; &#X221A;<SPAN style="text-decoration:overline"><I>n</I></SPAN>, alors :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I> <I>b</I>&#X2032;=<I>a</I>&#X2032; <I>b</I> (mod <I>n</I> ) </TD></TR>
</TABLE><P>
Comme |<I>ab</I>&#X2032;| &lt; <I>n</I>/2, |<I>a</I>&#X2032;<I>b</I>| &lt;<I>n</I>/2, 
on en déduit que <I>ab</I>&#X2032;=<I>a</I>&#X2032;<I>b</I>. Donc <I>a</I>/<I>b</I>=<I>a</I>&#X2032;/<I>b</I>&#X2032;
donc <I>a</I>=<I>a</I>&#X2032; et <I>b</I>=<I>b</I>&#X2032; car <I>a</I>/<I>b</I> et <I>a</I>&#X2032;/<I>b</I>&#X2032; sont supposées irréductibles.</P><P><B>Reconstruction lorsqu&#X2019;on sait qu&#X2019;il y a une solution</B><BR>
On suit l&#X2019;algorithme de calcul des coefficients de Bézout
pour les entiers <I>n</I> et <I>x</I>. On pose :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X3B1;<SUB><I>k</I></SUB> <I>n</I> + &#X3B2;<SUB><I>k</I></SUB> <I>x</I>= <I>r</I><SUB><I>k</I></SUB> </TD></TR>
</TABLE><P>
où les <I>r</I><SUB><I>k</I></SUB> sont les restes successifs de l&#X2019;algorithme d&#X2019;Euclide,
avec la condition initiale :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X3B1;<SUB>0</SUB>=1, &#X3B2;<SUB>0</SUB>=0, &#X3B1;<SUB>1</SUB>=0, &#X3B2;<SUB>1</SUB>=1, <I>r</I><SUB>0</SUB>=<I>n</I>, <I>r</I><SUB>1</SUB>=<I>x</I> </TD></TR>
</TABLE><P>
et la relation de récurrence :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X3B2;<SUB><I>k</I>+2</SUB>=&#X3B2;<SUB><I>k</I></SUB> &#X2212; <I>q</I><SUB><I>k</I>+2</SUB> &#X3B2;<SUB><I>k</I>+1</SUB>,   
<I>q</I><SUB><I>k</I>+2</SUB>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>r</I><SUB><I>k</I></SUB>&#X2212;<I>r</I><SUB><I>k</I>+2</SUB></TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>r</I><SUB><I>k</I>+1</SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>On a  &#X3B2;<SUB><I>k</I></SUB> <I>x</I>= <I>r</I><SUB><I>k</I></SUB> (mod <I>n</I> ) pour tout rang mais il faut vérifier
les conditions de taille sur &#X3B2;<SUB><I>k</I></SUB> et <I>r</I><SUB><I>k</I></SUB> pour trouver le couple
(<I>a</I>,<I>b</I>).
Montrons par récurrence que :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"> <A NAME="eq:rec"></A>
&#X3B2;<SUB><I>k</I>+1</SUB> <I>r</I><SUB><I>k</I></SUB> &#X2212; <I>r</I><SUB><I>k</I>+1</SUB> &#X3B2;<SUB><I>k</I></SUB> = (&#X2212;1)<SUP><I>k</I></SUP> <I>n</I> 
    (34)</TD></TR>
</TABLE><P>
Au rang <I>k</I>=0, on vérifie l&#X2019;égalité, on l&#X2019;admet au rang <I>k</I>, 
alors au rang <I>k</I>+1, on a :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP> &#X3B2;<SUB><I>k</I>+2</SUB> <I>r</I><SUB><I>k</I>+1</SUB> &#X2212; <I>r</I><SUB><I>k</I>+2</SUB> &#X3B2;<SUB><I>k</I>+1</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>&#X3B2;<SUB><I>k</I></SUB> <I>r</I><SUB><I>k</I>+1</SUB> &#X2212; <I>q</I><SUB><I>k</I>+2</SUB> <I>r</I><SUB><I>k</I>+1</SUB> &#X3B2;<SUB><I>k</I>+1</SUB>  &#X2212; <I>r</I><SUB><I>k</I>+2</SUB> &#X3B2;<SUB><I>k</I>+1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>&#X3B2;<SUB><I>k</I></SUB> <I>r</I><SUB><I>k</I>+1</SUB> &#X2212; (<I>r</I><SUB><I>k</I></SUB>&#X2212;<I>r</I><SUB><I>k</I>+2</SUB>) &#X3B2;<SUB><I>k</I>+1</SUB>  &#X2212; <I>r</I><SUB><I>k</I>+2</SUB> &#X3B2;<SUB><I>k</I>+1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>&#X3B2;<SUB><I>k</I></SUB> <I>r</I><SUB><I>k</I>+1</SUB> &#X2212; <I>r</I><SUB><I>k</I></SUB> &#X3B2;<SUB><I>k</I>+1</SUB> </TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP>&#X2212; (&#X2212;1)<SUP><I>k</I></SUP> <I>n</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
On vérifie aussi que le signe de &#X3B2;<SUB><I>k</I></SUB> est positif si <I>k</I> est impair
et négatif si <I>k</I> est pair, on déduit donc de (<A HREF="#eq:rec">34</A>) :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">|&#X3B2;<SUB><I>k</I>+1</SUB>| <I>r</I><SUB><I>k</I></SUB> &lt; <I>n</I> </TD></TR>
</TABLE><P>
(avec égalité si <I>r</I><SUB><I>k</I>+1</SUB>=0)</P><P>Considérons la taille des restes successifs, il existe un rang <I>k</I>
tel que <I>r</I><SUB><I>k</I></SUB> &#X2265; &#X221A;<SPAN style="text-decoration:overline"><I>n</I></SPAN> et <I>r</I><SUB><I>k</I>+1</SUB>&lt;&#X221A;<SPAN style="text-decoration:overline"><I>n</I></SPAN>. On a alors
|&#X3B2;<SUB><I>k</I>+1</SUB>| &lt; <I>n</I>/<I>r</I><SUB><I>k</I></SUB> &#X2264; &#X221A;<SPAN style="text-decoration:overline"><I>n</I></SPAN>.</P><P>Donc l&#X2019;algorithme de Bézout permet de reconstruire l&#X2019;unique couple
solution s&#X2019;il existe.</P><P><B>Exemple</B><BR>
On prend <I>n</I>=101, <I>a</I>=2, <I>b</I>=3, <I>a</I>/<I>b</I>=68 (mod 101 ).
Puis on effectue Bézout pour 68 et 101 en affichant les étapes 
intermédiaires (par exemple avec <CODE>IEGCD</CODE> sur une HP49 ou exercice
avec votre système de calcul formel) :
</P><PRE CLASS="verbatim">   = alpha*101+beta*68
101    1        0
 68    0        1  L1 - 1*L2
 33    1       -1  L2 - 2*L3
  2   -2        3  ...
</PRE><P>On s&#X2019;arrête à la première ligne telle que le coefficient de la 1ère colonne
est inférieur à &#X221A;<SPAN style="text-decoration:overline">101</SPAN>, on retrouve bien 2 et 3.
Quand on programme l&#X2019;algorithme de
reconstruction, on ne calcule bien sûr pas la colonne des &#X3B1;,
ce qui donne par exemple le programme xcas ou mupad suivant :
</P><PRE CLASS="verbatim">// Renvoie a/b tel que a/b=x mod n et |a|,|b|&lt;sqrt(n)
padictofrac:=proc (n,x)
  local r0,beta0,r1,beta1,r2,q2,beta2;
begin
  r0:=n;
  beta0:=0;
  r1:=x;
  beta1:=1;
  sqrtn:=float(sqrt(n));
  while r1&gt;sqrtn do
    r2:= irem(r0,r1); 
    q2:=(r0-r2)/r1;
    beta2:=beta0-q2*beta1;
    beta0:=beta1; r0:=r1; beta1:=beta2; r1:=r2;
  end_while;
  return(r1/beta1);
end_proc;
</PRE><!--TOC subsection Exercices (algèbre linéaire)-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc87">10.6</A>  Exercices (algèbre linéaire)</H3><!--SEC END --><!--TOC subsubsection Instructions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc88">10.6.1</A>  Instructions</H4><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
Les commandes d&#X2019;algèbre linéaire de Xcas sont
regroupées dans le menu <TT>Math-&gt;Alglin</TT>.
En maple et mupad, la commande <TT>?linalg</TT> affiche
la liste des commandes d&#X2019;algèbre linéaire. 
</LI><LI CLASS="li-itemize">En maple il est conseillé d&#X2019;exécuter <TT>with(linalg);</TT>,
en mupad <TT>export(linalg);</TT>, sinon il faut précéder
chaque commande de <TT>linalg::</TT>.
</LI><LI CLASS="li-itemize">En maple, attention
il faut utiliser le caractère <TT>&amp;</TT> avant la multiplication
et il faut souvent utiliser <TT>evalm</TT> dans les programmes
utilisant des matrices et vecteurs. 
</LI><LI CLASS="li-itemize">Pour travailler avec des
coefficients modulaires, en Xcas
on fait suivre les coefficients ou matrices de <TT>% n</TT>,
en maple on utilise les noms de commandes
avec une majuscule (forme inerte) suivi de <TT>mod n</TT>, en mupad
on définit les coefficients dans l&#X2019;anneau, par exemple<BR>
<CODE>Z19:=Dom::IntegerMod(19): MatZ19 := Dom::Matrix(Z19):</CODE><BR>
<CODE>A:=MatZ19([[1, 2], [2]]); Z19(5)*A;</CODE>
</LI></UL><!--TOC subsubsection Exercices-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc89">10.6.2</A>  Exercices</H4><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
En utilisant un logiciel de calcul formel,
comparez le temps de calcul d&#X2019;un déterminant de matrice
aléatoire à coefficients entiers de tailles 50 et 100, 
d&#X2019;une matrice de taille 6 et 12 avec comme coefficients symboliques
ligne <I>j</I> colonne <I>k</I>, <I>x</I><SUB><I>j</I>+<I>k</I></SUB> lorsque <I>j</I>+<I>k</I> est pair
et 0 sinon. Peut-on en déduire une indication sur l&#X2019;algorithme
utilisé?
</LI><LI CLASS="li-enumerate">Écrire un programme calculant la borne de Hadamard d&#X2019;un
déterminant à coefficients réels (rappel : c&#X2019;est la borne obtenue en faisant
le produit des normes euclidiennes des vecteurs colonnes).
</LI><LI CLASS="li-enumerate">Créez une matrice 4x4 aléatoire avec des coefficients entiers
compris entre -100 et 100, calculer la borne de Hadamard de son déterminant
avec le programme précédent, calculer ce déterminant modulo
quelques nombres premiers choisis en fonction de la borne de Hadamard
et vérifiez le résultat de la reconstruction modulaire du déterminant.
</LI><LI CLASS="li-enumerate">Créez une matrice 100x100 aléatoire à coefficients entiers
et calculez son déterminant
modulo quelques nombres premiers. Dans quels cas peut-on
conclure que la matrice est inversible dans &#X211D;? dans &#X2124;?
</LI><LI CLASS="li-enumerate">Écrire un programme calculant par interpolation de Lagrange
le polynôme caractéristique d&#X2019;une matrice (en donnant à &#X3BB;
de det(&#X3BB; <I>I</I> &#X2212;<I>A</I>), <I>n</I>+1 valeurs distinctes).
</LI><LI CLASS="li-enumerate">(Long) Écrire un programme qui calcule un déterminant de matrice
en calculant les mineurs 2x2 puis 3x3 etc. (méthode de Laplace)
</LI><LI CLASS="li-enumerate">Recherche du polynôme minimal. On prend un vecteur aléatoire
à coefficients entiers et on calcule <I>v</I>, <I>Av</I>, ..., <I>A</I><SUP><I>n</I></SUP><I>v</I> puis
on cherche une relation linéaire minimale entre ces vecteurs, en
calculant le noyau de la matrice ayant ces vecteurs colonnes. Si le
noyau est de dimension 1, alors le polynôme minimal est égal au
polynome caractéristique et correspond à un vecteur de la base du noyau.
Sinon, il faut choisir un vecteur du noyau correspondant au degré
le plus petit possible puis faire le PPCM avec les polynomes obtenurs
avec d&#X2019;autres vecteurs pour obtenir le polynôme minimal avec une grande
probabilité.
Essayez avec la matrice <I>A</I> de taille 3 ayant des 0 sur la diagonale et 
des 1 ailleurs.
Écrire un programme mettant en oeuvre cette recherche, testez-le avec
une matrice aléatoire de taille 30.
</LI><LI CLASS="li-enumerate">Testez l&#X2019;algorithme méthode de Fadeev pour la matrice <I>A</I> ci-dessus.
Même question pour 
<TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>A</I>=</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 3</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>2 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD><TD CLASS="dcell">,    
<I>A</I>=</TD><TD CLASS="dcell">&#X239B;<BR>
&#X239C;<BR>
&#X239C;<BR>
&#X239D;</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=center NOWRAP> 3</TD><TD ALIGN=center NOWRAP>2</TD><TD ALIGN=center NOWRAP>&#X2212;2 </TD></TR>
<TR><TD ALIGN=center NOWRAP>&#X2212;1</TD><TD ALIGN=center NOWRAP>0</TD><TD ALIGN=center NOWRAP>1 </TD></TR>
<TR><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>1</TD><TD ALIGN=center NOWRAP>0 </TD></TR>
</TABLE></TD><TD CLASS="dcell">&#X239E;<BR>
&#X239F;<BR>
&#X239F;<BR>
&#X23A0;</TD></TR>
</TABLE>
</LI><LI CLASS="li-enumerate">Écrire un programme calculant par une méthode itérative
la valeur propre de module maximal d&#X2019;une matrice à coefficients
complexes. Dans le cas réel, modifier le programme pour pouvoir
traiter le cas d&#X2019;un couple de complexes conjugués de module maximal.
Dans le cas hermitien ou réel symétrique, éliminer le couple valeur
propre/vecteur propre et continuer la diagonalisation numérique.
</LI><LI CLASS="li-enumerate">Soient |<I>a</I>|,|<I>b</I>|&lt;&#X221A;<SPAN style="text-decoration:overline"><I>n</I>/2</SPAN>
Écrire une fonction ayant comme arguments <I>a</I>/<I>b</I> (mod <I>n</I> ) 
qui calcule <I>a</I> et <I>b</I>.<BR>
Utiliser ce programme pour résoudre un système 4,4 à coefficients entiers
par une méthode <I>p</I>-adique.
</LI></OL><!--TOC subsection L&#X2019;algorithme du simplexe-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc90">10.7</A>  L&#X2019;algorithme du simplexe</H3><!--SEC END --><!--TOC section Interpolation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc91">11</A>  Interpolation</H2><!--SEC END --><P>
Étant donné la facilité de manipulation qu&#X2019;apportent les
polynomes, on peut chercher à approcher une fonction par un
polynôme. De plus l&#X2019;interpolation est un outil très utilisé
pour calculer des polynômes en calcul formel.</P><!--TOC subsection Lagrange-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc92">11.1</A>  Lagrange</H3><!--SEC END --><P>
La méthode la plus naturelle consiste à chercher
un polynôme de degré le plus petit possible
égal à la fonction en certains points <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I></SUB>
et à trouver une majoration de la différence entre la fonction
et le polynôme.
Le polynome interpolateur de Lagrange répond à cette question.</P><P>Soit donc <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I></SUB> des réels distincts et <I>y</I><SUB>0</SUB>,...,<I>y</I><SUB><I>n</I></SUB>
les valeurs de la fonction à approcher en ces points (on posera
<I>y</I><SUB><I>j</I></SUB>=<I>f</I>(<I>x</I><SUB><I>j</I></SUB>) pour approcher la fonction <I>f</I>). On cherche
donc <I>P</I> tel que <I>P</I>(<I>x</I><SUB><I>j</I></SUB>)=<I>y</I><SUB><I>i</I></SUB> pour <I>j</I> &#X2208; [0,<I>n</I>].</P><P>Commencons par voir s&#X2019;il y a beaucoup de solutions. Soit <I>P</I> et <I>Q</I>
deux solutions distinctes du problème, alors <I>P</I>&#X2212;<I>Q</I> est non nul
et va s&#X2019;annuler en <I>x</I><SUB>0</SUB>, ...,<I>x</I><SUB><I>n</I></SUB> donc possède <I>n</I>+1 racines donc
est de degré <I>n</I>+1 au moins. Réciproquement, si on ajoute
à <I>P</I> un multiple du polynome <I>A</I>=&#X220F;<SUB><I>j</I>=0</SUB><SUP><I>n</I></SUP> (<I>X</I>&#X2212;<I>x</I><SUB><I>j</I></SUB>), on obtient
une autre solution. Toutes les solutions se déduisent donc
d&#X2019;une solution particulière en y ajoutant un polynome de degré
au moins <I>n</I>+1 multiple de <I>A</I>. </P><P>Nous allons maintenant construire
une solution particulière de degré au plus <I>n</I>.
Si <I>n</I>=0, on prend <I>P</I>=<I>x</I><SUB>0</SUB> constant. On procède ensuite par
récurrence. Pour construire le polynôme correspondant
à <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I>+1</SUB> on part du polynoôme <I>P</I><SUB><I>n</I></SUB> correspondant à
<I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I></SUB> et on lui ajoute un multiple réel de <I>A</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB><I>n</I>+1</SUB>=<I>P</I><SUB><I>n</I></SUB>+<I>a</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>X</I>&#X2212;<I>x</I><SUB><I>j</I></SUB>) </TD></TR>
</TABLE><P>
Ainsi on a toujours <I>P</I><SUB><I>n</I>+1</SUB>(<I>x</I><SUB><I>j</I></SUB>)=<I>y</I><SUB><I>j</I></SUB> pour <I>j</I>=0,..<I>n</I>, on calcule
maintenant <I>a</I> pour que <I>P</I><SUB><I>n</I>+1</SUB>(<I>x</I><SUB><I>n</I>+1</SUB>)=<I>y</I><SUB><I>n</I>+1</SUB>.
En remplacant avec l&#X2019;expression de <I>P</I><SUB><I>n</I>+1</SUB> ci-dessus, on obtient
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I><SUB><I>n</I></SUB>(<I>x</I><SUB><I>n</I>+1</SUB>)+<I>a</I></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>x</I><SUB><I>n</I>+1</SUB>&#X2212;<I>x</I><SUB><I>j</I></SUB>) = <I>y</I><SUB><I>n</I>+1</SUB> </TD></TR>
</TABLE><P>
Comme tous les <I>x</I><SUB><I>j</I></SUB> sont distincts, il existe une solution unique <I>a</I> :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>a</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>y</I><SUB><I>n</I>+1</SUB>&#X2212;<I>P</I><SUB><I>n</I></SUB>(<I>x</I><SUB><I>n</I>+1</SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><TABLE CLASS="display"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell"> (<I>x</I><SUB><I>n</I>+1</SUB>&#X2212;<I>x</I><SUB><I>j</I></SUB>)</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>On a donc prouvé le :
</P><DIV CLASS="theorem"><B>Théorème 10</B>  <EM> </EM><A NAME="@default0"></A><EM> </EM><A NAME="@default1"></A><EM>
Soit </EM><EM><I>n</I>+1</EM><EM> réels distincts </EM><EM><I>x</I></EM><SUB><EM>0</EM></SUB><EM>,...,<I>x</I></EM><SUB><EM><I>n</I></EM></SUB><EM> et </EM><EM><I>n</I>+1</EM><EM>
réels quelconques </EM><EM><I>y</I></EM><SUB><EM>0</EM></SUB><EM>,...,<I>y</I></EM><SUB><EM><I>n</I></EM></SUB><EM>.
Il existe un unique polynôme </EM><EM><I>P</I></EM><EM> de degré inférieur ou égal à
</EM><EM><I>n</I></EM><EM>, appelé polynome de Lagrange, tel que :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM><I>P</I>(<I>x</I></EM><SUB><EM><I>i</I></EM></SUB><EM>)=<I>y</I></EM><SUB><EM><I>i</I></EM></SUB></TD></TR>
</TABLE><EM>
</EM></DIV><P>Exemple : déterminons le polynome de degré inférieur ou égal
à 2 tel que <I>P</I>(0)=1, <I>P</I>(1)=2, <I>P</I>(2)=1. On commence par <I>P</I><SUB>0</SUB>=1.
Puis on pose <I>P</I><SUB>1</SUB>=<I>P</I><SUB>0</SUB>+<I>aX</I>=1+<I>aX</I>. Comme <I>P</I>(1)=2=1+<I>a</I> on en tire <I>a</I>=1
donc <I>P</I><SUB>1</SUB>=1+<I>X</I>. Puis on pose <I>P</I><SUB>2</SUB>=<I>P</I><SUB>1</SUB>+<I>aX</I>(<I>X</I>&#X2212;1), on a <I>P</I><SUB>2</SUB>(2)=3+2<I>a</I>=1
donc <I>a</I>=&#X2212;1, finalement <I>P</I><SUB>2</SUB>=1+<I>X</I>&#X2212;<I>X</I>(<I>X</I>&#X2212;1).</P><P>On peut calculer le polynome de Lagrange comme indiqué ci-dessus,
la méthode dite des différences divisées permettant de le faire
de la manière la plus efficace possible (cf. par exemple Demailly).</P><P>Reste à estimer l&#X2019;écart entre une fonction et son polynome
interpolateur, on a le :
</P><DIV CLASS="theorem"><B>Théorème 11</B>  <EM> </EM><A NAME="@default2"></A><EM>
Soit </EM><EM><I>f</I></EM><EM> une fonction </EM><EM><I>n</I>+1</EM><EM> fois dérivable sur un intervalle </EM><EM><I>I</I>=[<I>a</I>,<I>b</I>]</EM><EM>
de </EM><EM>&#X211D;</EM><EM>, </EM><EM><I>x</I></EM><SUB><EM>0</EM></SUB><EM>,...,<I>x</I></EM><SUB><EM><I>n</I></EM></SUB><EM> des réels distincts de </EM><EM><I>I</I></EM><EM>. 
Soit </EM><EM><I>P</I></EM><EM> le polynome de Lagrange donné par les </EM><EM><I>x</I></EM><SUB><EM><I>j</I></EM></SUB><EM> et </EM><EM><I>y</I></EM><SUB><EM><I>j</I></EM></SUB><EM>=<I>f</I>(<I>x</I></EM><SUB><EM><I>j</I></EM></SUB><EM>)</EM><EM>.
Pour tout réel </EM><EM><I>x</I> &#X2208; <I>I</I></EM><EM>,
il existe un réel </EM><EM>&#X3BE;</EM><SUB><EM><I>x</I></EM></SUB><EM> &#X2208; [<I>a</I>,<I>b</I>]</EM><EM> (qui dépend de </EM><EM><I>x</I></EM><EM>) tel
que :
</EM><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><EM> </EM><A NAME="eq:lagrange"></A><EM>
<I>f</I>(<I>x</I>)&#X2212;<I>P</I>(<I>x</I>) = </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><I>f</I></EM><SUP><EM>[<I>n</I>+1]</EM></SUP><EM>(&#X3BE;</EM><SUB><EM><I>x</I></EM></SUB><EM>)</EM></TD></TR>
<TR><TD CLASS="hbar"><EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM>(<I>n</I>+1)!</EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM> </EM></TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><EM><EM><I>n</I></EM></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><FONT SIZE=6>&#X220F;</FONT></EM></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><EM><EM><I>j</I>=0</EM></EM></TD></TR>
</TABLE></TD><TD CLASS="dcell"><EM>(<I>x</I>&#X2212;<I>x</I></EM><SUB><EM><I>j</I></EM></SUB><EM>) 
    (35)</EM></TD></TR>
</TABLE><EM>
</EM></DIV><P>
Ainsi l&#X2019;erreur commise dépend d&#X2019;une majoration de la taille
de la dérivée <I>n</I>+1-ième sur l&#X2019;intervalle, mais aussi
de la disposition des points <I>x</I><SUB><I>j</I></SUB> par rapport à <I>x</I>. Par exemple
si les points <I>x</I><SUB><I>j</I></SUB> sont équidistribués, le terme
|&#X220F;<SUB><I>j</I>=0</SUB><SUP><I>n</I></SUP>(<I>x</I>&#X2212;<I>x</I><SUB><I>j</I></SUB>)| sera plus grand près du bord de <I>I</I> qu&#X2019;au
centre de <I>I</I>.</P><P>Preuve du théorème : Si <I>x</I> est l&#X2019;un des <I>x</I><SUB><I>j</I></SUB> l&#X2019;égalité est vraie. Soit 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>C</I>=(<I>f</I>(<I>x</I>)&#X2212;<I>P</I>(<I>x</I>))/</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>x</I>&#X2212;<I>x</I><SUB><I>j</I></SUB>) </TD></TR>
</TABLE><P>
on considère maintenant la fonction :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I>(<I>t</I>)=<I>f</I>(<I>t</I>)&#X2212;<I>P</I>(<I>t</I>) &#X2212; <I>C</I> </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>n</I></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>&#X220F;</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>j</I>=0</TD></TR>
</TABLE></TD><TD CLASS="dcell">(<I>t</I>&#X2212;<I>x</I><SUB><I>j</I></SUB>) </TD></TR>
</TABLE><P>
elle s&#X2019;annule en <I>x</I><SUB><I>j</I></SUB> pour <I>j</I> variant de 0 à <I>n</I> ainsi qu&#X2019;en <I>x</I>
suite au choix de la constante <I>C</I>, donc <I>g</I> s&#X2019;annule au moins <I>n</I>+2 fois
sur l&#X2019;intervalle contenant les <I>x</I><SUB><I>j</I></SUB> et <I>x</I>, donc <I>g</I>&#X2032; s&#X2019;annule au moins
<I>n</I>+1 fois sur ce même intervalle, donc <I>g</I>&#X2032;&#X2032; s&#X2019;annule au moins
<I>n</I> fois, etc. et finalement <I>g</I><SUP>[<I>n</I>+1]</SUP> s&#X2019;annule une fois
au moins sur cet intervalle. Or 
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>g</I><SUP>[<I>n</I>+1]</SUP> = <I>f</I><SUP>[<I>n</I>+1]</SUP> &#X2212; <I>C</I> (<I>n</I>+1)!</TD></TR>
</TABLE><P>
car <I>P</I> est de degré inférieur ou égal à <I>n</I> 
et  &#X220F;<SUB><I>j</I>=0</SUB><SUP><I>n</I></SUP>(<I>x</I>&#X2212;<I>x</I><SUB><I>j</I></SUB>) &#X2212; <I>x</I><SUP><I>n</I>+1</SUP> est de degré
inférieur ou égal à <I>n</I>. Donc il existe bien un réel &#X3BE;<SUB><I>x</I></SUB> dans
l&#X2019;intervalle contenant les <I>x</I><SUB><I>j</I></SUB> et <I>x</I> tel que
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>C</I>=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center"><I>f</I><SUP>[<I>n</I>+1]</SUP>(&#X3BE;<SUB><I>x</I></SUB>)</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center">(<I>n</I>+1)!</TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><!--TOC subsection Différences divisées-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc93">11.2</A>  Différences divisées</H3><!--SEC END --><P>
Le calcul pratique du polynôme de Lagrange se fait efficacement 
dans la base { 1,<I>x</I>&#X2212;<I>x</I><SUB>0</SUB>,...,(<I>x</I>&#X2212;<I>x</I><SUB>0</SUB>)...(<I>x</I>&#X2212;<I>x</I><SUB><I>n</I>&#X2212;1</SUB>)} par
la méthode des différences divisées.
On définit de manière récursive les coefficients
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">[<I>Y</I>]= <I>Y</I>,   
[<I>Y</I><SUB>0</SUB>,...,<I>Y</I><SUB><I>n</I></SUB>]= </TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">[<I>Y</I><SUB>1</SUB>,...,<I>Y</I><SUB><I>n</I></SUB>]&#X2212;[<I>Y</I><SUB>0</SUB>,...,<I>Y</I><SUB><I>n</I>&#X2212;1</SUB>]</TD></TR>
<TR><TD CLASS="hbar"></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>Y</I><SUB><I>n</I></SUB>&#X2212;<I>Y</I><SUB>0</SUB></TD></TR>
</TABLE></TD><TD CLASS="dcell"> </TD></TR>
</TABLE><P>
Le polynome d&#X2019;interpolation est alors donné par :
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>P</I>(<I>x</I>)=[<I>y</I><SUB>0</SUB>]+[<I>y</I><SUB>0</SUB>,<I>y</I><SUB>1</SUB>](<I>x</I>&#X2212;<I>x</I><SUB>0</SUB>)+[<I>y</I><SUB>0</SUB>,<I>y</I><SUB>1</SUB>,<I>y</I><SUB>2</SUB>](<I>x</I>&#X2212;<I>x</I><SUB>0</SUB>)(<I>x</I>&#X2212;<I>x</I><SUB>1</SUB>)
+ ... + [<I>y</I><SUB>0</SUB>,...,<I>y</I><SUB><I>n</I></SUB>](<I>x</I>&#X2212;<I>x</I><SUB>0</SUB>)..(<I>x</I>&#X2212;<I>x</I><SUB><I>n</I>&#X2212;1</SUB>) </TD></TR>
</TABLE><P>
Pour la preuve, cf. par exemple Demailly.</P><!--TOC subsection Les splines-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc94">11.3</A>  Les splines</H3><!--SEC END --><P>
Il s&#X2019;agit de fonctions définies par des polynomes de degré borné
sur des intervalles, dont on fixe la valeur
aux extrémités des intervalles (comme pour le polynome de Lagrange)
ce qui rend la fonction continue, de plus on exige un
degré de régularité plus grand, par exemple etre de classe <I>C</I><SUP>2</SUP>.
Enfin, on fixe des conditions aux bornes de la réunion des 
intervalles, par exemple avoir certaines dérivées nulles. </P><P>Par exemple supposons qu&#X2019;on se donne <I>n</I> intervalles, donc <I>n</I>+1
points <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I></SUB>, on se fixe une régularité <I>C</I><SUP><I>d</I>&#X2212;1</SUP>. Ceci
entraine (<I>n</I>&#X2212;1)<I>d</I> conditions de recollement, on y ajoute <I>n</I>+1
conditions de valeur en <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I></SUB>, on a donc <I>nd</I>+1 conditions,
la borne sur le degré des polynomes doit donc etre <I>d</I> (ou plus,
mais <I>d</I> suffit) ce qui donne <I>n</I>(<I>d</I>+1) degrés de liberté, on
peut donc ajouter <I>d</I>&#X2212;1 conditions, par exemple pour les splines
naturelles, on impose que les dérivées d&#X2019;ordre <I>d</I>/2 à <I>d</I>&#X2212;1
soient nulles en <I>x</I><SUB>0</SUB> et <I>x</I><SUB><I>n</I></SUB> (si <I>d</I> est pair, on commence à
la dérivée <I>d</I>/2+1-ième nulle en <I>x</I><SUB><I>n</I></SUB>).</P><P>Pour trouver les polynomes, on doit donc résoudre un grand système
linéaire. Une méthode permettant de diminuer la taille du système
linéaire à résoudre dans le cas des splines naturelles
consiste à se fixer <I>n</I> inconnues <I>z</I><SUB>0</SUB>,..,<I>z</I><SUB><I>n</I>&#X2212;1</SUB>
représentant les dérivées <I>d</I>-ième de la spline <I>f</I> en
<I>x</I><SUB>0</SUB> sur [<I>x</I><SUB>0</SUB>,<I>x</I><SUB>1</SUB>] à <I>x</I><SUB><I>n</I>&#X2212;1</SUB> sur [<I>x</I><SUB><I>n</I>&#X2212;1</SUB>,<I>x</I><SUB><I>n</I></SUB>], 
et (<I>d</I>&#X2212;1)/2 inconnues <I>f</I><SUB><I>j</I></SUB>, représentant
la valeur de la dérivée de <I>f</I> en <I>x</I><SUB>0</SUB> pour <I>j</I> variant
de 1 à (<I>d</I>&#X2212;1)/2. On peut alors écrire le polynome sur l&#X2019;intervalle
[<I>x</I><SUB>0</SUB>,<I>x</I><SUB>1</SUB>] car on connait son développement de Taylor en <I>x</I><SUB>0</SUB>.
On effectue un changement d&#X2019;origine (par application répétée
de Horner) en <I>x</I><SUB>1</SUB>. On obtient alors le polynome sur [<I>x</I><SUB>1</SUB>,<I>x</I><SUB>2</SUB>]
en remplaçant uniquement la dérivée <I>d</I>-ième par <I>z</I><SUB>1</SUB>.
On continue ainsi jusqu&#X2019;en <I>x</I><SUB><I>n</I>&#X2212;1</SUB>. Le système s&#X2019;obtient en
calculant la valeur du polynome en <I>x</I><SUB>0</SUB>,...,<I>x</I><SUB><I>n</I></SUB> et la nullité
des dérivées d&#X2019;ordre (<I>d</I>&#X2212;1)/2 à <I>d</I>/2 en <I>x</I><SUB><I>n</I></SUB>. On résoud
le système et on remplace pour avoir les valeurs numériques
des coefficients du polynome.</P><!--BEGIN NOTES document-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes">Certains
systèmes de calcul formel (calculatrices par exemple) utilisent d&#X2019;ailleurs des
méthodes spécifiques pour gérer le problème de la fragmentation de
la mémoire, appelés &#X201C;garbage collector&#X201D;. Ce type de méthode
est intégré dans des langages comme Lisp ou Java, en C/C++ on trouve
des libraries pour cela, par exemple GC de Boehm, incluse dans la
distribution de GCC.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note2" HREF="#text2">2</A></DT><DD CLASS="dd-thefootnotes">un quartet=un demi octet
</DD><DT CLASS="dt-thefootnotes"><A NAME="note3" HREF="#text3">3</A></DT><DD CLASS="dd-thefootnotes">Plus précisément deux
piles, la pile de donnée et la pile gérant le flux d&#X2019;exécution. Cette
dernière n&#X2019;est pas visible par l&#X2019;utilisateur
</DD><DT CLASS="dt-thefootnotes"><A NAME="note4" HREF="#text4">4</A></DT><DD CLASS="dd-thefootnotes">Sauf si
on utilise comme dernier argument le nombre d&#X2019;arguments de la fonction ou 
si on utilise (cf. infra) un tag de début de liste d&#X2019;arguments
</DD><DT CLASS="dt-thefootnotes"><A NAME="note5" HREF="#text5">5</A></DT><DD CLASS="dd-thefootnotes">Toutefois une adaptation du logiciel utilisant comme
quantum de base par exemple 32 bits porterait cette limite
à 65536<SUP>65535</SUP>&#X2212;1
</DD><DT CLASS="dt-thefootnotes"><A NAME="note6" HREF="#text6">6</A></DT><DD CLASS="dd-thefootnotes">Rappelons qu&#X2019;il s&#X2019;agit d&#X2019;une
majoration sur la valeur absolue des coefficients des facteurs de <I>P</I>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note7" HREF="#text7">7</A></DT><DD CLASS="dd-thefootnotes">Plus exactement, on multiplie <I>P</I><SUB><I>j</I></SUB> par le
coefficient dominant de <I>P</I> modulo <I>p</I><SUP><I>l</I></SUP>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note8" HREF="#text8">8</A></DT><DD CLASS="dd-thefootnotes">Ici |<I>P</I>| désigne le plus grand
coefficient de <I>P</I> en valeur absolue
</DD><DT CLASS="dt-thefootnotes"><A NAME="note9" HREF="#text9">9</A></DT><DD CLASS="dd-thefootnotes">cette preuve peut être sautée en première
lecture
</DD><DT CLASS="dt-thefootnotes"><A NAME="note10" HREF="#text10">10</A></DT><DD CLASS="dd-thefootnotes">Peut être omise en première lecture
</DD></DL>
<!--END NOTES-->
<!--CUT END -->
<!--HTMLFOOT-->
Retour &#XE0; la page principale de <A HREF="http://www-fourier.ujf-grenoble.fr/parisse/giac_fr.html">Giac/Xcas</A>.<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>Ce document a été traduit de L<sup>A</sup>T<sub>E</sub>X par </EM><A HREF="http://hevea.inria.fr"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A></BLOCKQUOTE></BODY>
</HTML>
