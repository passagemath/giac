Description: fix the documentation build on S390X
Author: Luka Marohnik (upstream)
Forwarded: yes

--- giac.orig/src/markup.cc
+++ giac/src/markup.cc
@@ -1,19 +1,19 @@
 /*  markup.cc
  *
-* copyright (c) 2019 Luka Marohnić
+ * copyright (c) 2019 Luka Marohnić
  *
-* This program is free software;you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation;either version 3 of the License,or
-* (at your option) any later version.
+ * This program is free software;you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation;either version 3 of the License,or
+ * (at your option) any later version.
  *
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY;without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY;without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
-* You should have received a copy of the GNU General Public License
-* along with this program. If not,see <http://www.gnu.org/licenses/>.
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not,see <http://www.gnu.org/licenses/>.
  */
 
 #include "giacPCH.h"
@@ -41,21 +41,28 @@
 namespace giac {
 #endif // ndef NO_NAMESPACE_GIAC
 
-string mml_itimes="<mo>&it;</mo>";
-string mml_cdot="<mo>&middot;</mo>";
-string mml_dot="<mo>.</mo>";
-string mml_times="<mo>&times;</mo>";
-string mml_plus="<mo>+</mo>";
-string mml_minus="<mo>&minus;</mo>";
-string mml_apply="<mo>&af;</mo>";
-string mml_icomma="<mo>&ic;</mo>";
-string mml_i="<mi mathvariant='normal'>i</mi>";
-string mml_e="<mi mathvariant='normal'>e</mi>";
-string mml_d="<mi mathvariant='normal'>d</mi>";
-string mml_re="<mi>&realpart;</mi>";
-string mml_im="<mi>&imagpart;</mi>";
-
-string tex_itimes="\\,";
+const string mml_itimes="<mo>&it;</mo>";
+const string mml_cdot="<mo>&middot;</mo>";
+const string mml_dot="<mo>.</mo>";
+const string mml_times="<mo>&times;</mo>";
+const string mml_plus="<mo>+</mo>";
+const string mml_minus="<mo>&minus;</mo>";
+const string mml_apply="<mo>&af;</mo>";
+const string mml_icomma="<mo>&ic;</mo>";
+const string mml_i="<mi mathvariant='normal'>i</mi>";
+const string mml_e="<mi mathvariant='normal'>e</mi>";
+const string mml_d="<mi mathvariant='normal'>d</mi>";
+const string mml_re="<mi>&realpart;</mi>";
+const string mml_im="<mi>&imagpart;</mi>";
+
+string tex_itimes=" ";
+string tex_mathi="\\mathrm{i}";
+string tex_mathe="\\mathrm{e}";
+string tex_mathd="\\mathrm{d}";
+
+const string tm_Dirac="\\operatorname{\\updelta}";
+const string tm_Heaviside="\\operatorname{\\uptheta}";
+const string tm_Zeta="\\operatorname{\\upzeta}";
 
 bool is_texmacs_compatible_latex_export=false;
 bool force_legacy_conversion_to_latex=false;
@@ -94,7 +101,8 @@
   _MLBLOCK_FUNC=1024,
   _MLBLOCK_POWER=2048,
   _MLBLOCK_DERIVATIVE=4096,
-  _MLBLOCK_HAS_SUBSCRIPT=8192
+  _MLBLOCK_HAS_SUBSCRIPT=8192,
+  _MLBLOCK_LEADING_DIGIT=16384
 };
 
 enum MarkupFlags {
@@ -122,32 +130,6 @@
   return s.rfind(p)+p.length()==s.length();
 }
 
-bool is_latex_command_suffix(const string &s,const string &com,bool delim=false) {
-  string c=com+"{";
-  size_t pos=s.rfind(c);
-  if (pos==string::npos || (delim && pos>0 && (isalnum(s[pos-1]) || s[pos-1]==32)))
-    return false;
-  pos+=c.length();
-  int level=1;
-  while (pos<s.length() && level>0) {
-    if (s[pos]=='{' && s[pos-1]!='\\')
-      ++level;
-    else if (s[pos]=='}' && s[pos-1]!='\\')
-      --level;
-    ++pos;
-  }
-  assert(level==0);
-  return pos==s.length();
-}
-
-bool is_leading_bracket(const string &s) {
-  return is_prefix(s,"\\left(") || is_prefix(s,"\\left\\{") || is_prefix(s,"\\left[");
-}
-
-bool is_closing_bracket(const string &s) {
-  return is_suffix(s,"\\right)") || is_suffix(s,"\\right\\}") || is_suffix(s,"\\right]");
-}
-
 bool is_greek_letter(const string &s) {
   switch (s.size()) {
   case 2:
@@ -172,16 +154,6 @@
   return false;
 }
 
-bool is_tex_greek__suffix(const string &s) {
-  if (!is_suffix(s,"\\_")) return false;
-  int i;
-  for (i=s.size()-2;i-->0;) {
-    if (s[i]=='\\') break;
-  }
-  if (i<0) return false;
-  return is_greek_letter(s.substr(i+1,s.size()-i-3));
-}
-
 bool is_double_letter(const string &s) {
   return s.length()==2 && isalpha(s.at(0)) && s.at(0)==s.at(1);
 }
@@ -201,30 +173,13 @@
 
 extern MarkupBlock gen2markup(const gen &g,int flags,int &idc,GIAC_CONTEXT);
 
-string tex_implmul(const MarkupBlock &ml,const MarkupBlock &prev) {
-  if (is_texmacs_compatible_latex_export &&
-      (((is_latex_command_suffix(prev.latex,"^",true) || is_latex_command_suffix(prev.latex,"_",true)) &&
-        !is_leading_bracket(ml.latex)) ||
-       is_tex_greek__suffix(prev.latex) ||
-       (is_prefix(ml.latex,"\\mathrm{") &&
-        !is_substr(ml.latex.substr(8,ml.latex.find("}",8)-8),"\\_")) ||
-       (is_prefix(ml.latex,"\\operatorname{") &&
-        (prev.latex.empty() || !isdigit(prev.latex[prev.latex.size()-1])) &&
-        !is_latex_command_suffix(prev.latex,"^") && !is_latex_command_suffix(prev.latex,"_")) ||
-       is_latex_command_suffix(prev.latex,"\\mathrm") ||
-       is_latex_command_suffix(prev.latex,"\\operatorname")))
-    return "\\,";
-  else if (!is_texmacs_compatible_latex_export &&
-           (ml.ctype(_MLBLOCK_ELEMAPP) || is_prefix(ml.latex,"\\operatorname{") ||
-            is_leading_bracket(ml.latex) || is_closing_bracket(prev.latex)))
-    return " ";
-  return tex_itimes;
-}
-
 #ifndef KHICAS
 void enable_texmacs_compatible_latex_export(bool yes) {
   is_texmacs_compatible_latex_export=yes;
-  tex_itimes=(yes?" ":"\\,");  
+  tex_itimes=(yes?"\\*":" ");
+  tex_mathi=(yes?"\\mathi ":"\\mathrm{i}");
+  tex_mathe=(yes?"\\mathe ":"\\mathrm{e}");
+  tex_mathd=(yes?"\\mathd ":"\\mathrm{d}");
 }
 #endif
   
@@ -801,7 +756,7 @@
   }
   len_sub=ssub.size();
   if (!ssub.empty() && is_greek_letter(ssub)) {
-    ssub=tex?("\\"+s):("&"+ssub+";");
+    ssub=tex?("\\"+(ssub=="phi"?"varphi":ssub)):("&"+ssub+";");
     len_sub=1;
   }
   if (is_double_letter(s)) {
@@ -818,7 +773,7 @@
                     :(tex?"\\mathrm{"+s+"}":mml_tag("mi",s,ssub.empty()?idc:0,mdf,"bold")));
   if (!ssub.empty()) {
     if (tex)
-      ret+="_{"+(len_sub==1 && !isdigit(ssub[0])?ssub:"\\mathrm{"+ssub+"}")+"}";
+      ret+="_{"+((len_sub==1 || atof(ssub.c_str())!=0)?ssub:"\\mathrm{"+ssub+"}")+"}";
     else
       ret=mml_tag("msub",ret+(ssub=="0" || atof(ssub.c_str())!=0?
                          "<mn>"+ssub+"</mn>":"<mi>"+ssub+"</mi>"),idc);
@@ -976,7 +931,7 @@
       case _IDNT:
         if (!vars.empty() && vars.back()._VECTptr->front()==g)
           vars.back()._VECTptr->back()+=1;
-        vars.push_back(makevecteur(g,1));
+        else vars.push_back(makevecteur(g,1));
         break;
       case _VECT:
         if (!get_derive_vars(*g._VECTptr,vars))
@@ -1012,6 +967,7 @@
 }
 
 string func2markup(const gen &g,bool tex,bool content,int idc=0) {
+  if (g.type==_FUNC) return func2markup(symbolic(*g._FUNCptr,vecteur(0)),tex,content,idc);
   string ret;
   bool has_id=false;
   if (g.is_symb_of_sommet(at_ln) || g.is_symb_of_sommet(at_LN))
@@ -1037,21 +993,27 @@
   else if (g.is_symb_of_sommet(at_atan) || g.is_symb_of_sommet(at_ATAN))
     ret=tex?"\\arctan ":(content? "<arctan/>":"<mi>arctan</mi>");
   else if (g.is_symb_of_sommet(at_acot) || g.is_symb_of_sommet(at_ACOT))
-    ret=tex?"\\operatorname{\\mathrm{arccot} }":(content? "<arccot/>":"<mi>arccot</mi>");
+    ret=tex?"\\operatorname{arccot}"
+           :(content? "<arccot/>":"<mi>arccot</mi>");
   else if (g.is_symb_of_sommet(at_sec) || g.is_symb_of_sommet(at_SEC))
     ret=tex?"\\sec ":(content? "<sec/>":"<mi>sec</mi>");
   else if (g.is_symb_of_sommet(at_csc) || g.is_symb_of_sommet(at_CSC))
     ret=tex?"\\csc ":(content? "<csc/>":"<mi>csc</mi>");
   else if (g.is_symb_of_sommet(at_asec) || g.is_symb_of_sommet(at_ASEC))
-    ret=tex?"\\operatorname{\\mathrm{arcsec} }":(content? "<arcsec/>":"<mi>arcsec</mi>");
+    ret=tex?"\\operatorname{arcsec}"
+           :(content? "<arcsec/>":"<mi>arcsec</mi>");
   else if (g.is_symb_of_sommet(at_acsc) || g.is_symb_of_sommet(at_ACSC))
-    ret=tex?"\\operatorname{\\mathrm{arccsc} }":(content? "<arccsc/>":"<mi>arccsc</mi>");
+    ret=tex?"\\operatorname{arccsc}"
+           :(content? "<arccsc/>":"<mi>arccsc</mi>");
   else if (g.is_symb_of_sommet(at_asinh) || g.is_symb_of_sommet(at_ASINH))
-    ret=tex?"\\operatorname{\\mathrm{arsinh} }":(content? "<arcsinh/>":"<mi>arsinh</mi>");
+    ret=tex?"\\operatorname{arsinh}"
+           :(content? "<arcsinh/>":"<mi>arsinh</mi>");
   else if (g.is_symb_of_sommet(at_acosh) || g.is_symb_of_sommet(at_ACOSH))
-    ret=tex?"\\operatorname{\\mathrm{arcosh} }":(content? "<arccosh/>":"<mi>arcosh</mi>");
+    ret=tex?"\\operatorname{arcosh}"
+           :(content? "<arccosh/>":"<mi>arcosh</mi>");
   else if (g.is_symb_of_sommet(at_atanh) || g.is_symb_of_sommet(at_ATANH))
-    ret=tex?"\\operatorname{\\mathrm{artanh} }":(content? "<arctanh/>":"<mi>artanh</mi>");
+    ret=tex?"\\operatorname{artanh}"
+           :(content? "<arctanh/>":"<mi>artanh</mi>");
   else {
     if (g.is_symb_of_sommet(at_id) && content) ret="<ident/>";
     else if (g.is_symb_of_sommet(at_gcd) && content) ret="<gcd/>";
@@ -1062,25 +1024,31 @@
     else if (g.is_symb_of_sommet(at_max) && content) ret="<max/>";
     else if (g.is_symb_of_sommet(at_min) && content) ret="<min/>";
     else if (g.is_symb_of_sommet(at_det) && content) ret="<determinant/>";
-    else if (g.is_symb_of_sommet(at_Dirac) && !content) ret=tex?"\\delta":"<mi>&delta;</mi>";
-    else if (g.is_symb_of_sommet(at_Heaviside) && !content) ret=tex?"\\Theta":"<mi>&Theta;</mi>";
+    else if (g.is_symb_of_sommet(at_Dirac) && !content)
+      ret=tex?(is_texmacs_compatible_latex_export?tm_Dirac:"\\operatorname{\\delta}"):"<mi>&delta;</mi>";
+    else if (g.is_symb_of_sommet(at_Heaviside) && !content)
+      ret=tex?(is_texmacs_compatible_latex_export?tm_Heaviside:"\\operatorname{\\theta}"):"<mi>&theta;</mi>";
     else if (g.is_symb_of_sommet(at_Gamma))
       ret=tex?"\\Gamma":(content?mml_csymbol("gamma","hypergeo0")
                                        :"<mi mathvariant='normal'>&Gamma;</mi>");
     else if (g.is_symb_of_sommet(at_Beta))
       ret=tex?"\\Beta":(content?mml_csymbol("beta","hypergeo0")
-                                     :"<mi mathvariant='normal'>&Beta;</mi>");
+                                      :"<mi mathvariant='normal'>&Beta;</mi>");
     else if (g.is_symb_of_sommet(at_euler))
       ret=tex?"\\phi":(content?mml_csymbol("euler","integer2")
                                      :"<mi mathvariant='normal'>&phi;</mi>");
     else if (g.is_symb_of_sommet(at_Airy_Ai))
-      ret=tex?"\\mathrm{Ai}":(content?mml_csymbol("Ai","airy"):"<mi>Ai</mi>");
+      ret=tex?"\\operatorname{Ai}"
+             :(content?mml_csymbol("Ai","airy"):"<mi>Ai</mi>");
     else if (g.is_symb_of_sommet(at_Airy_Bi))
-      ret=tex?"\\mathrm{Bi}":(content?mml_csymbol("Bi","airy"):"<mi>Bi</mi>");
+      ret=tex?"\\operatorname{Bi}"
+             :(content?mml_csymbol("Bi","airy"):"<mi>Bi</mi>");
     else if (g.is_symb_of_sommet(at_Psi) && !content)
-      ret=tex?"\\Psi":"<mi mathvariant='normal'>&Psi;</mi>";
+      ret=tex?"\\Psi"
+             :"<mi mathvariant='normal'>&Psi;</mi>";
     else if (g.is_symb_of_sommet(at_Zeta) && !content)
-      ret=tex?"\\zeta":"<mi mathvariant='normal'>&zeta;</mi>";
+      ret=tex?(is_texmacs_compatible_latex_export?tm_Zeta:"\\zeta")
+             :"<mi mathvariant='normal'>&zeta;</mi>";
     else {
       if (!tex && content)
         ret=mml_tag("ci",g._SYMBptr->sommet.ptr()->s,idc,"type","function");
@@ -1088,8 +1056,8 @@
         ret=idnt2markup(g._SYMBptr->sommet.ptr()->s,tex,false,idc);
       has_id=true;
     }
-    if (tex)
-      ret="\\operatorname{"+ret+" }";
+    if (tex && ret.length()>1 && isalpha(ret.at(0)))
+      ret="\\operatorname{"+ret+"}";
   }
   if (!tex && !has_id)
     ret=insert_id(ret,idc,content);
@@ -1201,6 +1169,7 @@
       if (tex)
         ml.latex=str;
     }
+    ml.type|=_MLBLOCK_LEADING_DIGIT;
     return ml;
   case _DOUBLE_:
   case _REAL:
@@ -1226,12 +1195,15 @@
         string ex=str.substr(cpos+2);
         while (ex[0]=='0')
           ex.erase(ex.begin());
+        string mant=str.substr(0,cpos);
+        if (mant.find('.')==string::npos)
+          mant+=".0";
         if (mml_presentation)
-          ml.markup=mml_tag("mrow","<mn>"+str.substr(0,cpos)+
+          ml.markup=mml_tag("mrow","<mn>"+mant+
                             "</mn><mo>&times;</mo><msup><mn>10</mn><mrow>"+
                             string(str[cpos+1]=='-'?mml_minus:"")+"<mn>"+ex+"</mn></mrow></msup>",idc);
         if (tex)
-          ml.latex=str.substr(0,cpos)+"\\times10^{"+string(str[cpos+1]=='-'?"-":"")+ex+"}";
+          ml.latex=mant+"\\times10^{"+string(str[cpos+1]=='-'?"-":"")+ex+"}";
       } else {
         if (mml_presentation)
           ml.markup=mml_tag("mn",str,idc);
@@ -1239,6 +1211,7 @@
           ml.latex=str;
       }
     }
+    ml.type|=_MLBLOCK_LEADING_DIGIT;
     return ml;
   case _CPLX:
     if (is_zero(im(g,contextptr)))
@@ -1251,7 +1224,7 @@
         if (mml_presentation)
           ml.markup=insert_id(mml_i,idc,false);
         if (tex)
-          ml.latex="\\mathrm{i}";
+          ml.latex=tex_mathi;
         ml.neg=is_minus_one(im(g,contextptr));
       } else {
         tmp=gen2markup(im(g,contextptr),flags | _MARKUP_FACTOR,idc,contextptr);
@@ -1264,7 +1237,7 @@
         if (mml_presentation)
           ml.markup=mml_tag("mrow",tmp.markup+mml_itimes+mml_i,idc);
         if (tex)
-          ml.latex=tmp.latex+"\\,\\mathrm{i}";
+          ml.latex=tmp.latex+tex_itimes+tex_mathi;
       }
       return ml;
     }
@@ -1286,7 +1259,7 @@
                                (isone?"":right.markup+mml_itimes)+mml_i,
                         idc);
     if (tex)
-      ml.latex=left.latex+(right.neg?"-":"+")+(isone?"":right.latex+"\\,")+"\\mathrm{i}";
+      ml.latex=left.latex+(right.neg?"-":"+")+(isone?"":right.latex+tex_itimes)+tex_mathi;
     return ml;
   case _FRAC:
     ml.type=_MLBLOCK_FRACTION;
@@ -1323,14 +1296,14 @@
       if (mml_presentation)
         ml.markup=mml_tag("mi","&pi;",idc);
       if (tex)
-        ml.latex="\\pi ";
+        ml.latex=(is_texmacs_compatible_latex_export?"\\mathpi ":"\\pi ");
     } else if (g==cst_euler_gamma) {
       if (mml_content)
         ml.content=insert_id("<eulergamma/>",++idc,true);
       if (mml_presentation)
         ml.markup=mml_tag("mi","&gamma;",idc);
       if (tex)
-        ml.latex="\\gamma ";
+        ml.latex=(is_texmacs_compatible_latex_export?"\\matheuler ":"\\gamma ");
     } else {
       if (mml_content) {
         str=g.print(contextptr);
@@ -1485,8 +1458,8 @@
         ml.content=mml_tag("set",ml.content,++idc);
       ld="{";
       rd="}";
-      ld_tex="\\{";
-      rd_tex="\\}";
+      ld_tex=(is_texmacs_compatible_latex_export?"\\llbracket ":"\\{");
+      rd_tex=(is_texmacs_compatible_latex_export?"\\rrbracket ":"\\}");
       break;
     default:
       if (mml_content)
@@ -1508,6 +1481,15 @@
       ml.neg=!ml.neg;
       return ml;
     }
+    if (g.is_symb_of_sommet(at_epsilon)) {
+      if (tex)
+        ml.latex="\\varepsilon ";
+      if (mml_presentation)
+        ml.markup="&epsilon;";
+      if (mml_content)
+        ml.content=mml_tag("ci",g.print(contextptr),++idc);
+      return ml;
+    }
     if (g.is_symb_of_sommet(at_plus) || g.is_symb_of_sommet(at_pointplus)) {
       const gen &arg=g._SYMBptr->feuille;
       if (vectarg) {
@@ -1668,13 +1650,12 @@
               (isinv && dc<den_count))))
           parenthesize(tmp,flags);
         is_cdot=
-            tmp.ctype(_MLBLOCK_NUMERIC_EXACT) || tmp.ctype(_MLBLOCK_NUMERIC_APPROX) ||
-            tmp.ctype(_MLBLOCK_SUBTYPE_IDNT) || tmp.ctype(_MLBLOCK_FACTORIAL) ||
-            prev.ctype(_MLBLOCK_SUBTYPE_IDNT) ||
+            tmp.ctype(_MLBLOCK_LEADING_DIGIT) || tmp.ctype(_MLBLOCK_SUBTYPE_IDNT) ||
+            tmp.ctype(_MLBLOCK_FACTORIAL) || prev.ctype(_MLBLOCK_SUBTYPE_IDNT) ||
             (tmp.ctype(_MLBLOCK_FRACTION) && prev.ctype(_MLBLOCK_FRACTION)) ||
             (prev.ctype(_MLBLOCK_ELEMAPP) && prev.appl);
         prod_sign=is_cdot?mml_cdot:mml_itimes;
-        prod_sign_tex=is_cdot?"\\cdot ":tex_implmul(tmp,prev);
+        prod_sign_tex=is_cdot?"\\cdot ":tex_itimes;
         if (isinv) {
           pden=tmp;
           if (mml_content)
@@ -1809,6 +1790,8 @@
       tmp=gen2markup(g._SYMBptr->feuille,flags,idc,contextptr);
       if (isfactor && tmp.priority>_PRIORITY_MUL)
         parenthesize(tmp,flags);
+      if (tmp.ctype(_MLBLOCK_LEADING_DIGIT))
+        ml.type=_MLBLOCK_LEADING_DIGIT;
       ml.priority=_PRIORITY_UNARY;
       ml.neg=tmp.neg;
       if (mml_content)
@@ -1827,7 +1810,7 @@
         if (mml_presentation)
           ml.markup=insert_id(mml_e,idc,false);
         if (tex)
-          ml.latex="\\mathrm{e}";
+          ml.latex=tex_mathe;
       } else {
         tmp=gen2markup(g._SYMBptr->feuille,flags,idc,contextptr);
         prepend_minus(tmp,flags);
@@ -1838,7 +1821,7 @@
         if (mml_presentation)
           ml.markup=mml_tag("msup",mml_e+tmp.markup,idc);
         if (tex)
-          ml.latex="\\mathrm{e}^{"+tmp.latex+"}";
+          ml.latex=tex_mathe+"^{"+tmp.latex+"}";
       }
       return ml;
     }
@@ -1923,6 +1906,8 @@
                      left.latex.substr(left.split_pos_tex);
         } else {
           ml.type=_MLBLOCK_POWER;
+          if (left.ctype(_MLBLOCK_LEADING_DIGIT))
+            ml.type|=_MLBLOCK_LEADING_DIGIT;
           if (left.appl || left.priority>=ml.priority)
             parenthesize(left,flags);
           if (mml_presentation)
@@ -2055,7 +2040,7 @@
             if (mml_presentation)
               var.markup=mml_itimes+mml_d+var.markup;
             if (tex)
-              var.latex="\\,\\mathrm{d}"+var.latex;
+              var.latex=(is_texmacs_compatible_latex_export?tex_itimes:"\\,")+tex_mathd+var.latex;
           }
         }
         if (!has_lb && args.size()>2) {
@@ -2109,8 +2094,13 @@
       }
       if (mml_presentation)
         ml.markup=mml_tag("mrow",big+e.markup+(isint?var.markup:""),idc);
-      if (tex)
+      if (tex) {
         ml.latex=big_tex+e.latex+(isint?var.latex:"");
+        /*
+        if (is_texmacs_compatible_latex_export)
+          ml.latex+="\\bignone ";
+        */
+      }
       return ml;
     }
     if ((g.is_symb_of_sommet(at_limit) || g.is_symb_of_sommet(at_limite)) &&
@@ -2127,8 +2117,6 @@
       else {
         if (mml_presentation)
           e.markup=mml_apply+e.markup;
-        if (tex)
-          e.latex="\\;"+e.latex;
       }
       if (args.size()>=2) {
         if (args[1].is_symb_of_sommet(at_equal)) {
@@ -2272,13 +2260,13 @@
                               :mml_tag("mrow",mml_tag("mfrac",mml_d+mml_tag("mrow",var.markup))+
                                               mml_apply+tmp.markup,idc);
               if (tex)
-                ml.latex=simp?"\\frac{\\mathrm{d}"+tmp.latex+"}{\\mathrm{d}"+var.latex+"}"
-                             :"\\frac{\\mathrm{d}}{\\mathrm{d}"+var.latex+"}"+tex_itimes+tmp.latex;
+                ml.latex=simp?"\\frac{"+tex_mathd+tmp.latex+"}{"+tex_mathd+var.latex+"}"
+                             :"\\frac{"+tex_mathd+"}{"+tex_mathd+var.latex+"}"+tmp.latex;
               return ml;
             }
             if (vars.size()>0) {
               string ds(vars.size()>1?"<mo>&part;</mo>":mml_d);
-              string ds_tex(vars.size()>1?"\\partial ":"\\mathrm{d}");
+              string ds_tex(vars.size()>1?"\\partial ":tex_mathd);
               int c=0;
               gen N(0);
               for (const_iterateur it=vars.begin();it!=vars.end();++it) {
@@ -2315,7 +2303,7 @@
                                               "<mrow>"+ml.markup+"</mrow>")+mml_apply+tmp.markup,idc);
               if (tex)
                 ml.latex=simp?"\\frac{"+ds_tex+"^{"+Ns+"}"+tmp.latex+"}{"+ml.latex+"}"
-                             :"\\frac{"+ds_tex+"^{"+Ns+"}}{"+ml.latex+"}"+tex_itimes+tmp.latex;
+                             :"\\frac{"+ds_tex+"^{"+Ns+"}}{"+ml.latex+"}"+tmp.latex;
               return ml;
             }
           }
@@ -2723,7 +2711,7 @@
           ml.latex="\\left("+ml.latex+"\\right)\\mapsto "+tmp.latex;
       } else {
         get_leftright(
-          makevecteur(args[0].type==_VECT?args[0]._VECTptr->front():args[0],args[2]),
+          makevecteur(args[0].type==_VECT && !args[0]._VECTptr->empty()?args[0]._VECTptr->front():args[0],args[2]),
           &ml,left,right,flags,idc,contextptr);
         if (mml_content)
           ml.content=mml_tag("lambda","<bvar>"+left.content+"</bvar>"+right.content,++idc);
@@ -3078,6 +3066,7 @@
   int idc=0,flags=_MARKUP_TOPLEVEL | _MARKUP_ELEMPOW | _MARKUP_LATEX;
   ml=gen2markup(g,flags,idc,contextptr);
   prepend_minus(ml,flags);
+  //*logptr(contextptr) << ml.latex << "\n";
   return ml.latex;
 }
 
